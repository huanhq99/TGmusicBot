--- main.py.backup	2025-12-12 13:45:08
+++ main.py.broken	2025-12-12 13:25:20
@@ -1,297 +1,3 @@
-#!/usr/bin/env python3
-"""
-TGmusicbot - Telegram Bot for Music Management
-åŠŸèƒ½ï¼šæ­Œå•åŒæ­¥åˆ° Emby + éŸ³ä¹ä¸Šä¼ åˆ° NAS
-"""
-
-import logging
-import os
-import json
-import time
-import re
-import html
-import sqlite3
-import asyncio
-import shutil
-from datetime import datetime, timedelta
-from urllib.parse import urljoin
-from pathlib import Path
-from cryptography.fernet import Fernet
-
-import requests
-from requests.adapters import HTTPAdapter
-from urllib3.util.retry import Retry
-from rapidfuzz import fuzz
-from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InlineQueryResultArticle, InputTextMessageContent, BotCommand
-from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler, InlineQueryHandler
-
-# åŠ è½½ç¯å¢ƒå˜é‡
-from dotenv import load_dotenv
-load_dotenv()
-
-# --- å…¨å±€é…ç½® ---
-APP_NAME = "TGmusicbot"
-APP_VERSION = "1.7.9"
-EMBY_CLIENT_NAME = "TGmusicbot"
-DEVICE_ID = "TGmusicbot_Device_v2"
-
-# è·¯å¾„é…ç½®
-SCRIPT_DIR = Path(__file__).parent.parent
-DATA_DIR = Path(os.environ.get('DATA_DIR', SCRIPT_DIR / 'data'))
-UPLOAD_DIR = Path(os.environ.get('UPLOAD_DIR', '/tmp/tgmusicbot_uploads'))
-MUSIC_TARGET_DIR = Path(os.environ.get('MUSIC_TARGET_DIR', SCRIPT_DIR / 'uploads'))
-
-DATA_DIR.mkdir(parents=True, exist_ok=True)
-UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
-MUSIC_TARGET_DIR.mkdir(parents=True, exist_ok=True)
-
-DATABASE_FILE = DATA_DIR / 'bot.db'
-LIBRARY_CACHE_FILE = DATA_DIR / 'library_cache.json'
-LOG_FILE = DATA_DIR / f'bot_{datetime.now().strftime("%Y%m%d")}.log'
-
-# ç¯å¢ƒå˜é‡é…ç½®
-TELEGRAM_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN') or os.environ.get('TELEGRAM_TOKEN')
-TELEGRAM_API_URL = os.environ.get('TELEGRAM_API_URL', '')  # Local Bot API Server URL, e.g. http://localhost:8081/bot
-ADMIN_USER_ID = os.environ.get('ADMIN_USER_ID')
-EMBY_URL = os.environ.get('EMBY_URL')
-EMBY_USERNAME = os.environ.get('EMBY_USERNAME')
-EMBY_PASSWORD = os.environ.get('EMBY_PASSWORD')
-
-# Emby Webhook é€šçŸ¥å¼€å…³
-EMBY_WEBHOOK_NOTIFY = os.environ.get('EMBY_WEBHOOK_NOTIFY', 'true').lower() == 'true'
-MAKE_PLAYLIST_PUBLIC = os.environ.get('MAKE_PLAYLIST_PUBLIC', 'false').lower() == 'true'
-
-# ç½‘æ˜“äº‘/QQéŸ³ä¹ä¸‹è½½é…ç½®
-NCM_COOKIE = os.environ.get('NCM_COOKIE', '')  # ç½‘æ˜“äº‘ç™»å½• Cookie
-QQ_COOKIE = os.environ.get('QQ_COOKIE', '')  # QQéŸ³ä¹ç™»å½• Cookie
-NCM_QUALITY = os.environ.get('NCM_QUALITY', 'exhigh')  # ä¸‹è½½éŸ³è´¨: standard/higher/exhigh/lossless/hires
-AUTO_DOWNLOAD = os.environ.get('AUTO_DOWNLOAD', 'false').lower() == 'true'  # æ˜¯å¦è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²
-
-# å›½å†…ä»£ç†æœåŠ¡é…ç½®ï¼ˆç”¨äºæµ·å¤– VPS ä¸‹è½½ QQ/ç½‘æ˜“äº‘éŸ³ä¹ï¼‰
-MUSIC_PROXY_URL = os.environ.get('MUSIC_PROXY_URL', '')  # å¦‚ http://å›½å†…IP:8899
-MUSIC_PROXY_KEY = os.environ.get('MUSIC_PROXY_KEY', '')  # ä»£ç† API Key
-
-# å®šæ—¶æ‰«æ Emby åª’ä½“åº“ï¼ˆå°æ—¶ï¼Œ0 è¡¨ç¤ºç¦ç”¨ï¼‰
-EMBY_SCAN_INTERVAL = int(os.environ.get('EMBY_SCAN_INTERVAL', '0'))
-
-# Pyrogram é…ç½®ï¼ˆå¤§æ–‡ä»¶ä¸Šä¼ æ”¯æŒï¼Œå¯é€‰ï¼‰
-TG_API_ID = os.environ.get('TG_API_ID', '')
-TG_API_HASH = os.environ.get('TG_API_HASH', '')
-
-# å…è®¸ä¸Šä¼ çš„éŸ³é¢‘æ ¼å¼
-ALLOWED_AUDIO_EXTENSIONS = ('.mp3', '.flac', '.m4a', '.wav', '.ogg', '.aac', '.ape', '.wma', '.alac', '.aiff', '.dsd', '.dsf', '.dff')
-
-# Pyrogram å®¢æˆ·ç«¯ï¼ˆç”¨äºæ¥æ”¶å¤§æ–‡ä»¶ï¼‰
-pyrogram_client = None
-
-
-def get_ncm_cookie():
-    """è·å–ç½‘æ˜“äº‘ Cookieï¼ˆä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼‰"""
-    try:
-        if database_conn:
-            cursor = database_conn.cursor()
-            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('ncm_cookie',))
-            row = cursor.fetchone()
-            if row:
-                # row å¯èƒ½æ˜¯ tuple æˆ– dict
-                value = row['value'] if isinstance(row, dict) else row[0]
-                if value:
-                    return value
-    except Exception as e:
-        logger.error(f"è¯»å– ncm_cookie å¤±è´¥: {e}")
-    return NCM_COOKIE  # å›é€€åˆ°ç¯å¢ƒå˜é‡
-
-
-def get_qq_cookie():
-    """è·å– QQéŸ³ä¹ Cookieï¼ˆä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼‰"""
-    try:
-        if database_conn:
-            cursor = database_conn.cursor()
-            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('qq_cookie',))
-            row = cursor.fetchone()
-            if row:
-                # row å¯èƒ½æ˜¯ tuple æˆ– dict
-                value = row['value'] if isinstance(row, dict) else row[0]
-                if value:
-                    return value
-    except Exception as e:
-        logger.error(f"è¯»å– qq_cookie å¤±è´¥: {e}")
-    return QQ_COOKIE  # å›é€€åˆ°ç¯å¢ƒå˜é‡
-
-
-# ä¸‹è½½ç®¡ç†å™¨ï¼ˆå…¨å±€å®ä¾‹ï¼‰
-from bot.download_manager import DownloadManager, init_download_manager as _init_dm, get_download_manager
-
-download_manager = None
-
-
-# åŠ å¯†å¯†é’¥
-ENCRYPTION_KEY = os.environ.get('PLAYLIST_BOT_KEY')
-if not ENCRYPTION_KEY:
-    ENCRYPTION_KEY = Fernet.generate_key().decode()
-    print(f"è­¦å‘Šï¼šæœªè®¾ç½® PLAYLIST_BOT_KEYï¼Œå·²ç”Ÿæˆæ–°å¯†é’¥ï¼š{ENCRYPTION_KEY}")
-
-fernet = Fernet(ENCRYPTION_KEY.encode())
-
-# API ç«¯ç‚¹
-QQ_API_GET_PLAYLIST_URL = "http://i.y.qq.com/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg"
-NCM_API_PLAYLIST_DETAIL_URL = "https://music.163.com/api/v3/playlist/detail"
-NCM_API_SONG_DETAIL_URL = "https://music.163.com/api/song/detail/"
-
-# åŒ¹é…å‚æ•°
-MATCH_THRESHOLD = 9
-EMBY_SCAN_PAGE_SIZE = 2000
-EMBY_PLAYLIST_ADD_BATCH_SIZE = 200
-
-# --- å…¨å±€çŠ¶æ€ ---
-emby_library_data = []
-emby_auth = {'access_token': None, 'user_id': None}
-database_conn = None
-requests_session = None
-ncm_downloader = None  # ç½‘æ˜“äº‘ä¸‹è½½å™¨å®ä¾‹
-
-# æœç´¢ç¼“å­˜ï¼ˆé¿å…é‡å¤ API è°ƒç”¨ï¼‰
-_cmd_search_cache = {}  # {(platform, keyword): (timestamp, results)}
-_cmd_search_cache_ttl = 180  # 3åˆ†é’Ÿ
-
-
-# ============================================================
-# è¿›åº¦æ¡å·¥å…·å‡½æ•°
-# ============================================================
-
-def make_progress_bar(current: int, total: int, width: int = 10) -> str:
-    """
-    ç”Ÿæˆæ–‡æœ¬è¿›åº¦æ¡
-    
-    Args:
-        current: å½“å‰è¿›åº¦
-        total: æ€»æ•°
-        width: è¿›åº¦æ¡å®½åº¦ï¼ˆå­—ç¬¦æ•°ï¼‰
-        
-    Returns:
-        è¿›åº¦æ¡å­—ç¬¦ä¸²ï¼Œå¦‚ "â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘ 50%"
-    """
-    if total <= 0:
-        return "â–‘" * width + " 0%"
-    
-    percent = min(current / total, 1.0)
-    filled = int(width * percent)
-    empty = width - filled
-    
-    bar = "â–“" * filled + "â–‘" * empty
-    percent_text = f"{int(percent * 100)}%"
-    
-    return f"{bar} {percent_text}"
-
-
-def make_progress_message(title: str, current: int, total: int, 
-                          current_item: str = "", extra_info: str = "") -> str:
-    """
-    ç”Ÿæˆå®Œæ•´çš„è¿›åº¦æ¶ˆæ¯
-    
-    Args:
-        title: æ ‡é¢˜ï¼ˆå¦‚ ğŸ“¥ ä¸‹è½½ä¸­ï¼‰
-        current: å½“å‰è¿›åº¦
-        total: æ€»æ•°
-        current_item: å½“å‰å¤„ç†çš„é¡¹ç›®åç§°
-        extra_info: é¢å¤–ä¿¡æ¯
-        
-    Returns:
-        æ ¼å¼åŒ–çš„è¿›åº¦æ¶ˆæ¯
-    """
-    bar = make_progress_bar(current, total)
-    msg = f"{title}\n\n{bar}\nğŸ“Š {current}/{total}"
-    
-    if current_item:
-        # æˆªæ–­è¿‡é•¿çš„é¡¹ç›®å
-        if len(current_item) > 35:
-            current_item = current_item[:32] + "..."
-        msg += f"\n\nğŸµ `{current_item}`"
-    
-    if extra_info:
-        msg += f"\n\n{extra_info}"
-    
-    return msg
-
-
-def escape_markdown(text: str) -> str:
-    """
-    è½¬ä¹‰ Telegram Markdown ç‰¹æ®Šå­—ç¬¦
-    
-    Args:
-        text: åŸå§‹æ–‡æœ¬
-        
-    Returns:
-        è½¬ä¹‰åçš„æ–‡æœ¬
-    """
-    if not text:
-        return ''
-    # Markdown ç‰¹æ®Šå­—ç¬¦: _ * [ ] ( ) ~ ` > # + - = | { } . !
-    special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
-    for char in special_chars:
-        text = text.replace(char, f'\\{char}')
-    return text
-
-
-async def start_pyrogram_client():
-    """å¯åŠ¨ Pyrogram å®¢æˆ·ç«¯ç”¨äºæ¥æ”¶å¤§æ–‡ä»¶"""
-    global pyrogram_client
-    
-    if not TG_API_ID or not TG_API_HASH:
-        logger.info("æœªé…ç½® TG_API_ID/TG_API_HASHï¼Œå¤§æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½æœªå¯ç”¨")
-        return
-    
-    try:
-        from pyrogram import Client, filters as pyro_filters
-        from pyrogram.handlers import MessageHandler as PyroMessageHandler
-        
-        # åˆ›å»º Pyrogram å®¢æˆ·ç«¯ï¼ˆBot æ¨¡å¼ï¼‰
-        pyrogram_client = Client(
-            name="tgmusicbot_pyrogram",
-            api_id=int(TG_API_ID),
-            api_hash=TG_API_HASH,
-            bot_token=TELEGRAM_TOKEN,
-            workdir=str(DATA_DIR)
-        )
-        
-        @pyrogram_client.on_message(pyro_filters.audio | pyro_filters.document)
-        async def handle_large_file(client, message):
-            """å¤„ç†å¤§æ–‡ä»¶ä¸Šä¼ ï¼ˆPyrogramï¼‰"""
-            user_id = str(message.from_user.id)
-            
-            # è·å–æ–‡ä»¶ä¿¡æ¯
-            if message.audio:
-                file = message.audio
-                original_name = file.file_name or f"{file.title or 'audio'}.mp3"
-                file_size = file.file_size or 0
-            elif message.document:
-                file = message.document
-                original_name = file.file_name or "unknown"
-                mime = file.mime_type or ""
-                # åªå¤„ç†éŸ³é¢‘æ–‡ä»¶
-                if not (mime.startswith('audio/') or original_name.lower().endswith(ALLOWED_AUDIO_EXTENSIONS)):
-                    return
-                file_size = file.file_size or 0
-            else:
-                return
-            
-            # åªå¤„ç†å¤§äº 20MB çš„æ–‡ä»¶ï¼Œå°æ–‡ä»¶ç”± python-telegram-bot å¤„ç†
-            if file_size <= 20 * 1024 * 1024:
-                return
-            
-            try:
-                status_msg = await message.reply_text(f"ğŸ“¥ æ­£åœ¨ä¸‹è½½å¤§æ–‡ä»¶: {original_name} ({file_size / 1024 / 1024:.1f} MB)...")
-                
-                # è·å–ä¸‹è½½è®¾ç½®
-                ncm_settings = get_ncm_settings()
-                download_mode = ncm_settings.get('download_mode', 'local')
-                download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
-                musictag_dir = ncm_settings.get('musictag_dir', '')
-                
-                # ç¡®ä¿ç›®å½•å­˜åœ¨
-                download_path = Path(download_dir)
-                download_path.mkdir(parents=True, exist_ok=True)
-                
                 # ä½¿ç”¨ Pyrogram ä¸‹è½½å¤§æ–‡ä»¶
                 temp_path = UPLOAD_DIR / original_name
                 await message.download(file_name=str(temp_path))
@@ -816,79 +522,94 @@
 
 def process_playlist(playlist_url, user_id=None, force_public=False, user_binding=None, match_mode="æ¨¡ç³ŠåŒ¹é…"):
     playlist_type, playlist_id = parse_playlist_input(playlist_url)
-    if not playlist_type:
-        return None, "æ— æ³•è¯†åˆ«çš„æ­Œå•é“¾æ¥"
-    
-    # ç”¨æˆ·è®¤è¯
-    if user_binding:
-        token, emby_user_id = authenticate_emby(EMBY_URL, user_binding['emby_username'], user_binding['emby_password'])
-        if not token:
-            return None, "Emby è®¤è¯å¤±è´¥"
-        temp_auth = {'access_token': token, 'user_id': emby_user_id}
-    else:
-        temp_auth = None
-    
-    # è·å–æ­Œå•
-    logger.info(f"å¤„ç† {playlist_type.upper()} æ­Œå•: {playlist_id}")
-    if playlist_type == "qq":
-        source_name, source_songs = get_qq_playlist_details(playlist_id)
-    elif playlist_type == "spotify":
-        source_name, source_songs = get_spotify_playlist_details(playlist_id)
-    else:  # netease
-        source_name, source_songs = get_ncm_playlist_details(playlist_id)
-    
-    source_songs = [s for s in source_songs if s and s.get('title')]
-    if not source_songs:
-        return None, "æ— æ³•è·å–æ­Œå•å†…å®¹"
-    
-    # æ„å»ºç´¢å¼•å¹¶åŒ¹é…
-    emby_index = {}
-    for track in emby_library_data:
-        key = _get_title_lookup_key(track.get('title'))
-        if key: emby_index.setdefault(key, []).append(track)
-    
-    matched_ids, unmatched = [], []
-    for source_track in source_songs:
-        key = _get_title_lookup_key(source_track.get('title'))
-        match = find_best_match(source_track, emby_index.get(key, []), match_mode)
-        if match:
-            matched_ids.append(match['id'])
-        else:
-            unmatched.append(source_track)
-    
-    logger.info(f"åŒ¹é…å®Œæˆ: {len(matched_ids)} æˆåŠŸ, {len(unmatched)} å¤±è´¥")
-    
-    if not matched_ids:
-        return None, f"æ­Œå• '{source_name}' æœªåŒ¹é…åˆ°ä»»ä½•æ­Œæ›²"
-    
-    # åˆ é™¤åŒåæ­Œå•
-    user_api_id = temp_auth['user_id'] if temp_auth else emby_auth['user_id']
-    for p in get_user_emby_playlists(temp_auth or emby_auth):
-        if p.get('name') == source_name:
-            call_emby_api(f"Items/{p['id']}", {}, method='DELETE', user_auth=temp_auth)
-            break
-    
-    # åˆ›å»ºæ­Œå•
-    is_public = force_public or (MAKE_PLAYLIST_PUBLIC and user_id == ADMIN_USER_ID)
-    create_response = call_emby_api("Playlists", 
-                                   {'Name': source_name, 'MediaType': 'Audio', 'UserId': user_api_id},
-                                   method='POST', data={'Name': source_name, 'MediaType': 'Audio'},
-                                   user_auth=temp_auth)
-    
-    if not create_response or 'Id' not in create_response:
-        return None, "åˆ›å»ºæ­Œå•å¤±è´¥"
-    
-    new_playlist_id = create_response['Id']
-    if is_public:
-        call_emby_api(f"Items/{new_playlist_id}/MakePublic", {}, method='POST', user_auth=temp_auth)
-    
-    # æ·»åŠ æ­Œæ›²
-    unique_ids = list(dict.fromkeys(matched_ids))
-    for i in range(0, len(unique_ids), EMBY_PLAYLIST_ADD_BATCH_SIZE):
-        batch = unique_ids[i:i + EMBY_PLAYLIST_ADD_BATCH_SIZE]
-        call_emby_api(f"Playlists/{new_playlist_id}/Items",
-                     {'Ids': ",".join(batch), 'UserId': user_api_id},
-                     method='POST', user_auth=temp_auth)
+    async def check_playlist_updates(app):
+        """æ ¹æ®å„è‡ªé—´éš”æ£€æŸ¥æ­Œå•æ›´æ–°å¹¶åŒæ­¥æ–°æ­Œæ›²"""
+        playlists = get_scheduled_playlists()
+        if not playlists:
+            logger.debug("æ²¡æœ‰è®¢é˜…æ­Œå•ï¼Œè·³è¿‡åŒæ­¥æ£€æŸ¥")
+            return
+        default_interval = get_playlist_sync_interval()
+        now = dt.datetime.utcnow()
+        due_found = False
+        for playlist in playlists:
+            try:
+                if not playlist.get('is_active', 1):
+                    continue
+                interval = playlist.get('sync_interval') or default_interval
+                interval = max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, interval)
+                last_sync_at = _parse_db_timestamp(playlist.get('last_sync_at'))
+                if last_sync_at:
+                    elapsed_minutes = (now - last_sync_at).total_seconds() / 60
+                    if elapsed_minutes < 0:
+                        elapsed_minutes = interval
+                    if elapsed_minutes < interval:
+                        continue
+                due_found = True
+                telegram_id = playlist['telegram_id']
+                playlist_url = playlist['playlist_url']
+                platform = playlist['platform']
+                old_song_ids = set(str(sid) for sid in playlist['last_song_ids'])
+            
+                # è·å–æ­Œå•æœ€æ–°æ­Œæ›²
+                playlist_name = playlist.get('playlist_name') or 'æœªçŸ¥æ­Œå•'
+                songs = []
+                remote_name = None
+                if platform == 'netease':
+                    playlist_id = extract_playlist_id(playlist_url, 'netease')
+                    if not playlist_id:
+                        logger.warning(f"æ— æ³•è§£æç½‘æ˜“äº‘æ­Œå•é“¾æ¥: {playlist_url}")
+                        continue
+                    remote_name, songs = get_ncm_playlist_details(playlist_id)
+                elif platform == 'qq':
+                    playlist_id = extract_playlist_id(playlist_url, 'qq')
+                    if not playlist_id:
+                        logger.warning(f"æ— æ³•è§£æ QQ æ­Œå•é“¾æ¥: {playlist_url}")
+                        continue
+                    remote_name, songs = get_qq_playlist_details(playlist_id)
+                else:
+                    logger.debug(f"æš‚ä¸æ”¯æŒçš„å¹³å° {platform}")
+                    continue
+                if remote_name:
+                    playlist_name = remote_name
+                if not songs:
+                    logger.debug(f"{playlist_name} æ— å¯ç”¨æ­Œæ›²ï¼Œè·³è¿‡")
+                    continue
+            
+                # è®¡ç®—æ–°å¢æ­Œæ›²
+                current_song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
+                new_songs = [s for s in songs if str(s.get('source_id') or s.get('id') or s.get('title', '')) not in old_song_ids]
+            
+                if new_songs:
+                    logger.info(f"æ­Œå• '{playlist_name}' å‘ç° {len(new_songs)} é¦–æ–°æ­Œæ›² (é—´éš” {interval} åˆ†é’Ÿ)")
+                    try:
+                        message = f"ğŸ”” **æ­Œå•æ›´æ–°é€šçŸ¥**\n\n"
+                        message += f"ğŸ“‹ æ­Œå•: `{playlist_name}`\n"
+                        message += f"ğŸ†• æ–°å¢: {len(new_songs)} é¦–æ­Œæ›²\n\n"
+                        for i, s in enumerate(new_songs[:5]):
+                            message += f"{i+1}. {s['title']} - {s['artist']}\n"
+                        if len(new_songs) > 5:
+                            message += f"... è¿˜æœ‰ {len(new_songs) - 5} é¦–\n"
+                        keyboard = [[
+                            InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{playlist['id']}"),
+                            InlineKeyboardButton("ğŸ”„ åŒæ­¥åˆ°Emby", callback_data=f"sync_emby_{playlist['id']}")
+                        ]]
+                        reply_markup = InlineKeyboardMarkup(keyboard)
+                        await app.bot.send_message(
+                            chat_id=int(telegram_id),
+                            text=message,
+                            parse_mode='Markdown',
+                            reply_markup=reply_markup
+                        )
+                    except Exception as e:
+                        logger.error(f"å‘é€æ­Œå•æ›´æ–°é€šçŸ¥å¤±è´¥: {e}")
+                else:
+                    logger.debug(f"æ­Œå• '{playlist_name}' æœªå‘ç°æ–°æ­Œæ›²")
+                # æ— è®ºæ˜¯å¦æœ‰æ–°æ­Œï¼Œåªè¦æ‹‰å–æˆåŠŸå°±æ›´æ–°åŒæ­¥æ—¶é—´
+                update_scheduled_playlist_songs(playlist['id'], current_song_ids, playlist_name)
+            except Exception as e:
+                logger.error(f"æ£€æŸ¥æ­Œå• '{playlist.get('playlist_name', '')}' æ›´æ–°å¤±è´¥: {e}")
+        if not due_found:
+            logger.debug("æ²¡æœ‰åˆ°è¾¾åŒæ­¥é—´éš”çš„æ­Œå•ï¼Œç­‰å¾…ä¸‹ä¸€ä¸ªå‘¨æœŸ")
         time.sleep(0.3)
     
     # è®°å½•åˆ°æ•°æ®åº“
@@ -913,6 +634,7 @@
 def init_database():
     global database_conn
     database_conn = sqlite3.connect(str(DATABASE_FILE), check_same_thread=False)
+    database_conn.row_factory = sqlite3.Row  # è®©æŸ¥è¯¢ç»“æœå¯ä»¥ç”¨å­—å…¸æ–¹å¼è®¿é—®
     cursor = database_conn.cursor()
     
     # ç”¨æˆ·ç»‘å®šè¡¨
@@ -963,6 +685,7 @@
             last_song_ids TEXT,
             last_sync_at TIMESTAMP,
             is_active INTEGER DEFAULT 1,
+            sync_interval INTEGER DEFAULT 6,
             created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
             UNIQUE(telegram_id, playlist_url)
         )
@@ -971,6 +694,12 @@
     # æ·»åŠ  is_active å­—æ®µï¼ˆå…¼å®¹æ—§æ•°æ®åº“ï¼‰
     try:
         cursor.execute('ALTER TABLE scheduled_playlists ADD COLUMN is_active INTEGER DEFAULT 1')
+    except:
+        pass  # å­—æ®µå·²å­˜åœ¨
+    
+    # æ·»åŠ  sync_interval å­—æ®µï¼ˆå…¼å®¹æ—§æ•°æ®åº“ï¼‰
+    try:
+        cursor.execute('ALTER TABLE scheduled_playlists ADD COLUMN sync_interval INTEGER DEFAULT 6')
     except:
         pass  # å­—æ®µå·²å­˜åœ¨
     
@@ -1225,6 +954,60 @@
 # ============================================================
 # å®šæ—¶åŒæ­¥æ­Œå•
 # ============================================================
+
+DEFAULT_PLAYLIST_SYNC_INTERVAL_MINUTES = max(1, int(os.environ.get('PLAYLIST_SYNC_INTERVAL', os.environ.get('PLAYLIST_SYNC_INTERVAL_MINUTES', '360'))))
+MIN_PLAYLIST_SYNC_INTERVAL_MINUTES = max(1, int(os.environ.get('PLAYLIST_SYNC_MIN_INTERVAL', '1')))
+PLAYLIST_SYNC_POLL_INTERVAL_SECONDS = max(30, int(os.environ.get('PLAYLIST_SYNC_POLL_INTERVAL', '60')))
+PLAYLIST_SYNC_INITIAL_DELAY_SECONDS = max(0, int(os.environ.get('PLAYLIST_SYNC_INITIAL_DELAY', '10')))
+
+
+def _parse_db_timestamp(value):
+    if not value:
+        return None
+    value = value.strip()
+    if not value:
+        return None
+    # å¸¸è§æ ¼å¼ï¼š"2024-07-12 06:30:00" æˆ– ISO8601
+    for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%dT%H:%M:%S.%f"):
+        try:
+            return dt.datetime.strptime(value, fmt)
+        except ValueError:
+            continue
+    try:
+        normalized = value.replace('Z', '+00:00')
+        return dt.datetime.fromisoformat(normalized)
+    except Exception:
+        logger.debug(f"æ— æ³•è§£ææ—¶é—´æˆ³: {value}")
+        return None
+
+
+def get_playlist_sync_interval():
+    """è·å–å…¨å±€é»˜è®¤æ­Œå•åŒæ­¥é—´éš”ï¼ˆå•ä½ï¼šåˆ†é’Ÿï¼‰"""
+    default_interval = max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, DEFAULT_PLAYLIST_SYNC_INTERVAL_MINUTES)
+    if not database_conn:
+        return default_interval
+    try:
+        cursor = database_conn.cursor()
+        cursor.execute('''
+            CREATE TABLE IF NOT EXISTS bot_settings (
+                key TEXT PRIMARY KEY,
+                value TEXT,
+                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
+            )
+        ''')
+        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('playlist_sync_interval',))
+        row = cursor.fetchone()
+        if row:
+            raw_value = row[0] if isinstance(row, tuple) else row['value']
+            try:
+                interval = int(raw_value)
+                return max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, interval)
+            except ValueError:
+                logger.warning(f"æ— æ•ˆçš„ playlist_sync_interval é…ç½®: {raw_value}")
+        return default_interval
+    except Exception as e:
+        logger.error(f"è¯»å–é»˜è®¤æ­Œå•åŒæ­¥é—´éš”å¤±è´¥: {e}")
+        return default_interval
 
 def add_scheduled_playlist(telegram_id: str, playlist_url: str, playlist_name: str, platform: str, song_ids: list):
     """æ·»åŠ å®šæ—¶åŒæ­¥æ­Œå•"""
@@ -1233,11 +1016,23 @@
     try:
         cursor = database_conn.cursor()
         song_ids_json = json.dumps(song_ids)
+        default_interval = get_playlist_sync_interval()
         cursor.execute('''
-            INSERT OR REPLACE INTO scheduled_playlists 
-            (telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at)
-            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
-        ''', (str(telegram_id), playlist_url, playlist_name, platform, song_ids_json))
+            INSERT INTO scheduled_playlists 
+            (telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at, sync_interval, is_active)
+            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?, 1)
+            ON CONFLICT(telegram_id, playlist_url) DO UPDATE SET
+                playlist_name=excluded.playlist_name,
+                platform=excluded.platform,
+                last_song_ids=excluded.last_song_ids,
+                last_sync_at=excluded.last_sync_at,
+                is_active=1,
+                sync_interval=CASE
+                    WHEN scheduled_playlists.sync_interval IS NULL OR scheduled_playlists.sync_interval < 1
+                        THEN excluded.sync_interval
+                    ELSE scheduled_playlists.sync_interval
+                END
+        ''', (str(telegram_id), playlist_url, playlist_name, platform, song_ids_json, default_interval))
         database_conn.commit()
         return True
     except Exception as e:
@@ -1252,27 +1047,36 @@
         cursor = database_conn.cursor()
         if telegram_id:
             cursor.execute('''
-                SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at
+                SELECT id, telegram_id, playlist_url, playlist_name, platform,
+                       last_song_ids, last_sync_at, sync_interval, is_active
                 FROM scheduled_playlists WHERE telegram_id = ? ORDER BY created_at DESC
             ''', (str(telegram_id),))
         else:
             cursor.execute('''
-                SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at
+                SELECT id, telegram_id, playlist_url, playlist_name, platform,
+                       last_song_ids, last_sync_at, sync_interval, is_active
                 FROM scheduled_playlists ORDER BY created_at DESC
             ''')
         rows = cursor.fetchall()
-        return [
-            {
-                'id': row[0],
-                'telegram_id': row[1],
-                'playlist_url': row[2],
-                'playlist_name': row[3],
-                'platform': row[4],
-                'last_song_ids': json.loads(row[5]) if row[5] else [],
-                'last_sync_at': row[6]
-            }
-            for row in rows
-        ]
+        playlists = []
+        for row in rows:
+            last_song_ids = []
+            try:
+                last_song_ids = json.loads(row['last_song_ids']) if row['last_song_ids'] else []
+            except Exception:
+                logger.debug(f"æ— æ³•è§£æ last_song_ids: {row['last_song_ids']}")
+            playlists.append({
+                'id': row['id'],
+                'telegram_id': row['telegram_id'],
+                'playlist_url': row['playlist_url'],
+                'playlist_name': row['playlist_name'],
+                'platform': row['platform'],
+                'last_song_ids': last_song_ids,
+                'last_sync_at': row['last_sync_at'],
+                'sync_interval': row['sync_interval'],
+                'is_active': row['is_active'] if row['is_active'] is not None else 1
+            })
+        return playlists
     except Exception as e:
         logger.error(f"è·å–å®šæ—¶åŒæ­¥æ­Œå•å¤±è´¥: {e}")
         return []
@@ -1293,20 +1097,27 @@
     except:
         return False
 
-def update_scheduled_playlist_songs(playlist_id: int, song_ids: list):
-    """æ›´æ–°æ­Œå•çš„æ­Œæ›²åˆ—è¡¨"""
+def update_scheduled_playlist_songs(playlist_id: int, song_ids: list, playlist_name: str = None):
+    """æ›´æ–°æ­Œå•çš„æ­Œæ›²åˆ—è¡¨åŠæœ€ååŒæ­¥æ—¶é—´"""
     if not database_conn:
         return False
     try:
         cursor = database_conn.cursor()
         song_ids_json = json.dumps(song_ids)
-        cursor.execute('''
-            UPDATE scheduled_playlists SET last_song_ids = ?, last_sync_at = CURRENT_TIMESTAMP
+        fields = ['last_song_ids = ?', 'last_sync_at = CURRENT_TIMESTAMP']
+        params = [song_ids_json]
+        if playlist_name:
+            fields.append('playlist_name = ?')
+            params.append(playlist_name)
+        params.append(playlist_id)
+        cursor.execute(f"""
+            UPDATE scheduled_playlists SET {', '.join(fields)}
             WHERE id = ?
-        ''', (song_ids_json, playlist_id))
+        """, params)
         database_conn.commit()
         return True
-    except:
+    except Exception as e:
+        logger.error(f"æ›´æ–°æ­Œå• {playlist_id} å¤±è´¥: {e}")
         return False
 
 
@@ -1343,8 +1154,8 @@
                 continue
             
             # è®¡ç®—æ–°å¢æ­Œæ›²
-            current_song_ids = [str(s.get('id', s.get('title', ''))) for s in songs]
-            new_songs = [s for s in songs if str(s.get('id', s.get('title', ''))) not in old_song_ids]
+            current_song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
+            new_songs = [s for s in songs if str(s.get('source_id') or s.get('id') or s.get('title', '')) not in old_song_ids]
             
             if new_songs:
                 logger.info(f"æ­Œå• '{playlist['playlist_name']}' å‘ç° {len(new_songs)} é¦–æ–°æ­Œæ›²")
@@ -1387,17 +1198,23 @@
 
 
 async def scheduled_sync_job(app):
-    """å®šæ—¶åŒæ­¥ä»»åŠ¡"""
+    """åå°è½®è¯¢æ­Œå•åŒæ­¥ä»»åŠ¡"""
+    poll_interval = PLAYLIST_SYNC_POLL_INTERVAL_SECONDS
+    initial_delay = PLAYLIST_SYNC_INITIAL_DELAY_SECONDS
+    if initial_delay:
+        await asyncio.sleep(initial_delay)
+    logger.info(
+        f"æ­Œå•åŒæ­¥ä»»åŠ¡å·²å¯åŠ¨ (é»˜è®¤ {get_playlist_sync_interval()} åˆ†é’Ÿ / è½®è¯¢ {poll_interval} ç§’)"
+    )
     while True:
         try:
-            # æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡
-            await asyncio.sleep(6 * 60 * 60)
             await check_playlist_updates(app)
         except asyncio.CancelledError:
+            logger.info("æ­Œå•åŒæ­¥ä»»åŠ¡å·²å–æ¶ˆ")
             break
         except Exception as e:
             logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å‡ºé”™: {e}")
-            await asyncio.sleep(60)  # å‡ºé”™åç­‰å¾… 1 åˆ†é’Ÿé‡è¯•
+        await asyncio.sleep(poll_interval)
 
 
 async def scheduled_emby_scan_job(app):
@@ -1435,11 +1252,11 @@
                 
                 if new_count != old_count:
                     logger.info(f"Emby åª’ä½“åº“æ›´æ–°: {old_count} -> {new_count} é¦–")
-                    # é€šçŸ¥ç®¡ç†å‘˜
-                    if ADMIN_USER_ID:
+                    # é€šçŸ¥æ‰€æœ‰ç®¡ç†å‘˜
+                    for admin_id in ADMIN_USER_IDS:
                         try:
                             await app.bot.send_message(
-                                chat_id=ADMIN_USER_ID,
+                                chat_id=admin_id,
                                 text=f"ğŸ”„ Emby åª’ä½“åº“å·²è‡ªåŠ¨æ›´æ–°\n\n"
                                      f"ğŸ“Š æ­Œæ›²æ•°é‡: {old_count} â†’ {new_count}\n"
                                      f"ğŸ“ˆ å˜åŒ–: {'+' if new_count > old_count else ''}{new_count - old_count}"
@@ -1677,16 +1494,16 @@
         else:
             # è‡ªåŠ¨æ·»åŠ åˆ°å®šæ—¶åŒæ­¥åˆ—è¡¨
             playlist_type, _ = parse_playlist_input(playlist_url)
-            if playlist_type and user_id == ADMIN_USER_ID:
+            if playlist_type and user_id in ADMIN_USER_IDS:
                 # è·å–æ­Œæ›² ID åˆ—è¡¨ç”¨äºåç»­æ¯”è¾ƒ
-                song_ids = [str(s.get('id', s.get('title', ''))) for s in result.get('all_unmatched', []) + result.get('unmatched_songs', [])]
+                song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in result.get('all_unmatched', []) + result.get('unmatched_songs', [])]
                 # ä»åŸå§‹æ­Œå•è·å–
                 if playlist_type == "netease":
                     _, songs = get_ncm_playlist_details(extract_playlist_id(playlist_url, 'netease'))
                 else:
                     _, songs = get_qq_playlist_details(extract_playlist_id(playlist_url, 'qq'))
                 if songs:
-                    song_ids = [str(s.get('id', s.get('title', ''))) for s in songs]
+                    song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
                 add_scheduled_playlist(user_id, playlist_url, result['name'], playlist_type, song_ids)
             
             msg = f"âœ… **æ­Œå•åŒæ­¥å®Œæˆ**\n\n"
@@ -1721,7 +1538,7 @@
                     InlineKeyboardButton("ğŸ“„ æŸ¥çœ‹æ›´å¤š", callback_data="unmatched_page_1")
                 ])
             
-            if ncm_unmatched and user_id == ADMIN_USER_ID:
+            if ncm_unmatched and user_id in ADMIN_USER_IDS:
                 # ä¿å­˜æœªåŒ¹é…æ­Œæ›²åˆ°ç”¨æˆ·æ•°æ®
                 context.user_data['unmatched_ncm_songs'] = ncm_unmatched
                 msg += f"\nğŸ’¡ æ£€æµ‹åˆ° {len(ncm_unmatched)} é¦–ç½‘æ˜“äº‘æ­Œæ›²å¯è‡ªåŠ¨ä¸‹è½½"
@@ -1780,7 +1597,7 @@
     # å¦‚æœæœ‰ç½‘æ˜“äº‘æ­Œæ›²ä¸”æ˜¯ç®¡ç†å‘˜ï¼Œæ˜¾ç¤ºä¸‹è½½æŒ‰é’®
     user_id = str(query.from_user.id)
     ncm_unmatched = context.user_data.get('unmatched_ncm_songs', [])
-    if ncm_unmatched and user_id == ADMIN_USER_ID:
+    if ncm_unmatched and user_id in ADMIN_USER_IDS:
         keyboard_buttons.append([
             InlineKeyboardButton("ğŸ“¥ è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²", callback_data="download_missing")
         ])
@@ -1796,7 +1613,7 @@
     await query.answer()
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
         return
     
@@ -1977,7 +1794,7 @@
 def check_user_permission(telegram_id: str, permission: str) -> bool:
     """æ£€æŸ¥ç”¨æˆ·æƒé™"""
     # ç®¡ç†å‘˜å§‹ç»ˆæœ‰æƒé™
-    if telegram_id == ADMIN_USER_ID:
+    if telegram_id in ADMIN_USER_IDS:
         return True
     
     try:
@@ -2132,7 +1949,7 @@
 async def cmd_ncm_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æ£€æŸ¥ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2179,7 +1996,7 @@
 
 async def cmd_rescan(update: Update, context: ContextTypes.DEFAULT_TYPE):
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2198,7 +2015,7 @@
 async def cmd_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æœç´¢æ­Œæ›²"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2275,7 +2092,7 @@
 async def cmd_album(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æœç´¢å¹¶ä¸‹è½½ä¸“è¾‘"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2328,7 +2145,7 @@
 async def cmd_qq_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """QQéŸ³ä¹æœç´¢æ­Œæ›²"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2398,7 +2215,7 @@
 async def cmd_qq_album(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """QQéŸ³ä¹æœç´¢å¹¶ä¸‹è½½ä¸“è¾‘"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2467,7 +2284,7 @@
 async def cmd_download_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æŸ¥çœ‹ä¸‹è½½çŠ¶æ€ /ds"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2508,7 +2325,7 @@
 async def cmd_download_queue(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æŸ¥çœ‹ä¸‹è½½é˜Ÿåˆ— /dq"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2550,7 +2367,7 @@
 async def cmd_download_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æŸ¥çœ‹ä¸‹è½½å†å² /dh"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2587,85 +2404,149 @@
 # å®šæ—¶ä»»åŠ¡
 # ============================================================
 
+def get_playlist_sync_interval():
+    """è·å–å…¨å±€æ­Œå•åŒæ­¥é—´éš”ï¼ˆåˆ†é’Ÿï¼Œä»æ•°æ®åº“è¯»å–ï¼‰"""
+    try:
+        if database_conn:
+            cursor = database_conn.cursor()
+            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('playlist_sync_interval',))
+            row = cursor.fetchone()
+            if row:
+                return max(1, int(row[0] if isinstance(row, tuple) else row['value']))
+    except:
+        pass
+    return 60  # é»˜è®¤ 60 åˆ†é’Ÿ
+
+
 async def scheduled_sync_job(application):
-    """å®šæ—¶åŒæ­¥æ­Œå•ä»»åŠ¡ - æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡"""
-    # å¯åŠ¨åç­‰å¾… 5 åˆ†é’Ÿå†å¼€å§‹ç¬¬ä¸€æ¬¡æ£€æŸ¥ï¼ˆç­‰å¾…å…¶ä»–æœåŠ¡å°±ç»ªï¼‰
-    await asyncio.sleep(300)
+    """å®šæ—¶åŒæ­¥æ­Œå•ä»»åŠ¡"""
+    logger.info("å®šæ—¶åŒæ­¥ä»»åŠ¡: å¯åŠ¨ï¼Œ5ç§’åå¼€å§‹ç¬¬ä¸€æ¬¡æ£€æŸ¥")
+    await asyncio.sleep(5)
     
+    next_check_times = {}
+    
     while True:
         try:
-            logger.info("å¼€å§‹å®šæ—¶æ£€æŸ¥æ­Œå•æ›´æ–°...")
-            
             if not database_conn:
-                await asyncio.sleep(6 * 3600)
+                logger.warning("å®šæ—¶åŒæ­¥: æ•°æ®åº“ä¸å¯ç”¨")
+                await asyncio.sleep(30)
                 continue
             
             cursor = database_conn.cursor()
-            # è·å–æ‰€æœ‰æ¿€æ´»çš„è®¢é˜…æ­Œå•
             try:
-                cursor.execute('SELECT * FROM scheduled_playlists WHERE is_active = 1')
+                cursor.execute('SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, sync_interval FROM scheduled_playlists WHERE is_active = 1')
             except:
-                # å…¼å®¹æ²¡æœ‰ is_active å­—æ®µçš„æ—§æ•°æ®åº“
-                cursor.execute('SELECT * FROM scheduled_playlists')
-            playlists = cursor.fetchall()
+                cursor.execute('SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, sync_interval FROM scheduled_playlists')
+            rows = cursor.fetchall()
             
-            for playlist in playlists:
+            default_interval = get_playlist_sync_interval()
+            current_time = time.time()
+            
+            logger.info(f"å®šæ—¶åŒæ­¥: æ£€æŸ¥ {len(rows)} ä¸ªæ­Œå•")
+            
+            for row in rows:
                 try:
-                    playlist_url = playlist['playlist_url']
-                    platform = playlist['platform']
-                    old_song_ids = set(json.loads(playlist['last_song_ids'] or '[]'))
+                    # è§£æè¡Œæ•°æ®
+                    pid = row[0]
+                    telegram_id = row[1]
+                    playlist_url = row[2]
+                    playlist_name = row[3] or 'æœªçŸ¥æ­Œå•'
+                    platform = row[4]
+                    last_song_ids_json = row[5] or '[]'
+                    sync_interval = row[6] or default_interval
                     
-                    # è·å–æœ€æ–°æ­Œæ›²åˆ—è¡¨
+                    interval_seconds = max(1, sync_interval) * 60
+                    
+                    # æ£€æŸ¥æ˜¯å¦åˆ°åŒæ­¥æ—¶é—´
+                    next_check = next_check_times.get(pid, 0)
+                    if current_time < next_check:
+                        continue
+                    
+                    logger.info(f"åŒæ­¥æ£€æŸ¥: {playlist_name} (é—´éš”{sync_interval}åˆ†é’Ÿ)")
+                    
+                    old_song_ids = set(json.loads(last_song_ids_json))
+                    
+                    # è·å–æœ€æ–°æ­Œæ›²
+                    songs = []
                     if platform == 'netease':
-                        playlist_id = extract_playlist_id(playlist_url, 'netease')
-                        _, songs = get_ncm_playlist_details(playlist_id)
+                        pid_str = extract_playlist_id(playlist_url, 'netease')
+                        _, songs = get_ncm_playlist_details(pid_str)
                     elif platform == 'qq':
-                        playlist_id = extract_playlist_id(playlist_url, 'qq')
-                        _, songs = get_qq_playlist_details(playlist_id)
-                    else:
-                        continue
+                        pid_str = extract_playlist_id(playlist_url, 'qq')
+                        _, songs = get_qq_playlist_details(pid_str)
                     
                     if not songs:
+                        logger.warning(f"åŒæ­¥å¤±è´¥: {playlist_name} è·å–æ­Œæ›²åˆ—è¡¨ä¸ºç©º")
+                        next_check_times[pid] = current_time + interval_seconds
                         continue
                     
-                    current_song_ids = set(str(s.get('id', s.get('title', ''))) for s in songs)
+                    def _format_song_display(song_dict):
+                        title = song_dict.get('title') or song_dict.get('name') or song_dict.get('song')
+                        title = title or song_dict.get('SongName') or 'æœªçŸ¥'
+                        artist = song_dict.get('artist') or song_dict.get('artists') or song_dict.get('singer')
+                        if isinstance(artist, list):
+                            artist = ', '.join(str(a) for a in artist if a)
+                        artist = artist or ''
+                        return f"{title} - {artist}".strip(' -')
+
+                    song_id_map = {}
+                    for song in songs:
+                        identifier = (
+                            song.get('source_id') or song.get('id') or song.get('song_id') or
+                            song.get('song_mid') or song.get('mid') or song.get('title') or
+                            song.get('name') or song.get('song') or song.get('SongName')
+                        )
+                        song_id = str(identifier or _format_song_display(song))
+                        song_id_map[song_id] = _format_song_display(song)
+                    
+                    current_song_ids = set(song_id_map.keys())
                     new_songs = current_song_ids - old_song_ids
+                    removed_songs = old_song_ids - current_song_ids
                     
+                    logger.info(
+                        f"åŒæ­¥ç»“æœ: {playlist_name} - å½“å‰{len(current_song_ids)}é¦–, "
+                        f"è®°å½•{len(old_song_ids)}é¦–, æ–°å¢{len(new_songs)}é¦–, åˆ é™¤{len(removed_songs)}é¦–"
+                    )
+                    
+                    def _describe_changes(song_ids):
+                        if not song_ids:
+                            return "æ— "
+                        samples = [song_id_map.get(sid, sid) for sid in list(song_ids)[:5]]
+                        suffix = " ..." if len(song_ids) > 5 else ""
+                        return ', '.join(samples) + suffix
+                    
                     if new_songs:
-                        # å‘ç°æ–°æ­Œæ›²ï¼Œé€šçŸ¥ç®¡ç†å‘˜
-                        new_count = len(new_songs)
-                        msg = f"ğŸµ **æ­Œå•æ›´æ–°é€šçŸ¥**\n\n"
-                        msg += f"ğŸ“‹ æ­Œå•: {playlist['playlist_name']}\n"
-                        msg += f"ğŸ†• æ–°å¢: {new_count} é¦–æ­Œæ›²\n\n"
-                        msg += "ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¸‹è½½æ–°æ­Œæ›²"
-                        
+                        logger.info(f"æ–°å¢æ­Œæ›²: {_describe_changes(new_songs)}")
+                    if removed_songs:
+                        logger.info(f"ä¸‹æ¶æ­Œæ›²: {_describe_changes(removed_songs)}")
+                    if not new_songs and not removed_songs:
+                        logger.info(f"åŒæ­¥å·®å¼‚: {playlist_name} æœªå‘ç°æ–°å¢æˆ–åˆ é™¤")
+                    
+                    if new_songs:
+                        msg = f"ğŸµ **æ­Œå•æ›´æ–°é€šçŸ¥**\n\nğŸ“‹ æ­Œå•: {playlist_name}\nğŸ†• æ–°å¢: {len(new_songs)} é¦–\n\nç‚¹å‡»æŒ‰é’®ä¸‹è½½"
                         keyboard = InlineKeyboardMarkup([
-                            [InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{playlist['id']}")],
-                            [InlineKeyboardButton("ğŸ”„ åŒæ­¥Emby", callback_data=f"sync_emby_{playlist['id']}")]
+                            [InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{pid}")],
+                            [InlineKeyboardButton("ğŸ”„ åŒæ­¥Emby", callback_data=f"sync_emby_{pid}")]
                         ])
-                        
-                        await application.bot.send_message(
-                            chat_id=playlist['telegram_id'],
-                            text=msg,
-                            parse_mode='Markdown',
-                            reply_markup=keyboard
-                        )
-                        
-                        logger.info(f"æ­Œå• {playlist['playlist_name']} å‘ç° {new_count} é¦–æ–°æ­Œ")
-                        
+                        await application.bot.send_message(chat_id=telegram_id, text=msg, parse_mode='Markdown', reply_markup=keyboard)
+                        logger.info(f"å·²é€šçŸ¥: {playlist_name} æ–°å¢ {len(new_songs)} é¦–")
+                    
+                    if new_songs or removed_songs or old_song_ids != current_song_ids:
+                        update_scheduled_playlist_songs(pid, list(current_song_ids))
+                    
+                    next_check_times[pid] = current_time + interval_seconds
+                    
                 except Exception as e:
-                    logger.error(f"æ£€æŸ¥æ­Œå• {playlist.get('playlist_name', '?')} å¤±è´¥: {e}")
+                    logger.error(f"åŒæ­¥æ­Œå•å‡ºé”™: {e}", exc_info=True)
+                    next_check_times[row[0]] = current_time + 300
             
-            # ç­‰å¾… 6 å°æ—¶åå†æ¬¡æ£€æŸ¥
-            await asyncio.sleep(6 * 3600)
-                    
+            await asyncio.sleep(30)
+            
         except asyncio.CancelledError:
             break
         except Exception as e:
-            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡é”™è¯¯: {e}")
-            await asyncio.sleep(60)
-
-
+            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å¼‚å¸¸: {e}", exc_info=True)
+            await asyncio.sleep(30)
 async def scheduled_emby_scan_job(application):
     """å®šæ—¶æ‰«æ Emby åª’ä½“åº“ä»»åŠ¡"""
     while True:
@@ -2760,12 +2641,17 @@
                 msg += f"**ğŸ“‹ æ­Œå•åŒæ­¥**\n"
                 msg += f"â”” åŒæ­¥: {playlists} æ¬¡\n"
                 
-                if ADMIN_USER_ID:
-                    await application.bot.send_message(
-                        chat_id=ADMIN_USER_ID,
-                        text=msg,
-                        parse_mode='Markdown'
-                    )
+                # å‘é€ç»™æ‰€æœ‰ç®¡ç†å‘˜
+                for admin_id in ADMIN_USER_IDS:
+                    try:
+                        await application.bot.send_message(
+                            chat_id=admin_id,
+                            text=msg,
+                            parse_mode='Markdown'
+                        )
+                    except:
+                        pass
+                if ADMIN_USER_IDS:
                     logger.info("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šå·²å‘é€")
             
         except asyncio.CancelledError:
@@ -2814,16 +2700,20 @@
                 except Exception as e:
                     logger.error(f"æ£€æŸ¥ QQ Cookie å¤±è´¥: {e}")
             
-            # å‘é€é€šçŸ¥
-            if notifications and ADMIN_USER_ID:
+            # å‘é€é€šçŸ¥ç»™æ‰€æœ‰ç®¡ç†å‘˜
+            if notifications and ADMIN_USER_IDS:
                 msg = "âš ï¸ **Cookie çŠ¶æ€å‘Šè­¦**\n\n" + "\n\n".join(notifications)
                 msg += "\n\nğŸ’¡ è¯·åœ¨ Web ç®¡ç†ç•Œé¢é‡æ–°é…ç½® Cookie"
                 
-                await application.bot.send_message(
-                    chat_id=ADMIN_USER_ID,
-                    text=msg,
-                    parse_mode='Markdown'
-                )
+                for admin_id in ADMIN_USER_IDS:
+                    try:
+                        await application.bot.send_message(
+                            chat_id=admin_id,
+                            text=msg,
+                            parse_mode='Markdown'
+                        )
+                    except:
+                        pass
                 logger.warning("å·²å‘é€ Cookie è¿‡æœŸé€šçŸ¥")
             
             # ç­‰å¾… 6 å°æ—¶åå†æ¬¡æ£€æŸ¥
@@ -2934,7 +2824,7 @@
 async def cmd_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """æŸ¥çœ‹å®šæ—¶åŒæ­¥æ­Œå•"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -2949,21 +2839,142 @@
         )
         return
     
+    default_interval = get_playlist_sync_interval()
     msg = "ğŸ“… **å®šæ—¶åŒæ­¥æ­Œå•**\n\n"
     for i, p in enumerate(playlists, 1):
         platform_icon = "ğŸ”´" if p['platform'] == 'netease' else "ğŸŸ¢"
         last_sync = p['last_sync_at'][:16] if p['last_sync_at'] else "æœªåŒæ­¥"
+        # è·å–åŒæ­¥é—´éš”
+        try:
+            interval = p.get('sync_interval') or default_interval
+        except:
+            interval = default_interval
+        interval = max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, interval)
+        if interval >= 60:
+            hours = interval // 60
+            minutes = interval % 60
+            if minutes:
+                interval_str = f"{hours}h{minutes}m"
+            else:
+                interval_str = f"{hours}h"
+        else:
+            interval_str = f"{interval}m"
         msg += f"`{i}.` {platform_icon} {p['playlist_name']}\n"
-        msg += f"    ğŸ“Š {len(p['last_song_ids'])} é¦– Â· æœ€ååŒæ­¥: {last_sync}\n\n"
+        msg += f"    ğŸ“Š {len(p['last_song_ids'])} é¦– Â· â± {interval_str} Â· æœ€ååŒæ­¥: {last_sync}\n\n"
     
-    msg += f"ğŸ’¡ ä½¿ç”¨ `/unschedule <åºå·>` å–æ¶ˆè®¢é˜…"
+    msg += f"ğŸ’¡ ä½¿ç”¨ `/unschedule <åºå·>` å–æ¶ˆè®¢é˜…\n"
+    msg += f"ğŸ’¡ ä½¿ç”¨ `/syncinterval <åºå·> <åˆ†é’Ÿ>` è®¾ç½®åŒæ­¥é—´éš”"
     await update.message.reply_text(msg, parse_mode='Markdown')
 
 
+async def cmd_syncinterval(update: Update, context: ContextTypes.DEFAULT_TYPE):
+    """è®¾ç½®æ­Œå•åŒæ­¥é—´éš”
+    ç®¡ç†å‘˜: /syncinterval æˆ– /syncinterval default <åˆ†é’Ÿ> è®¾ç½®å…¨å±€é»˜è®¤
+    ç”¨æˆ·: /syncinterval <åºå·> <åˆ†é’Ÿ> è®¾ç½®è‡ªå·±æ­Œå•çš„åŒæ­¥é—´éš”
+    """
+    user_id = str(update.effective_user.id)
+    is_admin = user_id in ADMIN_USER_IDS
+    
+    # è·å–å½“å‰å…¨å±€é»˜è®¤é—´éš”
+    default_interval = get_playlist_sync_interval()
+    
+    if not context.args:
+        # æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
+        msg = f"â± **æ­Œå•åŒæ­¥é—´éš”è®¾ç½®**\n\n"
+        msg += f"ğŸ“Š å½“å‰é»˜è®¤é—´éš”: **{default_interval} åˆ†é’Ÿ**\n\n"
+        msg += f"**ç”¨æ³•:**\n"
+        msg += f"â€¢ `/syncinterval <åºå·> <åˆ†é’Ÿ>` - è®¾ç½®æŒ‡å®šæ­Œå•çš„åŒæ­¥é—´éš”\n"
+        if is_admin:
+            msg += f"â€¢ `/syncinterval default <åˆ†é’Ÿ>` - è®¾ç½®å…¨å±€é»˜è®¤é—´éš”\n"
+        msg += f"\n**ç¤ºä¾‹:**\n"
+        msg += f"â€¢ `/syncinterval 1 30` - ç¬¬1ä¸ªæ­Œå•æ¯30åˆ†é’ŸåŒæ­¥\n"
+        if is_admin:
+            msg += f"â€¢ `/syncinterval default 60` - å…¨å±€é»˜è®¤æ¯60åˆ†é’ŸåŒæ­¥\n"
+        msg += f"\nğŸ’¡ æœ€å°é—´éš”: {MIN_PLAYLIST_SYNC_INTERVAL_MINUTES} åˆ†é’Ÿ"
+        await update.message.reply_text(msg, parse_mode='Markdown')
+        return
+    
+    # ç®¡ç†å‘˜è®¾ç½®å…¨å±€é»˜è®¤é—´éš”
+    if context.args[0].lower() == 'default':
+        if not is_admin:
+            await update.message.reply_text("âŒ åªæœ‰ç®¡ç†å‘˜å¯ä»¥è®¾ç½®å…¨å±€é»˜è®¤é—´éš”")
+            return
+        
+        if len(context.args) < 2:
+            await update.message.reply_text(f"å½“å‰å…¨å±€é»˜è®¤é—´éš”: {default_interval} åˆ†é’Ÿ\nç”¨æ³•: `/syncinterval default <åˆ†é’Ÿ>`", parse_mode='Markdown')
+            return
+        
+        try:
+            interval = int(context.args[1])
+            if interval < MIN_PLAYLIST_SYNC_INTERVAL_MINUTES:
+                await update.message.reply_text(f"âŒ é—´éš”ä¸èƒ½å°äº {MIN_PLAYLIST_SYNC_INTERVAL_MINUTES} åˆ†é’Ÿ")
+                return
+            if interval > 10080:  # æœ€å¤§ä¸€å‘¨ï¼ˆ7*24*60ï¼‰
+                await update.message.reply_text("âŒ é—´éš”ä¸èƒ½è¶…è¿‡ 10080 åˆ†é’Ÿï¼ˆä¸€å‘¨ï¼‰")
+                return
+            
+            # ä¿å­˜åˆ°æ•°æ®åº“
+            if database_conn:
+                cursor = database_conn.cursor()
+                cursor.execute('''
+                    INSERT OR REPLACE INTO bot_settings (key, value, updated_at)
+                    VALUES (?, ?, ?)
+                ''', ('playlist_sync_interval', str(interval), datetime.now().isoformat()))
+                database_conn.commit()
+            
+            await update.message.reply_text(f"âœ… å·²è®¾ç½®å…¨å±€é»˜è®¤åŒæ­¥é—´éš”ä¸º **{interval} åˆ†é’Ÿ**", parse_mode='Markdown')
+            
+        except ValueError:
+            await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
+        return
+    
+    # ç”¨æˆ·è®¾ç½®è‡ªå·±æ­Œå•çš„åŒæ­¥é—´éš”
+    try:
+        index = int(context.args[0]) - 1
+        
+        if len(context.args) < 2:
+            await update.message.reply_text("ç”¨æ³•: `/syncinterval <åºå·> <åˆ†é’Ÿ>`\nä¾‹å¦‚: `/syncinterval 1 30`", parse_mode='Markdown')
+            return
+        
+        interval = int(context.args[1])
+        if interval < MIN_PLAYLIST_SYNC_INTERVAL_MINUTES:
+            await update.message.reply_text(f"âŒ é—´éš”ä¸èƒ½å°äº {MIN_PLAYLIST_SYNC_INTERVAL_MINUTES} åˆ†é’Ÿ")
+            return
+        if interval > 10080:  # æœ€å¤§ä¸€å‘¨
+            await update.message.reply_text("âŒ é—´éš”ä¸èƒ½è¶…è¿‡ 10080 åˆ†é’Ÿï¼ˆä¸€å‘¨ï¼‰")
+            return
+        
+        # è·å–ç”¨æˆ·çš„æ­Œå•åˆ—è¡¨
+        playlists = get_scheduled_playlists(user_id)
+        
+        if index < 0 or index >= len(playlists):
+            await update.message.reply_text("âŒ åºå·æ— æ•ˆï¼Œè¯·ä½¿ç”¨ /schedule æŸ¥çœ‹æ­Œå•åˆ—è¡¨")
+            return
+        
+        playlist = playlists[index]
+        
+        # æ›´æ–°æ•°æ®åº“
+        if database_conn:
+            cursor = database_conn.cursor()
+            cursor.execute('''
+                UPDATE scheduled_playlists SET sync_interval = ?
+                WHERE id = ?
+            ''', (interval, playlist['id']))
+            database_conn.commit()
+        
+        await update.message.reply_text(
+            f"âœ… å·²è®¾ç½®æ­Œå• **{playlist['playlist_name']}** çš„åŒæ­¥é—´éš”ä¸º **{interval} åˆ†é’Ÿ**",
+            parse_mode='Markdown'
+        )
+        
+    except ValueError:
+        await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—\nç”¨æ³•: `/syncinterval <åºå·> <åˆ†é’Ÿ>`", parse_mode='Markdown')
+
+
 async def cmd_scaninterval(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """è®¾ç½® Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æé—´éš”"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -3020,7 +3031,7 @@
 async def cmd_unschedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """å–æ¶ˆå®šæ—¶åŒæ­¥æ­Œå•"""
     user_id = str(update.effective_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
         return
     
@@ -3051,7 +3062,7 @@
     await query.answer()
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await query.edit_message_text("æ— æƒæ‰§è¡Œæ­¤æ“ä½œ")
         return
     
@@ -3085,7 +3096,7 @@
                 await query.message.reply_text("âŒ ä¸æ”¯æŒçš„å¹³å°")
                 return
             
-            new_songs = [s for s in songs if str(s.get('id', s.get('title', ''))) not in old_song_ids]
+            new_songs = [s for s in songs if str(s.get('source_id') or s.get('id') or s.get('title', '')) not in old_song_ids]
             
             if not new_songs:
                 await query.message.reply_text("æ²¡æœ‰æ–°æ­Œæ›²éœ€è¦ä¸‹è½½")
@@ -3158,8 +3169,8 @@
             save_download_record_v2(success_results, failed, download_quality, user_id)
             
             # æ›´æ–°æ­Œæ›²åˆ—è¡¨
-            current_song_ids = [str(s.get('id', s.get('title', ''))) for s in songs]
-            update_scheduled_playlist_songs(playlist['id'], current_song_ids)
+            current_song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
+            update_scheduled_playlist_songs(playlist['id'], current_song_ids, playlist['playlist_name'])
             
             # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
             ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
@@ -3322,7 +3333,7 @@
         )
         
         # é€šçŸ¥ç®¡ç†å‘˜
-        if ADMIN_USER_ID:
+        if ADMIN_USER_IDS:
             user = update.effective_user
             user_info = f"@{user.username}" if user.username else f"{user.first_name} ({user_id})"
             
@@ -3345,15 +3356,17 @@
                 f"ğŸ”— é“¾æ¥: {playlist_url}"
             )
             
-            try:
-                await context.bot.send_message(
-                    chat_id=ADMIN_USER_ID,
-                    text=admin_msg,
-                    parse_mode='Markdown',
-                    reply_markup=keyboard
-                )
-            except Exception as e:
-                logger.error(f"é€šçŸ¥ç®¡ç†å‘˜å¤±è´¥: {e}")
+            # é€šçŸ¥æ‰€æœ‰ç®¡ç†å‘˜
+            for admin_id in ADMIN_USER_IDS:
+                try:
+                    await context.bot.send_message(
+                        chat_id=admin_id,
+                        text=admin_msg,
+                        parse_mode='Markdown',
+                        reply_markup=keyboard
+                    )
+                except Exception as e:
+                    logger.error(f"é€šçŸ¥ç®¡ç†å‘˜ {admin_id} å¤±è´¥: {e}")
                 
     except Exception as e:
         logger.error(f"æäº¤æ­Œå•ç”³è¯·å¤±è´¥: {e}")
@@ -3405,7 +3418,7 @@
     await query.answer()
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await query.answer("ä»…ç®¡ç†å‘˜å¯æ“ä½œ", show_alert=True)
         return
     
@@ -3523,7 +3536,12 @@
             return
         
         # åŒ¹é… Emby åª’ä½“åº“ï¼Œæ‰¾å‡ºç¼ºå¤±æ­Œæ›²
-        admin_binding = get_user_binding(ADMIN_USER_ID)
+        # ä½¿ç”¨ç¬¬ä¸€ä¸ªç®¡ç†å‘˜çš„ç»‘å®š
+        admin_binding = None
+        for admin_id in ADMIN_USER_IDS:
+            admin_binding = get_user_binding(admin_id)
+            if admin_binding:
+                break
         if not admin_binding:
             await query.message.reply_text("âŒ ç®¡ç†å‘˜æœªç»‘å®š Emby")
             return
@@ -3639,8 +3657,9 @@
         except:
             pass
         
-        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰
-        save_download_record_v2(success_results, failed_songs, download_quality, ADMIN_USER_ID)
+        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰- ä½¿ç”¨ç¬¬ä¸€ä¸ªç®¡ç†å‘˜ID
+        first_admin_id = ADMIN_USER_IDS[0] if ADMIN_USER_IDS else ''
+        save_download_record_v2(success_results, failed_songs, download_quality, first_admin_id)
         
         # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
         ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
@@ -3698,7 +3717,7 @@
     await query.answer("ğŸ§ æ­£åœ¨è·å–è¯•å¬...")
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         return
     
     data = query.data
@@ -3756,7 +3775,7 @@
     await query.answer("ğŸ§ æ­£åœ¨è·å–è¯•å¬...")
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         return
     
     data = query.data
@@ -3814,7 +3833,7 @@
     await query.answer()
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
         return
     
@@ -4050,7 +4069,7 @@
     await query.answer()
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
         return
     
@@ -4337,7 +4356,7 @@
     await query.answer()
     
     user_id = str(query.from_user.id)
-    if user_id != ADMIN_USER_ID:
+    if user_id not in ADMIN_USER_IDS:
         await query.edit_message_text("æ— æƒæ‰§è¡Œæ­¤æ“ä½œ")
         return
     
@@ -4443,8 +4462,8 @@
             callback=file_organizer_callback
         )
         
-        # å‘é€ Telegram é€šçŸ¥
-        if ADMIN_USER_ID:
+        # å‘é€ Telegram é€šçŸ¥ç»™æ‰€æœ‰ç®¡ç†å‘˜
+        for admin_id in ADMIN_USER_IDS:
             try:
                 msg = (
                     "ğŸ“ *æ–‡ä»¶æ•´ç†å™¨å·²å¯åŠ¨*\n\n"
@@ -4454,7 +4473,7 @@
                     f"âš™ï¸ å†²çªå¤„ç†: `{on_conflict}`"
                 )
                 await application.bot.send_message(
-                    chat_id=ADMIN_USER_ID,
+                    chat_id=admin_id,
                     text=msg,
                     parse_mode='Markdown'
                 )
@@ -4465,184 +4484,6 @@
         logger.error(f"å¯åŠ¨æ–‡ä»¶æ•´ç†å™¨å¤±è´¥: {e}")
 
 
-# ============================================================
-# å®šæ—¶ä»»åŠ¡
-# ============================================================
-
-async def scheduled_sync_job(application):
-    """å®šæ—¶æ£€æŸ¥è®¢é˜…æ­Œå•æ›´æ–°"""
-    await asyncio.sleep(300)  # å¯åŠ¨å 5 åˆ†é’Ÿå¼€å§‹ç¬¬ä¸€æ¬¡æ£€æŸ¥
-    
-    while True:
-        try:
-            logger.info("å¼€å§‹å®šæ—¶æ­Œå•åŒæ­¥æ£€æŸ¥...")
-            
-            if database_conn:
-                cursor = database_conn.cursor()
-                cursor.execute('''
-                    SELECT id, telegram_id, playlist_url, playlist_name, platform
-                    FROM scheduled_playlists WHERE is_active = 1
-                ''')
-                playlists = cursor.fetchall()
-                
-                for playlist in playlists:
-                    try:
-                        playlist_id = playlist[0] if isinstance(playlist, tuple) else playlist['id']
-                        telegram_id = playlist[1] if isinstance(playlist, tuple) else playlist['telegram_id']
-                        playlist_url = playlist[2] if isinstance(playlist, tuple) else playlist['playlist_url']
-                        playlist_name = playlist[3] if isinstance(playlist, tuple) else playlist['playlist_name']
-                        
-                        logger.info(f"æ£€æŸ¥æ­Œå•æ›´æ–°: {playlist_name}")
-                        # è¿™é‡Œå¯ä»¥æ·»åŠ æ­Œå•åŒæ­¥é€»è¾‘
-                        
-                    except Exception as e:
-                        logger.error(f"åŒæ­¥æ­Œå•å¤±è´¥: {e}")
-                        
-        except Exception as e:
-            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å‡ºé”™: {e}")
-        
-        await asyncio.sleep(6 * 3600)  # æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡
-
-
-async def scheduled_emby_scan_job(application):
-    """å®šæ—¶æ‰«æ Emby åª’ä½“åº“"""
-    await asyncio.sleep(600)  # å¯åŠ¨å 10 åˆ†é’Ÿå¼€å§‹
-    
-    while True:
-        try:
-            # è·å–æ‰«æé—´éš”è®¾ç½®
-            scan_interval = EMBY_SCAN_INTERVAL
-            if database_conn:
-                cursor = database_conn.cursor()
-                cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
-                row = cursor.fetchone()
-                if row:
-                    scan_interval = int(row[0] if isinstance(row, tuple) else row['value'])
-            
-            if scan_interval <= 0:
-                await asyncio.sleep(3600)  # æœªå¯ç”¨æ—¶ï¼Œæ¯å°æ—¶æ£€æŸ¥é…ç½®
-                continue
-            
-            logger.info(f"å¼€å§‹å®šæ—¶ Emby åª’ä½“åº“æ‰«æ...")
-            
-            # æ‰«æå¹¶æ›´æ–°ç¼“å­˜
-            if emby_auth.get('access_token') and emby_auth.get('user_id'):
-                await sync_library_cache()
-                logger.info("Emby åª’ä½“åº“æ‰«æå®Œæˆ")
-            
-        except Exception as e:
-            logger.error(f"å®šæ—¶æ‰«æä»»åŠ¡å‡ºé”™: {e}")
-        
-        # ç­‰å¾…ä¸‹ä¸€æ¬¡æ‰«æ
-        interval_hours = scan_interval if scan_interval > 0 else 1
-        await asyncio.sleep(interval_hours * 3600)
-
-
-async def daily_stats_job(application):
-    """æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š"""
-    import datetime as dt
-    
-    while True:
-        try:
-            now = dt.datetime.now()
-            # è®¡ç®—åˆ°æ˜å¤©æ—©ä¸Š 9 ç‚¹çš„ç§’æ•°
-            target = now.replace(hour=9, minute=0, second=0, microsecond=0)
-            if now >= target:
-                target += dt.timedelta(days=1)
-            wait_seconds = (target - now).total_seconds()
-            
-            await asyncio.sleep(wait_seconds)
-            
-            # å‘é€æ¯æ—¥ç»Ÿè®¡
-            if ADMIN_USER_ID and database_conn:
-                cursor = database_conn.cursor()
-                today = dt.datetime.now().strftime('%Y-%m-%d')
-                
-                # ä»Šæ—¥ä¸‹è½½æ•°
-                cursor.execute('''
-                    SELECT COUNT(*) FROM download_history 
-                    WHERE date(download_time) = ?
-                ''', (today,))
-                today_downloads = cursor.fetchone()[0]
-                
-                # æ€»ä¸‹è½½æ•°
-                cursor.execute('SELECT COUNT(*) FROM download_history')
-                total_downloads = cursor.fetchone()[0]
-                
-                # æ´»è·ƒç”¨æˆ·æ•°
-                cursor.execute('SELECT COUNT(DISTINCT telegram_id) FROM users WHERE emby_token IS NOT NULL')
-                active_users = cursor.fetchone()[0]
-                
-                msg = (
-                    f"ğŸ“Š *æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š*\n"
-                    f"ğŸ“… æ—¥æœŸ: {today}\n\n"
-                    f"â¬‡ï¸ ä»Šæ—¥ä¸‹è½½: {today_downloads} é¦–\n"
-                    f"ğŸ“¥ æ€»ä¸‹è½½æ•°: {total_downloads} é¦–\n"
-                    f"ğŸ‘¥ ç»‘å®šç”¨æˆ·: {active_users} äºº"
-                )
-                
-                try:
-                    await application.bot.send_message(
-                        chat_id=ADMIN_USER_ID,
-                        text=msg,
-                        parse_mode='Markdown'
-                    )
-                except Exception as e:
-                    logger.debug(f"å‘é€æ¯æ—¥æŠ¥å‘Šå¤±è´¥: {e}")
-                    
-        except Exception as e:
-            logger.error(f"æ¯æ—¥ç»Ÿè®¡ä»»åŠ¡å‡ºé”™: {e}")
-            await asyncio.sleep(3600)  # å‡ºé”™åç­‰å¾… 1 å°æ—¶å†è¯•
-
-
-async def cookie_check_job(application):
-    """å®šæ—¶æ£€æŸ¥ Cookie æ˜¯å¦è¿‡æœŸ"""
-    await asyncio.sleep(1800)  # å¯åŠ¨å 30 åˆ†é’Ÿå¼€å§‹
-    
-    while True:
-        try:
-            issues = []
-            
-            # æ£€æŸ¥ç½‘æ˜“äº‘ Cookie
-            ncm_cookie = get_ncm_cookie()
-            if ncm_cookie:
-                try:
-                    from bot.ncm_downloader import check_ncm_cookie
-                    if not check_ncm_cookie(ncm_cookie):
-                        issues.append("âš ï¸ ç½‘æ˜“äº‘ Cookie å¯èƒ½å·²è¿‡æœŸ")
-                except:
-                    pass
-            
-            # æ£€æŸ¥ QQ éŸ³ä¹ Cookie
-            qq_cookie = get_qq_cookie()
-            if qq_cookie:
-                try:
-                    from bot.ncm_downloader import check_qq_cookie
-                    if not check_qq_cookie(qq_cookie):
-                        issues.append("âš ï¸ QQéŸ³ä¹ Cookie å¯èƒ½å·²è¿‡æœŸ")
-                except:
-                    pass
-            
-            # å‘é€å‘Šè­¦
-            if issues and ADMIN_USER_ID:
-                msg = "ğŸ”” *Cookie æ£€æŸ¥å‘Šè­¦*\n\n" + "\n".join(issues)
-                msg += "\n\nè¯·åŠæ—¶åœ¨ Web ç®¡ç†ç•Œé¢æ›´æ–° Cookie"
-                
-                try:
-                    await application.bot.send_message(
-                        chat_id=ADMIN_USER_ID,
-                        text=msg,
-                        parse_mode='Markdown'
-                    )
-                except:
-                    pass
-                    
-        except Exception as e:
-            logger.error(f"Cookie æ£€æŸ¥ä»»åŠ¡å‡ºé”™: {e}")
-        
-        await asyncio.sleep(6 * 3600)  # æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡
-
-
 async def emby_webhook_notify_job(application):
     """å¤„ç† Emby Webhook é€šçŸ¥å¹¶å‘é€åˆ° Telegram"""
     from bot.web import get_webhook_notifications, set_webhook_bot
@@ -4659,7 +4500,7 @@
             # è·å–å¾…å¤„ç†çš„é€šçŸ¥
             notifications = get_webhook_notifications()
             
-            if notifications and ADMIN_USER_ID:
+            if notifications and ADMIN_USER_IDS:
                 for notif in notifications:
                     try:
                         if notif.get('type') == 'library_new':
@@ -4688,11 +4529,16 @@
                             if album:
                                 msg += f"ğŸ’¿ ä¸“è¾‘: {album}"
                             
-                            await application.bot.send_message(
-                                chat_id=ADMIN_USER_ID,
-                                text=msg,
-                                parse_mode='Markdown'
-                            )
+                            # å‘é€ç»™æ‰€æœ‰ç®¡ç†å‘˜
+                            for admin_id in ADMIN_USER_IDS:
+                                try:
+                                    await application.bot.send_message(
+                                        chat_id=admin_id,
+                                        text=msg,
+                                        parse_mode='Markdown'
+                                    )
+                                except:
+                                    pass
                             
                     except Exception as e:
                         logger.debug(f"å‘é€ Webhook é€šçŸ¥å¤±è´¥: {e}")
@@ -4873,7 +4719,8 @@
     app.add_handler(CommandHandler(["qqalbum", "qa"], cmd_qq_album))  # /qa QQéŸ³ä¹ä¸“è¾‘
     app.add_handler(CommandHandler(["schedule", "sub"], cmd_schedule))  # /sub è®¢é˜…åˆ—è¡¨
     app.add_handler(CommandHandler(["unschedule", "unsub"], cmd_unschedule))  # /unsub å–æ¶ˆè®¢é˜…
-    app.add_handler(CommandHandler(["scaninterval", "si"], cmd_scaninterval))  # /si æ‰«æé—´éš”
+    app.add_handler(CommandHandler(["scaninterval", "si"], cmd_scaninterval))  # /si Embyæ‰«æé—´éš”
+    app.add_handler(CommandHandler(["syncinterval", "syi"], cmd_syncinterval))  # /syi æ­Œå•åŒæ­¥é—´éš”
     app.add_handler(CommandHandler(["request", "req"], cmd_request))  # /req ç”³è¯·
     app.add_handler(CommandHandler(["myrequests", "mr"], cmd_myrequests))  # /mr æˆ‘çš„ç”³è¯·
     app.add_handler(CommandHandler(["dlstatus", "ds"], cmd_download_status))  # /ds ä¸‹è½½çŠ¶æ€
@@ -4936,7 +4783,10 @@
         
         # å¯åŠ¨å®šæ—¶åŒæ­¥ä»»åŠ¡
         asyncio.create_task(scheduled_sync_job(application))
-        logger.info("å®šæ—¶åŒæ­¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡)")
+        sync_interval = get_playlist_sync_interval()
+        logger.info(
+            f"å®šæ—¶åŒæ­¥ä»»åŠ¡å³å°†å¯åŠ¨ (é»˜è®¤é—´éš”: {sync_interval} åˆ†é’Ÿ, è½®è¯¢ {PLAYLIST_SYNC_POLL_INTERVAL_SECONDS} ç§’)"
+        )
         
         # å¯åŠ¨å®šæ—¶æ‰«æ Emby åª’ä½“åº“ä»»åŠ¡
         asyncio.create_task(scheduled_emby_scan_job(application))
@@ -4984,6 +4834,36 @@
     if TG_API_ID and TG_API_HASH:
         asyncio.get_event_loop().run_until_complete(start_pyrogram_client())
     
+    # å…¨å±€é”™è¯¯å¤„ç†å™¨ï¼Œç”¨äºæ•è·æœªå¤„ç†å¼‚å¸¸å¹¶è®°å½•/é€šçŸ¥ç®¡ç†å‘˜
+    async def global_error_handler(update, context):
+        import traceback
+        try:
+            tb = traceback.format_exc()
+        except Exception:
+            tb = 'æ— æ³•è·å– traceback'
+        # è®°å½•åˆ°æ—¥å¿—
+        logger.error(f"Unhandled exception in update handler:\n{tb}")
+        # å‘é€ç»™ç®¡ç†å‘˜ï¼ˆé¿å…åœ¨ç¾¤é‡Œé‡å¤å‘é€å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸ï¼‰
+        try:
+            text = "âŒ æœºå™¨äººå‘ç”Ÿæœªå¤„ç†å¼‚å¸¸ï¼Œå·²è®°å½•ã€‚è¯·æ£€æŸ¥æ—¥å¿—ã€‚"
+            for admin in ADMIN_USER_IDS:
+                try:
+                    await app.bot.send_message(chat_id=admin, text=text)
+                except Exception:
+                    pass
+        except Exception:
+            pass
+
+    # æ³¨å†Œå…¨å±€é”™è¯¯å¤„ç†å™¨ï¼ˆtelegram.ext ä¼šåœ¨å¤„ç† update æ—¶è°ƒç”¨ï¼‰
+    try:
+        app.add_error_handler(global_error_handler)
+    except Exception:
+        # å…¼å®¹ä¸åŒç‰ˆæœ¬çš„ python-telegram-botï¼ˆæŸäº›æ—§ç‰ˆä½¿ç”¨ä¸åŒæ¥å£ï¼‰
+        try:
+            app.add_error_handler(lambda u, c: None)
+        except:
+            pass
+
     app.run_polling()
 
 
