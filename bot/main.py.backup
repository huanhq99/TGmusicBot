#!/usr/bin/env python3
"""
TGmusicbot - Telegram Bot for Music Management
åŠŸèƒ½ï¼šæ­Œå•åŒæ­¥åˆ° Emby + éŸ³ä¹ä¸Šä¼ åˆ° NAS
"""

import logging
import os
import json
import time
import re
import html
import sqlite3
import asyncio
import shutil
from datetime import datetime, timedelta
from urllib.parse import urljoin
from pathlib import Path
from cryptography.fernet import Fernet

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from rapidfuzz import fuzz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InlineQueryResultArticle, InputTextMessageContent, BotCommand
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler, InlineQueryHandler

# åŠ è½½ç¯å¢ƒå˜é‡
from dotenv import load_dotenv
load_dotenv()

# --- å…¨å±€é…ç½® ---
APP_NAME = "TGmusicbot"
APP_VERSION = "1.7.9"
EMBY_CLIENT_NAME = "TGmusicbot"
DEVICE_ID = "TGmusicbot_Device_v2"

# è·¯å¾„é…ç½®
SCRIPT_DIR = Path(__file__).parent.parent
DATA_DIR = Path(os.environ.get('DATA_DIR', SCRIPT_DIR / 'data'))
UPLOAD_DIR = Path(os.environ.get('UPLOAD_DIR', '/tmp/tgmusicbot_uploads'))
MUSIC_TARGET_DIR = Path(os.environ.get('MUSIC_TARGET_DIR', SCRIPT_DIR / 'uploads'))

DATA_DIR.mkdir(parents=True, exist_ok=True)
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
MUSIC_TARGET_DIR.mkdir(parents=True, exist_ok=True)

DATABASE_FILE = DATA_DIR / 'bot.db'
LIBRARY_CACHE_FILE = DATA_DIR / 'library_cache.json'
LOG_FILE = DATA_DIR / f'bot_{datetime.now().strftime("%Y%m%d")}.log'

# ç¯å¢ƒå˜é‡é…ç½®
TELEGRAM_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN') or os.environ.get('TELEGRAM_TOKEN')
TELEGRAM_API_URL = os.environ.get('TELEGRAM_API_URL', '')  # Local Bot API Server URL, e.g. http://localhost:8081/bot
ADMIN_USER_ID = os.environ.get('ADMIN_USER_ID')
EMBY_URL = os.environ.get('EMBY_URL')
EMBY_USERNAME = os.environ.get('EMBY_USERNAME')
EMBY_PASSWORD = os.environ.get('EMBY_PASSWORD')

# Emby Webhook é€šçŸ¥å¼€å…³
EMBY_WEBHOOK_NOTIFY = os.environ.get('EMBY_WEBHOOK_NOTIFY', 'true').lower() == 'true'
MAKE_PLAYLIST_PUBLIC = os.environ.get('MAKE_PLAYLIST_PUBLIC', 'false').lower() == 'true'

# ç½‘æ˜“äº‘/QQéŸ³ä¹ä¸‹è½½é…ç½®
NCM_COOKIE = os.environ.get('NCM_COOKIE', '')  # ç½‘æ˜“äº‘ç™»å½• Cookie
QQ_COOKIE = os.environ.get('QQ_COOKIE', '')  # QQéŸ³ä¹ç™»å½• Cookie
NCM_QUALITY = os.environ.get('NCM_QUALITY', 'exhigh')  # ä¸‹è½½éŸ³è´¨: standard/higher/exhigh/lossless/hires
AUTO_DOWNLOAD = os.environ.get('AUTO_DOWNLOAD', 'false').lower() == 'true'  # æ˜¯å¦è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²

# å›½å†…ä»£ç†æœåŠ¡é…ç½®ï¼ˆç”¨äºæµ·å¤– VPS ä¸‹è½½ QQ/ç½‘æ˜“äº‘éŸ³ä¹ï¼‰
MUSIC_PROXY_URL = os.environ.get('MUSIC_PROXY_URL', '')  # å¦‚ http://å›½å†…IP:8899
MUSIC_PROXY_KEY = os.environ.get('MUSIC_PROXY_KEY', '')  # ä»£ç† API Key

# å®šæ—¶æ‰«æ Emby åª’ä½“åº“ï¼ˆå°æ—¶ï¼Œ0 è¡¨ç¤ºç¦ç”¨ï¼‰
EMBY_SCAN_INTERVAL = int(os.environ.get('EMBY_SCAN_INTERVAL', '0'))

# Pyrogram é…ç½®ï¼ˆå¤§æ–‡ä»¶ä¸Šä¼ æ”¯æŒï¼Œå¯é€‰ï¼‰
TG_API_ID = os.environ.get('TG_API_ID', '')
TG_API_HASH = os.environ.get('TG_API_HASH', '')

# å…è®¸ä¸Šä¼ çš„éŸ³é¢‘æ ¼å¼
ALLOWED_AUDIO_EXTENSIONS = ('.mp3', '.flac', '.m4a', '.wav', '.ogg', '.aac', '.ape', '.wma', '.alac', '.aiff', '.dsd', '.dsf', '.dff')

# Pyrogram å®¢æˆ·ç«¯ï¼ˆç”¨äºæ¥æ”¶å¤§æ–‡ä»¶ï¼‰
pyrogram_client = None


def get_ncm_cookie():
    """è·å–ç½‘æ˜“äº‘ Cookieï¼ˆä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼‰"""
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('ncm_cookie',))
            row = cursor.fetchone()
            if row:
                # row å¯èƒ½æ˜¯ tuple æˆ– dict
                value = row['value'] if isinstance(row, dict) else row[0]
                if value:
                    return value
    except Exception as e:
        logger.error(f"è¯»å– ncm_cookie å¤±è´¥: {e}")
    return NCM_COOKIE  # å›é€€åˆ°ç¯å¢ƒå˜é‡


def get_qq_cookie():
    """è·å– QQéŸ³ä¹ Cookieï¼ˆä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼‰"""
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('qq_cookie',))
            row = cursor.fetchone()
            if row:
                # row å¯èƒ½æ˜¯ tuple æˆ– dict
                value = row['value'] if isinstance(row, dict) else row[0]
                if value:
                    return value
    except Exception as e:
        logger.error(f"è¯»å– qq_cookie å¤±è´¥: {e}")
    return QQ_COOKIE  # å›é€€åˆ°ç¯å¢ƒå˜é‡


# ä¸‹è½½ç®¡ç†å™¨ï¼ˆå…¨å±€å®ä¾‹ï¼‰
from bot.download_manager import DownloadManager, init_download_manager as _init_dm, get_download_manager

download_manager = None


# åŠ å¯†å¯†é’¥
ENCRYPTION_KEY = os.environ.get('PLAYLIST_BOT_KEY')
if not ENCRYPTION_KEY:
    ENCRYPTION_KEY = Fernet.generate_key().decode()
    print(f"è­¦å‘Šï¼šæœªè®¾ç½® PLAYLIST_BOT_KEYï¼Œå·²ç”Ÿæˆæ–°å¯†é’¥ï¼š{ENCRYPTION_KEY}")

fernet = Fernet(ENCRYPTION_KEY.encode())

# API ç«¯ç‚¹
QQ_API_GET_PLAYLIST_URL = "http://i.y.qq.com/qzone/fcg-bin/fcg_ucc_getcdinfo_byids_cp.fcg"
NCM_API_PLAYLIST_DETAIL_URL = "https://music.163.com/api/v3/playlist/detail"
NCM_API_SONG_DETAIL_URL = "https://music.163.com/api/song/detail/"

# åŒ¹é…å‚æ•°
MATCH_THRESHOLD = 9
EMBY_SCAN_PAGE_SIZE = 2000
EMBY_PLAYLIST_ADD_BATCH_SIZE = 200

# --- å…¨å±€çŠ¶æ€ ---
emby_library_data = []
emby_auth = {'access_token': None, 'user_id': None}
database_conn = None
requests_session = None
ncm_downloader = None  # ç½‘æ˜“äº‘ä¸‹è½½å™¨å®ä¾‹

# æœç´¢ç¼“å­˜ï¼ˆé¿å…é‡å¤ API è°ƒç”¨ï¼‰
_cmd_search_cache = {}  # {(platform, keyword): (timestamp, results)}
_cmd_search_cache_ttl = 180  # 3åˆ†é’Ÿ


# ============================================================
# è¿›åº¦æ¡å·¥å…·å‡½æ•°
# ============================================================

def make_progress_bar(current: int, total: int, width: int = 10) -> str:
    """
    ç”Ÿæˆæ–‡æœ¬è¿›åº¦æ¡
    
    Args:
        current: å½“å‰è¿›åº¦
        total: æ€»æ•°
        width: è¿›åº¦æ¡å®½åº¦ï¼ˆå­—ç¬¦æ•°ï¼‰
        
    Returns:
        è¿›åº¦æ¡å­—ç¬¦ä¸²ï¼Œå¦‚ "â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘ 50%"
    """
    if total <= 0:
        return "â–‘" * width + " 0%"
    
    percent = min(current / total, 1.0)
    filled = int(width * percent)
    empty = width - filled
    
    bar = "â–“" * filled + "â–‘" * empty
    percent_text = f"{int(percent * 100)}%"
    
    return f"{bar} {percent_text}"


def make_progress_message(title: str, current: int, total: int, 
                          current_item: str = "", extra_info: str = "") -> str:
    """
    ç”Ÿæˆå®Œæ•´çš„è¿›åº¦æ¶ˆæ¯
    
    Args:
        title: æ ‡é¢˜ï¼ˆå¦‚ ğŸ“¥ ä¸‹è½½ä¸­ï¼‰
        current: å½“å‰è¿›åº¦
        total: æ€»æ•°
        current_item: å½“å‰å¤„ç†çš„é¡¹ç›®åç§°
        extra_info: é¢å¤–ä¿¡æ¯
        
    Returns:
        æ ¼å¼åŒ–çš„è¿›åº¦æ¶ˆæ¯
    """
    bar = make_progress_bar(current, total)
    msg = f"{title}\n\n{bar}\nğŸ“Š {current}/{total}"
    
    if current_item:
        # æˆªæ–­è¿‡é•¿çš„é¡¹ç›®å
        if len(current_item) > 35:
            current_item = current_item[:32] + "..."
        msg += f"\n\nğŸµ `{current_item}`"
    
    if extra_info:
        msg += f"\n\n{extra_info}"
    
    return msg


def escape_markdown(text: str) -> str:
    """
    è½¬ä¹‰ Telegram Markdown ç‰¹æ®Šå­—ç¬¦
    
    Args:
        text: åŸå§‹æ–‡æœ¬
        
    Returns:
        è½¬ä¹‰åçš„æ–‡æœ¬
    """
    if not text:
        return ''
    # Markdown ç‰¹æ®Šå­—ç¬¦: _ * [ ] ( ) ~ ` > # + - = | { } . !
    special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    for char in special_chars:
        text = text.replace(char, f'\\{char}')
    return text


async def start_pyrogram_client():
    """å¯åŠ¨ Pyrogram å®¢æˆ·ç«¯ç”¨äºæ¥æ”¶å¤§æ–‡ä»¶"""
    global pyrogram_client
    
    if not TG_API_ID or not TG_API_HASH:
        logger.info("æœªé…ç½® TG_API_ID/TG_API_HASHï¼Œå¤§æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½æœªå¯ç”¨")
        return
    
    try:
        from pyrogram import Client, filters as pyro_filters
        from pyrogram.handlers import MessageHandler as PyroMessageHandler
        
        # åˆ›å»º Pyrogram å®¢æˆ·ç«¯ï¼ˆBot æ¨¡å¼ï¼‰
        pyrogram_client = Client(
            name="tgmusicbot_pyrogram",
            api_id=int(TG_API_ID),
            api_hash=TG_API_HASH,
            bot_token=TELEGRAM_TOKEN,
            workdir=str(DATA_DIR)
        )
        
        @pyrogram_client.on_message(pyro_filters.audio | pyro_filters.document)
        async def handle_large_file(client, message):
            """å¤„ç†å¤§æ–‡ä»¶ä¸Šä¼ ï¼ˆPyrogramï¼‰"""
            user_id = str(message.from_user.id)
            
            # è·å–æ–‡ä»¶ä¿¡æ¯
            if message.audio:
                file = message.audio
                original_name = file.file_name or f"{file.title or 'audio'}.mp3"
                file_size = file.file_size or 0
            elif message.document:
                file = message.document
                original_name = file.file_name or "unknown"
                mime = file.mime_type or ""
                # åªå¤„ç†éŸ³é¢‘æ–‡ä»¶
                if not (mime.startswith('audio/') or original_name.lower().endswith(ALLOWED_AUDIO_EXTENSIONS)):
                    return
                file_size = file.file_size or 0
            else:
                return
            
            # åªå¤„ç†å¤§äº 20MB çš„æ–‡ä»¶ï¼Œå°æ–‡ä»¶ç”± python-telegram-bot å¤„ç†
            if file_size <= 20 * 1024 * 1024:
                return
            
            try:
                status_msg = await message.reply_text(f"ğŸ“¥ æ­£åœ¨ä¸‹è½½å¤§æ–‡ä»¶: {original_name} ({file_size / 1024 / 1024:.1f} MB)...")
                
                # è·å–ä¸‹è½½è®¾ç½®
                ncm_settings = get_ncm_settings()
                download_mode = ncm_settings.get('download_mode', 'local')
                download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
                musictag_dir = ncm_settings.get('musictag_dir', '')
                
                # ç¡®ä¿ç›®å½•å­˜åœ¨
                download_path = Path(download_dir)
                download_path.mkdir(parents=True, exist_ok=True)
                
                # ä½¿ç”¨ Pyrogram ä¸‹è½½å¤§æ–‡ä»¶
                temp_path = UPLOAD_DIR / original_name
                await message.download(file_name=str(temp_path))
                
                # æ¸…ç†æ–‡ä»¶åå¹¶ç§»åŠ¨åˆ°ä¸‹è½½ç›®å½•
                clean_name = clean_filename(original_name)
                target_path = download_path / clean_name
                
                if target_path.exists():
                    target_path.unlink()
                
                shutil.move(str(temp_path), str(target_path))
                
                # å¦‚æœæ˜¯ MusicTag æ¨¡å¼
                final_path = target_path
                if download_mode == 'musictag' and musictag_dir:
                    musictag_path = Path(musictag_dir)
                    musictag_path.mkdir(parents=True, exist_ok=True)
                    final_dest = musictag_path / clean_name
                    shutil.move(str(target_path), str(final_dest))
                    final_path = final_dest
                    logger.info(f"å·²ç§»åŠ¨å¤§æ–‡ä»¶åˆ° MusicTag: {clean_name}")
                
                # è®°å½•
                save_upload_record(user_id, original_name, clean_name, file_size)
                
                size_mb = file_size / 1024 / 1024
                if download_mode == 'musictag' and musictag_dir:
                    await status_msg.edit_text(f"âœ… å¤§æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB\nğŸ“‚ å·²è½¬ç§»åˆ° MusicTag ç›®å½•")
                else:
                    await status_msg.edit_text(f"âœ… å¤§æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB\nğŸ“‚ ä¿å­˜ä½ç½®: {download_path}")
                
                logger.info(f"ç”¨æˆ· {user_id} ä¸Šä¼ å¤§æ–‡ä»¶: {clean_name} ({size_mb:.2f} MB)")
                
            except Exception as e:
                logger.error(f"å¤§æ–‡ä»¶ä¸Šä¼ å¤±è´¥: {e}")
                await message.reply_text(f"âŒ ä¸Šä¼ å¤±è´¥: {str(e)}")
        
        await pyrogram_client.start()
        logger.info("âœ… Pyrogram å®¢æˆ·ç«¯å·²å¯åŠ¨ï¼Œå¤§æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½å·²å¯ç”¨ (æœ€å¤§ 2GB)")
        
    except ImportError:
        logger.warning("Pyrogram æœªå®‰è£…ï¼Œå¤§æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½ä¸å¯ç”¨")
    except Exception as e:
        logger.error(f"Pyrogram å¯åŠ¨å¤±è´¥: {e}")


# --- æ—¥å¿—è®¾ç½® ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE, encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# é™ä½ç¬¬ä¸‰æ–¹åº“çš„æ—¥å¿—çº§åˆ«ï¼Œé¿å…åˆ·å±
logging.getLogger('httpx').setLevel(logging.WARNING)
logging.getLogger('httpcore').setLevel(logging.WARNING)
logging.getLogger('telegram').setLevel(logging.WARNING)
logging.getLogger('apscheduler').setLevel(logging.WARNING)

# ============================================================
# å·¥å…·å‡½æ•°
# ============================================================

def create_requests_session():
    session = requests.Session()
    retry_strategy = Retry(total=3, status_forcelist=[429, 500, 502, 503, 504], 
                          allowed_methods=["HEAD", "GET", "POST", "DELETE"], backoff_factor=1)
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

def strip_jsonp(jsonp_str):
    match = re.match(r'^[^{]*\(({.*?})\)[^}]*$', jsonp_str.strip())
    return match.group(1) if match else jsonp_str

def encrypt_password(password):
    return fernet.encrypt(password.encode()).decode()

def decrypt_password(encrypted_password):
    try:
        return fernet.decrypt(encrypted_password.encode()).decode()
    except Exception:
        # è§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ—§ key åŠ å¯†çš„ï¼Œè¿”å›åŸæ–‡ï¼ˆå‡è®¾æ˜¯æ˜æ–‡ï¼‰
        logger.warning("å¯†ç è§£å¯†å¤±è´¥ï¼Œå¯èƒ½éœ€è¦é‡æ–°ç»‘å®šè´¦å·")
        return encrypted_password

def _normalize_artists(artist_str: str) -> set:
    if not isinstance(artist_str, str): return set()
    s = artist_str.lower()
    s = re.sub(r'\s*[\(ï¼ˆ].*?[\)ï¼‰]', '', s)
    s = re.sub(r'\s*[\[ã€].*?[\]ã€‘]', '', s)
    s = re.sub(r'\s+(feat|ft|with|vs|presents|pres\.|starring)\.?\s+', '/', s)
    s = re.sub(r'\s*&\s*', '/', s)
    return {artist.strip() for artist in re.split(r'\s*[/â€¢,ã€]\s*', s) if artist.strip()}

def _get_title_lookup_key(title: str) -> str:
    if not isinstance(title, str): return ""
    key = title.lower()
    key = re.sub(r'\s*[\(ï¼ˆã€\[].*?[\)ï¼‰ã€‘\]]', '', key).strip()
    return key

def _resolve_short_url(url: str) -> str:
    try:
        headers = {'User-Agent': 'Mozilla/5.0', 'Accept': 'text/html'}
        response = requests_session.get(url, headers=headers, timeout=(10, 20), allow_redirects=True)
        if response.url != url:
            logger.info(f"çŸ­é“¾æ¥è§£æ: {url} -> {response.url}")
        return response.url
    except:
        return url

def clean_filename(name: str) -> str:
    """æ¸…ç†æ–‡ä»¶å"""
    name = re.sub(r'^\d+\s*[-_. ]+\s*', '', name)
    name = re.sub(r'[_]+', ' ', name)
    name = re.sub(r'\s*\(\d+\)\s*', '', name)
    # ç§»é™¤éæ³•å­—ç¬¦
    name = re.sub(r'[<>:"/\\|?*]', '', name)
    return name.strip()


# ============================================================
# Emby API
# ============================================================

def authenticate_emby(base_url, username, password):
    api_url = urljoin(base_url, "/emby/Users/AuthenticateByName")
    auth_header = f'Emby Client="{EMBY_CLIENT_NAME}", Device="Docker", DeviceId="{DEVICE_ID}", Version="{APP_VERSION}"'
    headers = {
        'X-Emby-Authorization': auth_header,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    try:
        response = requests_session.post(api_url, params={'format': 'json'},
                                        json={"Username": username, "Pw": password},
                                        headers=headers, timeout=(10, 20))
        response.raise_for_status()
        data = response.json()
        if data and 'AccessToken' in data and 'User' in data:
            logger.info(f"Emby è®¤è¯æˆåŠŸ: {username}")
            return data['AccessToken'], data['User']['Id']
    except requests.RequestException as e:
        logger.error(f"Emby è®¤è¯å¤±è´¥: {e}")
    return None, None

def call_emby_api(endpoint, params=None, method='GET', data=None, user_auth=None, timeout=(15, 60)):
    auth = user_auth or emby_auth
    access_token = auth.get('access_token')
    user_id = auth.get('user_id')
    if not access_token or not user_id:
        return None
    
    api_url = urljoin(EMBY_URL, f"/emby/{endpoint.lstrip('/')}")
    auth_header = f'Emby UserId="{user_id}", Client="{EMBY_CLIENT_NAME}", Device="Docker", DeviceId="{DEVICE_ID}", Version="{APP_VERSION}", Token="{access_token}"'
    headers = {
        'X-Emby-Authorization': auth_header,
        'X-Emby-Token': access_token,
        'Accept': 'application/json'
    }
    query_params = {'format': 'json', **(params or {})}
    
    try:
        if method.upper() == 'GET':
            response = requests_session.get(api_url, params=query_params, headers=headers, timeout=timeout)
        elif method.upper() == 'POST':
            headers['Content-Type'] = 'application/json'
            response = requests_session.post(api_url, params=params, json=data, headers=headers, timeout=timeout)
        elif method.upper() == 'DELETE':
            response = requests_session.delete(api_url, params=params, headers=headers, timeout=timeout)
        else:
            return None
        
        if response.status_code == 204:
            return {"status": "ok"}
        response.raise_for_status()
        try:
            return response.json()
        except:
            return {"status": "ok"}
    except requests.RequestException as e:
        logger.error(f"Emby API ({endpoint}) å¤±è´¥: {e}")
        return None


def trigger_emby_library_scan(user_auth=None):
    """è§¦å‘ Emby åª’ä½“åº“æ‰«æ"""
    try:
        # åˆ·æ–°æ•´ä¸ªåª’ä½“åº“
        result = call_emby_api("Library/Refresh", method='POST', user_auth=user_auth)
        if result:
            logger.info("å·²è§¦å‘ Emby åª’ä½“åº“æ‰«æ")
            return True
        return False
    except Exception as e:
        logger.error(f"è§¦å‘ Emby æ‰«åº“å¤±è´¥: {e}")
        return False


# ============================================================
# åª’ä½“åº“æ‰«æ
# ============================================================

def scan_emby_library(save_to_cache=True, user_id=None, access_token=None):
    global emby_library_data
    logger.info("å¼€å§‹æ‰«æ Emby åª’ä½“åº“...")
    scanned_songs = []
    start_index = 0
    
    scan_user_id = user_id or emby_auth['user_id']
    scan_access_token = access_token or emby_auth['access_token']
    if not scan_user_id or not scan_access_token:
        return []
    
    temp_auth = {'user_id': scan_user_id, 'access_token': scan_access_token}
    
    while True:
        params = {
            'IncludeItemTypes': 'Audio', 'Recursive': 'true',
            'Limit': EMBY_SCAN_PAGE_SIZE, 'StartIndex': start_index,
            'Fields': 'Id,Name,ArtistItems'
        }
        response = call_emby_api(f"Users/{scan_user_id}/Items", params, user_auth=temp_auth, timeout=(15, 180))
        
        if response and 'Items' in response:
            items = response['Items']
            if not items: break
            for item in items:
                artists = "/".join([a.get('Name', '') for a in item.get('ArtistItems', [])])
                scanned_songs.append({
                    'id': str(item.get('Id')),
                    'title': html.unescape(item.get('Name', '')),
                    'artist': html.unescape(artists)
                })
            logger.info(f"å·²æ‰«æ {len(scanned_songs)} é¦–æ­Œæ›²...")
            if len(items) < EMBY_SCAN_PAGE_SIZE: break
            start_index += EMBY_SCAN_PAGE_SIZE
        else:
            break
    
    emby_library_data = scanned_songs
    logger.info(f"æ‰«æå®Œæˆï¼Œå…± {len(emby_library_data)} é¦–æ­Œæ›²")
    
    if save_to_cache:
        try:
            with open(LIBRARY_CACHE_FILE, 'w', encoding='utf-8') as f:
                json.dump(emby_library_data, f, ensure_ascii=False)
        except Exception as e:
            logger.error(f"ä¿å­˜ç¼“å­˜å¤±è´¥: {e}")
    
    return emby_library_data


def get_user_emby_playlists(user_auth):
    if not user_auth: return []
    params = {'IncludeItemTypes': 'Playlist', 'Recursive': 'true', 'Fields': 'Id,Name'}
    response = call_emby_api(f"Users/{user_auth['user_id']}/Items", params, user_auth=user_auth)
    if response and 'Items' in response:
        return [{'id': p.get('Id'), 'name': p.get('Name')} for p in response['Items']]
    return []

def delete_emby_playlist(playlist_id, user_auth):
    return call_emby_api(f"Items/{playlist_id}", {}, method='DELETE', user_auth=user_auth) is not None


# ============================================================
# æ­Œå•è§£æ
# ============================================================

def parse_playlist_input(input_str: str):
    input_str = input_str.strip()
    url_match = re.search(r'https?://\S+', input_str)
    url = url_match.group(0) if url_match else input_str
    
    if '163cn.tv' in url or 'c6.y.qq.com' in url:
        url = _resolve_short_url(url)
    
    # ç½‘æ˜“äº‘
    for pattern in [r"music\.163\.com.*[?&/#]id=(\d+)", r"music\.163\.com/playlist/(\d+)"]:
        match = re.search(pattern, url)
        if match: return "netease", match.group(1)
    
    # QQéŸ³ä¹
    for pattern in [r"y\.qq\.com/n/ryqq/playlist/(\d+)", r"(?:y|i)\.qq\.com/.*?[?&](id|dissid)=(\d+)"]:
        match = re.search(pattern, url)
        if match:
            return "qq", match.group(2) if len(match.groups()) > 1 and match.group(2) else match.group(1)
    
    # Spotify
    for pattern in [r"open\.spotify\.com/playlist/([a-zA-Z0-9]+)", r"spotify:playlist:([a-zA-Z0-9]+)"]:
        match = re.search(pattern, url)
        if match: return "spotify", match.group(1)
    
    return None, None


def extract_playlist_id(playlist_url: str, platform: str) -> str:
    """ä»æ­Œå• URL ä¸­æå– ID"""
    playlist_type, playlist_id = parse_playlist_input(playlist_url)
    if playlist_type == platform or (platform == 'netease' and playlist_type == 'ncm'):
        return playlist_id
    return None

def get_qq_playlist_details(playlist_id):
    params = {'type': 1, 'utf8': 1, 'disstid': playlist_id, 'loginUin': 0}
    headers = {'Referer': 'https://y.qq.com/', 'User-Agent': 'Mozilla/5.0'}
    try:
        response = requests_session.get(QQ_API_GET_PLAYLIST_URL, params=params, headers=headers, timeout=(10, 15))
        response.raise_for_status()
        data = json.loads(strip_jsonp(response.text))
        if not data or 'cdlist' not in data or not data['cdlist']:
            return None, []
        playlist = data['cdlist'][0]
        name = html.unescape(playlist.get('dissname', f"QQæ­Œå•{playlist_id}"))
        songs = []
        for s in playlist.get('songlist', []):
            if s:
                artists = "/".join([a.get('name', '') for a in s.get('singer', [])])
                songs.append({
                    'source_id': str(s.get('songid') or s.get('id')),
                    'title': html.unescape(s.get('songname') or s.get('title', '')),
                    'artist': html.unescape(artists),
                    'platform': 'QQ'
                })
        return name, songs
    except Exception as e:
        logger.error(f"è·å– QQ æ­Œå•å¤±è´¥: {e}")
        return None, []

def get_ncm_playlist_details(playlist_id):
    headers = {'Referer': 'https://music.163.com/', 'User-Agent': 'Mozilla/5.0'}
    try:
        response = requests_session.get(NCM_API_PLAYLIST_DETAIL_URL, 
                                        params={'id': playlist_id, 'n': 100000},
                                        headers=headers, timeout=(10, 20))
        response.raise_for_status()
        data = response.json()
        playlist = data.get('playlist')
        if not playlist: return None, []
        
        name = html.unescape(playlist.get('name', f"ç½‘æ˜“äº‘æ­Œå•{playlist_id}"))
        track_ids = [str(t['id']) for t in playlist.get('trackIds', [])]
        
        songs = []
        for i in range(0, len(track_ids), 200):
            batch_ids = track_ids[i:i + 200]
            detail_response = requests_session.get(NCM_API_SONG_DETAIL_URL,
                                                   params={'ids': f"[{','.join(batch_ids)}]"},
                                                   headers=headers, timeout=(10, 15))
            detail_response.raise_for_status()
            for s in detail_response.json().get('songs', []):
                artist_list = s.get('ar') or s.get('artists') or []
                artists = "/".join([a.get('name', '') for a in artist_list])
                songs.append({
                    'source_id': str(s.get('id')),
                    'title': html.unescape(s.get('name', '')),
                    'artist': html.unescape(artists),
                    'platform': 'NCM'
                })
        return name, songs
    except Exception as e:
        logger.error(f"è·å–ç½‘æ˜“äº‘æ­Œå•å¤±è´¥: {e}")
        return None, []


def get_spotify_playlist_details(playlist_id: str):
    """
    è·å– Spotify æ­Œå•è¯¦æƒ…ï¼ˆé€šè¿‡ç½‘é¡µè§£æï¼Œæ— éœ€ API Keyï¼‰
    
    Args:
        playlist_id: Spotify æ­Œå• ID
        
    Returns:
        (æ­Œå•åç§°, æ­Œæ›²åˆ—è¡¨)
    """
    try:
        # ä½¿ç”¨ Spotify embed é¡µé¢è·å–æ­Œå•ä¿¡æ¯
        embed_url = f"https://open.spotify.com/embed/playlist/{playlist_id}"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
        }
        
        response = requests_session.get(embed_url, headers=headers, timeout=15)
        response.raise_for_status()
        
        # ä» HTML ä¸­æå– JSON æ•°æ®
        html_content = response.text
        
        # å°è¯•æ‰¾åˆ°æ­Œå•æ•°æ®
        import re
        
        # æ–¹æ³•1: æ‰¾ <script id="__NEXT_DATA__" 
        json_match = re.search(r'<script id="__NEXT_DATA__"[^>]*>(.*?)</script>', html_content, re.DOTALL)
        if json_match:
            try:
                data = json.loads(json_match.group(1))
                # è§£ææ­Œå•ä¿¡æ¯
                playlist_data = data.get('props', {}).get('pageProps', {})
                
                playlist_name = playlist_data.get('state', {}).get('data', {}).get('entity', {}).get('name', f'Spotify æ­Œå•')
                tracks_data = playlist_data.get('state', {}).get('data', {}).get('entity', {}).get('trackList', [])
                
                songs = []
                for track in tracks_data:
                    title = track.get('title', '')
                    artists = track.get('subtitle', '')  # Spotify embed ä¸­ subtitle æ˜¯è‰ºæœ¯å®¶
                    
                    if title:
                        songs.append({
                            'source_id': track.get('uri', ''),
                            'title': title,
                            'artist': artists,
                            'platform': 'Spotify'
                        })
                
                if songs:
                    logger.info(f"æˆåŠŸè·å– Spotify æ­Œå•: {playlist_name}, {len(songs)} é¦–æ­Œæ›²")
                    return playlist_name, songs
            except json.JSONDecodeError:
                pass
        
        # æ–¹æ³•2: ä½¿ç”¨ Spotify oembed API
        oembed_url = f"https://open.spotify.com/oembed?url=https://open.spotify.com/playlist/{playlist_id}"
        oembed_resp = requests_session.get(oembed_url, headers=headers, timeout=10)
        if oembed_resp.status_code == 200:
            oembed_data = oembed_resp.json()
            playlist_name = oembed_data.get('title', 'Spotify æ­Œå•')
            # oembed ä¸åŒ…å«æ­Œæ›²åˆ—è¡¨ï¼Œä½†è‡³å°‘èƒ½è·å–æ­Œå•åç§°
            logger.info(f"è·å–åˆ° Spotify æ­Œå•åç§°: {playlist_name}")
            
            # å°è¯•ä»ç½‘é¡µç‰ˆè·å–æ­Œæ›²åˆ—è¡¨
            web_url = f"https://open.spotify.com/playlist/{playlist_id}"
            web_resp = requests_session.get(web_url, headers=headers, timeout=15)
            
            # ä½¿ç”¨æ­£åˆ™æå–æ­Œæ›²ä¿¡æ¯
            # Spotify ç½‘é¡µä¸­æ­Œæ›²é€šå¸¸åœ¨ data-testid="tracklist-row" å…ƒç´ ä¸­
            track_pattern = r'"name":"([^"]+)"[^}]*"artists":\[(\{[^]]+\})\]'
            matches = re.findall(track_pattern, web_resp.text)
            
            songs = []
            seen = set()
            for title, artists_json in matches:
                try:
                    # è§£æè‰ºæœ¯å®¶
                    artist_names = re.findall(r'"name":"([^"]+)"', artists_json)
                    artist = '/'.join(artist_names) if artist_names else ''
                    
                    key = f"{title}|{artist}"
                    if key not in seen and title:
                        seen.add(key)
                        songs.append({
                            'source_id': '',
                            'title': html.unescape(title),
                            'artist': html.unescape(artist),
                            'platform': 'Spotify'
                        })
                except:
                    continue
            
            if songs:
                logger.info(f"ä» Spotify ç½‘é¡µè§£æåˆ° {len(songs)} é¦–æ­Œæ›²")
                return playlist_name, songs
        
        logger.warning(f"æ— æ³•è§£æ Spotify æ­Œå•: {playlist_id}")
        return None, []
        
    except Exception as e:
        logger.error(f"è·å– Spotify æ­Œå•å¤±è´¥: {e}")
        return None, []


# ============================================================
# åŒ¹é…é€»è¾‘
# ============================================================

def find_best_match(source_track, candidates, match_mode):
    if not candidates: return None
    source_title = source_track.get('title', '').strip()
    source_artist = source_track.get('artist', '').strip()
    
    if match_mode == "å®Œå…¨åŒ¹é…":
        source_artists_norm = sorted(list(_normalize_artists(source_artist)))
        for track in candidates:
            if source_title == track.get('title', '').strip():
                track_artists_norm = sorted(list(_normalize_artists(track.get('artist', ''))))
                if source_artists_norm == track_artists_norm:
                    return track
        return None
    
    # æ¨¡ç³ŠåŒ¹é…
    best_match, best_score = None, -1
    source_title_lower = source_title.lower()
    source_artists_norm = _normalize_artists(source_artist)
    
    for track in candidates:
        track_title_lower = track.get('title', '').lower()
        title_sim = fuzz.ratio(source_title_lower, track_title_lower)
        
        title_pts = 10 if title_sim >= 95 else (8 if title_sim >= 88 else (5 if title_sim >= 75 else 0))
        
        track_artists_norm = _normalize_artists(track.get('artist', ''))
        artist_pts = 0
        if source_artists_norm and track_artists_norm:
            if source_artists_norm == track_artists_norm: artist_pts = 5
            elif source_artists_norm.issubset(track_artists_norm) or track_artists_norm.issubset(source_artists_norm): artist_pts = 4
            elif source_artists_norm.intersection(track_artists_norm): artist_pts = 2
        
        score = title_pts + artist_pts
        if score > best_score:
            best_match, best_score = track, score
    
    return best_match if best_score >= MATCH_THRESHOLD else None


def process_playlist(playlist_url, user_id=None, force_public=False, user_binding=None, match_mode="æ¨¡ç³ŠåŒ¹é…"):
    playlist_type, playlist_id = parse_playlist_input(playlist_url)
    if not playlist_type:
        return None, "æ— æ³•è¯†åˆ«çš„æ­Œå•é“¾æ¥"
    
    # ç”¨æˆ·è®¤è¯
    if user_binding:
        token, emby_user_id = authenticate_emby(EMBY_URL, user_binding['emby_username'], user_binding['emby_password'])
        if not token:
            return None, "Emby è®¤è¯å¤±è´¥"
        temp_auth = {'access_token': token, 'user_id': emby_user_id}
    else:
        temp_auth = None
    
    # è·å–æ­Œå•
    logger.info(f"å¤„ç† {playlist_type.upper()} æ­Œå•: {playlist_id}")
    if playlist_type == "qq":
        source_name, source_songs = get_qq_playlist_details(playlist_id)
    elif playlist_type == "spotify":
        source_name, source_songs = get_spotify_playlist_details(playlist_id)
    else:  # netease
        source_name, source_songs = get_ncm_playlist_details(playlist_id)
    
    source_songs = [s for s in source_songs if s and s.get('title')]
    if not source_songs:
        return None, "æ— æ³•è·å–æ­Œå•å†…å®¹"
    
    # æ„å»ºç´¢å¼•å¹¶åŒ¹é…
    emby_index = {}
    for track in emby_library_data:
        key = _get_title_lookup_key(track.get('title'))
        if key: emby_index.setdefault(key, []).append(track)
    
    matched_ids, unmatched = [], []
    for source_track in source_songs:
        key = _get_title_lookup_key(source_track.get('title'))
        match = find_best_match(source_track, emby_index.get(key, []), match_mode)
        if match:
            matched_ids.append(match['id'])
        else:
            unmatched.append(source_track)
    
    logger.info(f"åŒ¹é…å®Œæˆ: {len(matched_ids)} æˆåŠŸ, {len(unmatched)} å¤±è´¥")
    
    if not matched_ids:
        return None, f"æ­Œå• '{source_name}' æœªåŒ¹é…åˆ°ä»»ä½•æ­Œæ›²"
    
    # åˆ é™¤åŒåæ­Œå•
    user_api_id = temp_auth['user_id'] if temp_auth else emby_auth['user_id']
    for p in get_user_emby_playlists(temp_auth or emby_auth):
        if p.get('name') == source_name:
            call_emby_api(f"Items/{p['id']}", {}, method='DELETE', user_auth=temp_auth)
            break
    
    # åˆ›å»ºæ­Œå•
    is_public = force_public or (MAKE_PLAYLIST_PUBLIC and user_id == ADMIN_USER_ID)
    create_response = call_emby_api("Playlists", 
                                   {'Name': source_name, 'MediaType': 'Audio', 'UserId': user_api_id},
                                   method='POST', data={'Name': source_name, 'MediaType': 'Audio'},
                                   user_auth=temp_auth)
    
    if not create_response or 'Id' not in create_response:
        return None, "åˆ›å»ºæ­Œå•å¤±è´¥"
    
    new_playlist_id = create_response['Id']
    if is_public:
        call_emby_api(f"Items/{new_playlist_id}/MakePublic", {}, method='POST', user_auth=temp_auth)
    
    # æ·»åŠ æ­Œæ›²
    unique_ids = list(dict.fromkeys(matched_ids))
    for i in range(0, len(unique_ids), EMBY_PLAYLIST_ADD_BATCH_SIZE):
        batch = unique_ids[i:i + EMBY_PLAYLIST_ADD_BATCH_SIZE]
        call_emby_api(f"Playlists/{new_playlist_id}/Items",
                     {'Ids': ",".join(batch), 'UserId': user_api_id},
                     method='POST', user_auth=temp_auth)
        time.sleep(0.3)
    
    # è®°å½•åˆ°æ•°æ®åº“
    save_playlist_record(user_id, source_name, playlist_type, len(source_songs), len(matched_ids))
    
    result = {
        'name': source_name,
        'total': len(source_songs),
        'matched': len(matched_ids),
        'unmatched': len(unmatched),
        'unmatched_songs': unmatched[:15],  # æ˜¾ç¤ºå‰15é¦–
        'all_unmatched': unmatched,  # ä¿å­˜æ‰€æœ‰æœªåŒ¹é…æ­Œæ›²ç”¨äºä¸‹è½½
        'mode': match_mode
    }
    return result, None


# ============================================================
# æ•°æ®åº“æ“ä½œ
# ============================================================

def init_database():
    global database_conn
    database_conn = sqlite3.connect(str(DATABASE_FILE), check_same_thread=False)
    cursor = database_conn.cursor()
    
    # ç”¨æˆ·ç»‘å®šè¡¨
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_bindings (
            telegram_id TEXT PRIMARY KEY,
            emby_username TEXT NOT NULL,
            emby_password TEXT NOT NULL,
            emby_user_id TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # æ­Œå•åŒæ­¥è®°å½•
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS playlist_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id TEXT,
            playlist_name TEXT,
            platform TEXT,
            total_songs INTEGER,
            matched_songs INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # ä¸Šä¼ è®°å½•
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS upload_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id TEXT,
            original_name TEXT,
            saved_name TEXT,
            file_size INTEGER,
            status TEXT DEFAULT 'completed',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # å®šæ—¶åŒæ­¥æ­Œå•
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS scheduled_playlists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id TEXT NOT NULL,
            playlist_url TEXT NOT NULL,
            playlist_name TEXT,
            platform TEXT,
            last_song_ids TEXT,
            last_sync_at TIMESTAMP,
            is_active INTEGER DEFAULT 1,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(telegram_id, playlist_url)
        )
    ''')
    
    # æ·»åŠ  is_active å­—æ®µï¼ˆå…¼å®¹æ—§æ•°æ®åº“ï¼‰
    try:
        cursor.execute('ALTER TABLE scheduled_playlists ADD COLUMN is_active INTEGER DEFAULT 1')
    except:
        pass  # å­—æ®µå·²å­˜åœ¨
    
    database_conn.commit()
    logger.info(f"æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: {DATABASE_FILE}")

def get_user_binding(telegram_id):
    if not database_conn: return None
    cursor = database_conn.cursor()
    cursor.execute('SELECT emby_username, emby_password, emby_user_id FROM user_bindings WHERE telegram_id = ?',
                  (str(telegram_id),))
    result = cursor.fetchone()
    if result:
        try:
            return {'emby_username': result[0], 'emby_password': decrypt_password(result[1]), 'emby_user_id': result[2]}
        except:
            return None
    return None

def save_user_binding(telegram_id, emby_username, emby_password, emby_user_id=None):
    if not database_conn: return False
    try:
        cursor = database_conn.cursor()
        cursor.execute('INSERT OR REPLACE INTO user_bindings VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)',
                      (str(telegram_id), emby_username, encrypt_password(emby_password), emby_user_id))
        database_conn.commit()
        return True
    except:
        return False

def delete_user_binding(telegram_id):
    if not database_conn: return False
    try:
        cursor = database_conn.cursor()
        cursor.execute('DELETE FROM user_bindings WHERE telegram_id = ?', (str(telegram_id),))
        database_conn.commit()
        return True
    except:
        return False

def save_playlist_record(telegram_id, name, platform, total, matched):
    if not database_conn: return
    try:
        cursor = database_conn.cursor()
        cursor.execute('INSERT INTO playlist_records (telegram_id, playlist_name, platform, total_songs, matched_songs) VALUES (?, ?, ?, ?, ?)',
                      (str(telegram_id), name, platform, total, matched))
        database_conn.commit()
    except:
        pass

def save_upload_record(telegram_id, original_name, saved_name, file_size):
    if not database_conn: return
    try:
        cursor = database_conn.cursor()
        cursor.execute('INSERT INTO upload_records (telegram_id, original_name, saved_name, file_size) VALUES (?, ?, ?, ?)',
                      (str(telegram_id), original_name, saved_name, file_size))
        database_conn.commit()
    except:
        pass


def save_download_record(songs: list, success_files: list, failed_songs: list, 
                         platform: str, quality: str, user_id: str = None):
    """ä¿å­˜ä¸‹è½½è®°å½•åˆ°å†å²è¡¨"""
    if not database_conn:
        return
    try:
        cursor = database_conn.cursor()
        
        # ç¡®ä¿è¡¨å­˜åœ¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS download_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id TEXT,
                song_id TEXT,
                title TEXT,
                artist TEXT,
                platform TEXT,
                quality TEXT,
                status TEXT,
                file_path TEXT,
                file_size INTEGER DEFAULT 0,
                duration REAL DEFAULT 0,
                error_message TEXT,
                user_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        import uuid
        
        # è®°å½•æˆåŠŸçš„ä¸‹è½½
        for i, file_path in enumerate(success_files):
            song = songs[i] if i < len(songs) else {}
            
            # è·å–æ–‡ä»¶å¤§å°
            file_size = 0
            if file_path:
                try:
                    p = Path(file_path)
                    if p.exists():
                        file_size = p.stat().st_size
                        logger.debug(f"è·å–æ–‡ä»¶å¤§å°æˆåŠŸ: {file_size} bytes")
                    else:
                        logger.warning(f"ä¿å­˜ä¸‹è½½è®°å½•æ—¶æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
                except Exception as e:
                    logger.warning(f"è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {e}")
            
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, file_path, file_size, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', '')),
                song.get('title', Path(file_path).stem if file_path else ''),
                song.get('artist', ''),
                platform,
                quality,
                'completed',
                file_path,
                file_size,
                user_id
            ))
        
        # è®°å½•å¤±è´¥çš„ä¸‹è½½
        for song in failed_songs:
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, error_message, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', '')),
                song.get('title', ''),
                song.get('artist', ''),
                platform,
                quality,
                'failed',
                song.get('error', 'ä¸‹è½½å¤±è´¥'),
                user_id
            ))
        
        database_conn.commit()
        logger.debug(f"ä¿å­˜ä¸‹è½½è®°å½•: {len(success_files)} æˆåŠŸ, {len(failed_songs)} å¤±è´¥")
    except Exception as e:
        logger.error(f"ä¿å­˜ä¸‹è½½è®°å½•å¤±è´¥: {e}")


def save_download_record_v2(success_results: list, failed_songs: list, 
                            quality: str, user_id: str = None):
    """ä¿å­˜ä¸‹è½½è®°å½•åˆ°å†å²è¡¨ï¼ˆæ”¯æŒæŒ‰å®é™…å¹³å°è®°å½•ï¼‰
    
    Args:
        success_results: [{'file': path, 'platform': 'NCM'/'QQ', 'song': song_info}, ...]
        failed_songs: å¤±è´¥çš„æ­Œæ›²åˆ—è¡¨
        quality: ä¸‹è½½éŸ³è´¨
        user_id: ç”¨æˆ·ID
    """
    if not database_conn:
        return
    try:
        cursor = database_conn.cursor()
        
        # ç¡®ä¿è¡¨å­˜åœ¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS download_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id TEXT,
                song_id TEXT,
                title TEXT,
                artist TEXT,
                platform TEXT,
                quality TEXT,
                status TEXT,
                file_path TEXT,
                file_size INTEGER DEFAULT 0,
                duration REAL DEFAULT 0,
                error_message TEXT,
                user_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        import uuid
        
        # è®°å½•æˆåŠŸçš„ä¸‹è½½ï¼ˆæŒ‰å®é™…ä¸‹è½½å¹³å°ï¼‰
        for result in success_results:
            file_path = result.get('file', '')
            platform = result.get('platform', 'NCM')
            song = result.get('song', {})
            
            # ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ file_sizeï¼ˆåœ¨ä¸‹è½½æ—¶ç«‹å³è·å–çš„ï¼‰ï¼Œé¿å…æ–‡ä»¶è¢«å¤–éƒ¨ç¨‹åºç§»èµ°åæ— æ³•è·å–
            file_size = result.get('file_size', 0)
            
            # å¦‚æœæ²¡æœ‰é¢„å…ˆè·å–çš„å¤§å°ï¼Œå°è¯•ä»æ–‡ä»¶è·å–
            if not file_size and file_path:
                try:
                    p = Path(file_path)
                    if p.exists():
                        file_size = p.stat().st_size
                        logger.debug(f"è·å–æ–‡ä»¶å¤§å°æˆåŠŸ: {file_size} bytes, è·¯å¾„: {file_path}")
                    else:
                        logger.warning(f"ä¿å­˜ä¸‹è½½è®°å½•æ—¶æ–‡ä»¶ä¸å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«å¤–éƒ¨ç¨‹åºç§»èµ°ï¼‰: {file_path}")
                except Exception as e:
                    logger.warning(f"è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {e}, è·¯å¾„: {file_path}")
            
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, file_path, file_size, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', song.get('source_id', ''))),
                song.get('title', Path(file_path).stem if file_path else ''),
                song.get('artist', ''),
                platform,
                quality,
                'completed',
                file_path,
                file_size,
                user_id
            ))
        
        # è®°å½•å¤±è´¥çš„ä¸‹è½½
        for song in failed_songs:
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, error_message, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', song.get('source_id', ''))),
                song.get('title', ''),
                song.get('artist', ''),
                song.get('platform', 'NCM'),  # å¤±è´¥çš„è®°å½•åŸå§‹å¹³å°
                quality,
                'failed',
                song.get('error', 'ä¸‹è½½å¤±è´¥'),
                user_id
            ))
        
        database_conn.commit()
        
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        logger.debug(f"ä¿å­˜ä¸‹è½½è®°å½•: NCM {ncm_count} é¦–, QQ {qq_count} é¦–, å¤±è´¥ {len(failed_songs)} é¦–")
    except Exception as e:
        logger.error(f"ä¿å­˜ä¸‹è½½è®°å½•å¤±è´¥: {e}")


# ============================================================
# å®šæ—¶åŒæ­¥æ­Œå•
# ============================================================

def add_scheduled_playlist(telegram_id: str, playlist_url: str, playlist_name: str, platform: str, song_ids: list):
    """æ·»åŠ å®šæ—¶åŒæ­¥æ­Œå•"""
    if not database_conn:
        return False
    try:
        cursor = database_conn.cursor()
        song_ids_json = json.dumps(song_ids)
        cursor.execute('''
            INSERT OR REPLACE INTO scheduled_playlists 
            (telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at)
            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        ''', (str(telegram_id), playlist_url, playlist_name, platform, song_ids_json))
        database_conn.commit()
        return True
    except Exception as e:
        logger.error(f"æ·»åŠ å®šæ—¶åŒæ­¥æ­Œå•å¤±è´¥: {e}")
        return False

def get_scheduled_playlists(telegram_id: str = None):
    """è·å–å®šæ—¶åŒæ­¥æ­Œå•åˆ—è¡¨"""
    if not database_conn:
        return []
    try:
        cursor = database_conn.cursor()
        if telegram_id:
            cursor.execute('''
                SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at
                FROM scheduled_playlists WHERE telegram_id = ? ORDER BY created_at DESC
            ''', (str(telegram_id),))
        else:
            cursor.execute('''
                SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at
                FROM scheduled_playlists ORDER BY created_at DESC
            ''')
        rows = cursor.fetchall()
        return [
            {
                'id': row[0],
                'telegram_id': row[1],
                'playlist_url': row[2],
                'playlist_name': row[3],
                'platform': row[4],
                'last_song_ids': json.loads(row[5]) if row[5] else [],
                'last_sync_at': row[6]
            }
            for row in rows
        ]
    except Exception as e:
        logger.error(f"è·å–å®šæ—¶åŒæ­¥æ­Œå•å¤±è´¥: {e}")
        return []

def delete_scheduled_playlist(playlist_id: int, telegram_id: str = None):
    """åˆ é™¤å®šæ—¶åŒæ­¥æ­Œå•"""
    if not database_conn:
        return False
    try:
        cursor = database_conn.cursor()
        if telegram_id:
            cursor.execute('DELETE FROM scheduled_playlists WHERE id = ? AND telegram_id = ?', 
                          (playlist_id, str(telegram_id)))
        else:
            cursor.execute('DELETE FROM scheduled_playlists WHERE id = ?', (playlist_id,))
        database_conn.commit()
        return cursor.rowcount > 0
    except:
        return False

def update_scheduled_playlist_songs(playlist_id: int, song_ids: list):
    """æ›´æ–°æ­Œå•çš„æ­Œæ›²åˆ—è¡¨"""
    if not database_conn:
        return False
    try:
        cursor = database_conn.cursor()
        song_ids_json = json.dumps(song_ids)
        cursor.execute('''
            UPDATE scheduled_playlists SET last_song_ids = ?, last_sync_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ''', (song_ids_json, playlist_id))
        database_conn.commit()
        return True
    except:
        return False


async def check_playlist_updates(app):
    """æ£€æŸ¥æ­Œå•æ›´æ–°å¹¶åŒæ­¥æ–°æ­Œæ›²"""
    logger.info("å¼€å§‹æ£€æŸ¥æ­Œå•æ›´æ–°...")
    
    playlists = get_scheduled_playlists()
    if not playlists:
        return
    
    for playlist in playlists:
        try:
            telegram_id = playlist['telegram_id']
            playlist_url = playlist['playlist_url']
            platform = playlist['platform']
            old_song_ids = set(playlist['last_song_ids'])
            
            # è·å–æ­Œå•æœ€æ–°æ­Œæ›²
            if platform == 'netease':
                playlist_id = extract_playlist_id(playlist_url, 'netease')
                if not playlist_id:
                    continue
                playlist_name, songs = get_ncm_playlist_details(playlist_id)
            elif platform == 'qq':
                playlist_id = extract_playlist_id(playlist_url, 'qq')
                if not playlist_id:
                    continue
                playlist_name, songs = get_qq_playlist_details(playlist_id)
            else:
                continue
            
            if not songs:
                continue
            
            # è®¡ç®—æ–°å¢æ­Œæ›²
            current_song_ids = [str(s.get('id', s.get('title', ''))) for s in songs]
            new_songs = [s for s in songs if str(s.get('id', s.get('title', ''))) not in old_song_ids]
            
            if new_songs:
                logger.info(f"æ­Œå• '{playlist['playlist_name']}' å‘ç° {len(new_songs)} é¦–æ–°æ­Œæ›²")
                
                # å‘é€é€šçŸ¥
                try:
                    message = f"ğŸ”” **æ­Œå•æ›´æ–°é€šçŸ¥**\n\n"
                    message += f"ğŸ“‹ æ­Œå•: `{playlist['playlist_name']}`\n"
                    message += f"ğŸ†• æ–°å¢: {len(new_songs)} é¦–æ­Œæ›²\n\n"
                    for i, s in enumerate(new_songs[:5]):
                        message += f"{i+1}. {s['title']} - {s['artist']}\n"
                    if len(new_songs) > 5:
                        message += f"... è¿˜æœ‰ {len(new_songs) - 5} é¦–\n"
                    
                    # æ·»åŠ ä¸‹è½½æŒ‰é’®
                    keyboard = [
                        [
                            InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{playlist['id']}"),
                            InlineKeyboardButton("ğŸ”„ åŒæ­¥åˆ°Emby", callback_data=f"sync_emby_{playlist['id']}")
                        ]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await app.bot.send_message(
                        chat_id=int(telegram_id),
                        text=message,
                        parse_mode='Markdown',
                        reply_markup=reply_markup
                    )
                except Exception as e:
                    logger.error(f"å‘é€æ­Œå•æ›´æ–°é€šçŸ¥å¤±è´¥: {e}")
            
            # æ›´æ–°æ­Œæ›²åˆ—è¡¨
            update_scheduled_playlist_songs(playlist['id'], current_song_ids)
            
        except Exception as e:
            logger.error(f"æ£€æŸ¥æ­Œå• '{playlist.get('playlist_name', '')}' æ›´æ–°å¤±è´¥: {e}")
    
    logger.info("æ­Œå•æ›´æ–°æ£€æŸ¥å®Œæˆ")


async def scheduled_sync_job(app):
    """å®šæ—¶åŒæ­¥ä»»åŠ¡"""
    while True:
        try:
            # æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡
            await asyncio.sleep(6 * 60 * 60)
            await check_playlist_updates(app)
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å‡ºé”™: {e}")
            await asyncio.sleep(60)  # å‡ºé”™åç­‰å¾… 1 åˆ†é’Ÿé‡è¯•


async def scheduled_emby_scan_job(app):
    """å®šæ—¶æ‰«æ Emby åª’ä½“åº“"""
    # è·å–æ‰«æé—´éš”ï¼ˆä¼˜å…ˆæ•°æ®åº“é…ç½®ï¼‰
    def get_scan_interval():
        try:
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                row = cursor.fetchone()
                if row:
                    return int(row[0] if isinstance(row, tuple) else row['value'])
        except:
            pass
        return EMBY_SCAN_INTERVAL
    
    while True:
        try:
            interval = get_scan_interval()
            if interval <= 0:
                # ç¦ç”¨å®šæ—¶æ‰«æï¼Œæ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡é…ç½®æ˜¯å¦å˜åŒ–
                await asyncio.sleep(60 * 60)
                continue
            
            # ç­‰å¾…æŒ‡å®šæ—¶é—´
            await asyncio.sleep(interval * 60 * 60)
            
            # æ‰§è¡Œæ‰«æ
            logger.info("å¼€å§‹å®šæ—¶æ‰«æ Emby åª’ä½“åº“...")
            if emby_auth.get('access_token'):
                old_count = len(emby_library_data)
                scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
                new_count = len(emby_library_data)
                
                if new_count != old_count:
                    logger.info(f"Emby åª’ä½“åº“æ›´æ–°: {old_count} -> {new_count} é¦–")
                    # é€šçŸ¥ç®¡ç†å‘˜
                    if ADMIN_USER_ID:
                        try:
                            await app.bot.send_message(
                                chat_id=ADMIN_USER_ID,
                                text=f"ğŸ”„ Emby åª’ä½“åº“å·²è‡ªåŠ¨æ›´æ–°\n\n"
                                     f"ğŸ“Š æ­Œæ›²æ•°é‡: {old_count} â†’ {new_count}\n"
                                     f"ğŸ“ˆ å˜åŒ–: {'+' if new_count > old_count else ''}{new_count - old_count}"
                            )
                        except:
                            pass
                else:
                    logger.info(f"Emby åª’ä½“åº“æ— å˜åŒ–: {new_count} é¦–")
            else:
                logger.warning("Emby æœªè®¤è¯ï¼Œè·³è¿‡å®šæ—¶æ‰«æ")
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"å®šæ—¶æ‰«æ Emby å‡ºé”™: {e}")
            await asyncio.sleep(60)

def get_ncm_settings():
    """è·å–ç½‘æ˜“äº‘ä¸‹è½½è®¾ç½®ï¼ˆä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼Œå¦åˆ™ä»ç¯å¢ƒå˜é‡ï¼‰"""
    default_settings = {
        'ncm_quality': os.environ.get('NCM_QUALITY', 'exhigh'),
        'auto_download': os.environ.get('AUTO_DOWNLOAD', 'false').lower() == 'true',
        'download_mode': 'local',
        'download_dir': str(MUSIC_TARGET_DIR),
        'musictag_dir': '',
        'organize_dir': ''
    }
    
    if not database_conn:
        return default_settings
    
    try:
        cursor = database_conn.cursor()
        
        # ç¡®ä¿è®¾ç½®è¡¨å­˜åœ¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS bot_settings (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('ncm_quality',))
        row = cursor.fetchone()
        ncm_quality = row[0] if row else default_settings['ncm_quality']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('auto_download',))
        row = cursor.fetchone()
        auto_download = row[0] == 'true' if row else default_settings['auto_download']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('download_mode',))
        row = cursor.fetchone()
        download_mode = row[0] if row else default_settings['download_mode']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('download_dir',))
        row = cursor.fetchone()
        download_dir = row[0] if row else default_settings['download_dir']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('musictag_dir',))
        row = cursor.fetchone()
        musictag_dir = row[0] if row else default_settings['musictag_dir']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_dir',))
        row = cursor.fetchone()
        organize_dir = row[0] if row else default_settings['organize_dir']
        
        return {
            'ncm_quality': ncm_quality,
            'auto_download': auto_download,
            'download_mode': download_mode,
            'download_dir': download_dir,
            'musictag_dir': musictag_dir,
            'organize_dir': organize_dir
        }
    except:
        return default_settings

def get_stats():
    """è·å–ç»Ÿè®¡æ•°æ®"""
    if not database_conn: return {}
    cursor = database_conn.cursor()
    
    cursor.execute('SELECT COUNT(*) FROM user_bindings')
    users = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*), SUM(matched_songs) FROM playlist_records')
    row = cursor.fetchone()
    playlists, songs_synced = row[0] or 0, row[1] or 0
    
    cursor.execute('SELECT COUNT(*), SUM(file_size) FROM upload_records')
    row = cursor.fetchone()
    uploads, upload_size = row[0] or 0, row[1] or 0
    
    return {
        'users': users,
        'playlists': playlists,
        'songs_synced': songs_synced,
        'uploads': uploads,
        'upload_size': upload_size,
        'library_songs': len(emby_library_data)
    }

def get_recent_records(limit=20):
    """è·å–æœ€è¿‘è®°å½•"""
    if not database_conn: return [], []
    cursor = database_conn.cursor()
    
    cursor.execute('SELECT playlist_name, platform, total_songs, matched_songs, created_at FROM playlist_records ORDER BY created_at DESC LIMIT ?', (limit,))
    playlists = cursor.fetchall()
    
    cursor.execute('SELECT original_name, saved_name, file_size, created_at FROM upload_records ORDER BY created_at DESC LIMIT ?', (limit,))
    uploads = cursor.fetchall()
    
    return playlists, uploads


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - ä¸»èœå•
# ============================================================

def get_main_menu_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ“‹ æ­Œå•åŒæ­¥", callback_data="menu_playlist"),
         InlineKeyboardButton("ğŸ“¤ éŸ³ä¹ä¸Šä¼ ", callback_data="menu_upload")],
        [InlineKeyboardButton("âš™ï¸ è®¾ç½®", callback_data="menu_settings"),
         InlineKeyboardButton("ğŸ“Š çŠ¶æ€", callback_data="menu_status")]
    ])

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    binding = get_user_binding(user_id)
    
    welcome = f"ğŸ‘‹ æ¬¢è¿ä½¿ç”¨ **{APP_NAME}**ï¼\n\n"
    if binding:
        welcome += f"å·²ç»‘å®š Emby: `{binding['emby_username']}`\n\n"
    else:
        welcome += "âš ï¸ å°šæœªç»‘å®š Emby è´¦æˆ·\n\n"
    welcome += "è¯·é€‰æ‹©åŠŸèƒ½ï¼š"
    
    await update.message.reply_text(welcome, reply_markup=get_main_menu_keyboard(), parse_mode='Markdown')

async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
**ğŸ“– TGmusicbot ä½¿ç”¨å¸®åŠ©**

**ğŸµ æ­Œå•åŒæ­¥ï¼š** ç›´æ¥å‘é€æ­Œå•é“¾æ¥
**ğŸ“¤ ä¸Šä¼ éŸ³ä¹ï¼š** ç›´æ¥å‘é€éŸ³é¢‘æ–‡ä»¶

**ğŸ“‹ æœç´¢ä¸‹è½½ï¼š**
`/ss å…³é”®è¯` - ç½‘æ˜“äº‘æœç´¢æ­Œæ›²
`/al ä¸“è¾‘å` - ç½‘æ˜“äº‘æœç´¢ä¸“è¾‘
`/qs å…³é”®è¯` - QQéŸ³ä¹æœç´¢æ­Œæ›²
`/qa ä¸“è¾‘å` - QQéŸ³ä¹æœç´¢ä¸“è¾‘

**ğŸ“¥ ä¸‹è½½ç®¡ç†ï¼š**
`/ds` - æŸ¥çœ‹ä¸‹è½½çŠ¶æ€
`/dq` - æŸ¥çœ‹ä¸‹è½½é˜Ÿåˆ—
`/dh` - æŸ¥çœ‹ä¸‹è½½å†å²

**ğŸ“‹ å…¶ä»–å‘½ä»¤ï¼š**
`/req æ­Œæ›²-æ­Œæ‰‹` - ç”³è¯·è¡¥å…¨æ­Œæ›²
`/mr` - æŸ¥çœ‹æˆ‘çš„ç”³è¯·
`/sub` - æŸ¥çœ‹è®¢é˜…æ­Œå•
`/unsub åºå·` - å–æ¶ˆè®¢é˜…
`/scan` - æ‰‹åŠ¨æ‰«æEmbyåº“
`/si å°æ—¶` - è®¾ç½®è‡ªåŠ¨æ‰«æé—´éš”

**ğŸ”§ åŸºç¡€å‘½ä»¤ï¼š**
`/b ç”¨æˆ·å å¯†ç ` - ç»‘å®šEmby
`/unbind` - è§£é™¤ç»‘å®š
`/s` - æŸ¥çœ‹çŠ¶æ€

ğŸ’¡ æ‰€æœ‰çŸ­å‘½ä»¤éƒ½æœ‰å®Œæ•´ç‰ˆæœ¬ï¼Œå¦‚ /ss = /search
"""
    await update.message.reply_text(help_text, parse_mode='Markdown')


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - æ­Œå•åŒæ­¥
# ============================================================

async def handle_playlist_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    user_id = str(update.effective_user.id)
    
    playlist_type, _ = parse_playlist_input(text)
    if not playlist_type:
        return False
    
    binding = get_user_binding(user_id)
    if not binding:
        await update.message.reply_text("è¯·å…ˆç»‘å®š Emby è´¦æˆ·ï¼š/bind <ç”¨æˆ·å> <å¯†ç >")
        return True
    
    context.user_data['playlist_url'] = text
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("âš¡ æ¨¡ç³ŠåŒ¹é…", callback_data="match_fuzzy"),
         InlineKeyboardButton("ğŸ¯ å®Œå…¨åŒ¹é…", callback_data="match_exact")]
    ])
    await update.message.reply_text("è¯·é€‰æ‹©åŒ¹é…æ¨¡å¼ï¼š", reply_markup=keyboard)
    return True

async def handle_match_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    playlist_url = context.user_data.pop('playlist_url', None)
    
    if not playlist_url:
        await query.edit_message_text("è¯·é‡æ–°å‘é€æ­Œå•é“¾æ¥")
        return
    
    match_mode = "å®Œå…¨åŒ¹é…" if query.data == 'match_exact' else "æ¨¡ç³ŠåŒ¹é…"
    await query.edit_message_text(
        f"ğŸ”„ **æ­£åœ¨åŒæ­¥æ­Œå•**\n\n"
        f"â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 10%\n\n"
        f"ğŸ“‹ æ¨¡å¼: `{match_mode}`\n"
        f"â³ æ­£åœ¨è·å–æ­Œå•ä¿¡æ¯...",
        parse_mode='Markdown'
    )
    
    binding = get_user_binding(user_id)
    if not binding:
        await query.message.reply_text("è¯·å…ˆç»‘å®š Emby è´¦æˆ·")
        return
    
    try:
        result, error = await asyncio.to_thread(process_playlist, playlist_url, user_id, False, binding, match_mode)
        
        if error:
            await query.message.reply_text(f"âŒ {error}")
        else:
            # è‡ªåŠ¨æ·»åŠ åˆ°å®šæ—¶åŒæ­¥åˆ—è¡¨
            playlist_type, _ = parse_playlist_input(playlist_url)
            if playlist_type and user_id == ADMIN_USER_ID:
                # è·å–æ­Œæ›² ID åˆ—è¡¨ç”¨äºåç»­æ¯”è¾ƒ
                song_ids = [str(s.get('id', s.get('title', ''))) for s in result.get('all_unmatched', []) + result.get('unmatched_songs', [])]
                # ä»åŸå§‹æ­Œå•è·å–
                if playlist_type == "netease":
                    _, songs = get_ncm_playlist_details(extract_playlist_id(playlist_url, 'netease'))
                else:
                    _, songs = get_qq_playlist_details(extract_playlist_id(playlist_url, 'qq'))
                if songs:
                    song_ids = [str(s.get('id', s.get('title', ''))) for s in songs]
                add_scheduled_playlist(user_id, playlist_url, result['name'], playlist_type, song_ids)
            
            msg = f"âœ… **æ­Œå•åŒæ­¥å®Œæˆ**\n\n"
            msg += f"ğŸ“‹ æ­Œå•: `{result['name']}`\n"
            msg += f"ğŸ¯ æ¨¡å¼: `{result['mode']}`\n"
            msg += f"ğŸ“Š æ€»æ•°: {result['total']} é¦–\n"
            msg += f"âœ… åŒ¹é…: {result['matched']} é¦–\n"
            msg += f"âŒ æœªåŒ¹é…: {result['unmatched']} é¦–\n"
            msg += f"ğŸ“… å·²æ·»åŠ åˆ°å®šæ—¶åŒæ­¥\n"
            
            # æ£€æŸ¥æ˜¯å¦å¯ä»¥è‡ªåŠ¨ä¸‹è½½ï¼ˆç½‘æ˜“äº‘æ­Œå•ä¸”æœ‰æœªåŒ¹é…æ­Œæ›²æ—¶ï¼‰
            ncm_unmatched = [s for s in result.get('all_unmatched', result.get('unmatched_songs', [])) if s.get('platform') == 'NCM']
            all_unmatched = result.get('all_unmatched', result.get('unmatched_songs', []))
            
            if all_unmatched:
                # ä¿å­˜æ‰€æœ‰æœªåŒ¹é…æ­Œæ›²ç”¨äºç¿»é¡µ
                context.user_data['all_unmatched_songs'] = all_unmatched
                context.user_data['unmatched_page'] = 0
                
                msg += "\n**æœªåŒ¹é…æ­Œæ›²ï¼š**\n"
                page_size = 10
                for i, s in enumerate(all_unmatched[:page_size]):
                    msg += f"`{i+1}. {s['title']} - {s['artist']}`\n"
                if len(all_unmatched) > page_size:
                    msg += f"...è¿˜æœ‰ {len(all_unmatched) - page_size} é¦–\n"
            
            keyboard_buttons = []
            
            # ç¿»é¡µæŒ‰é’®ï¼ˆå¦‚æœè¶…è¿‡10é¦–ï¼‰
            if len(all_unmatched) > 10:
                keyboard_buttons.append([
                    InlineKeyboardButton("ğŸ“„ æŸ¥çœ‹æ›´å¤š", callback_data="unmatched_page_1")
                ])
            
            if ncm_unmatched and user_id == ADMIN_USER_ID:
                # ä¿å­˜æœªåŒ¹é…æ­Œæ›²åˆ°ç”¨æˆ·æ•°æ®
                context.user_data['unmatched_ncm_songs'] = ncm_unmatched
                msg += f"\nğŸ’¡ æ£€æµ‹åˆ° {len(ncm_unmatched)} é¦–ç½‘æ˜“äº‘æ­Œæ›²å¯è‡ªåŠ¨ä¸‹è½½"
                keyboard_buttons.append([
                    InlineKeyboardButton("ğŸ“¥ è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²", callback_data="download_missing")
                ])
            
            keyboard = InlineKeyboardMarkup(keyboard_buttons) if keyboard_buttons else None
            
            await query.message.reply_text(msg, parse_mode='Markdown', reply_markup=keyboard)
    except Exception as e:
        logger.exception(f"å¤„ç†æ­Œå•å¤±è´¥: {e}")
        await query.message.reply_text(f"å¤„ç†å¤±è´¥: {e}")


async def handle_unmatched_page_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æœªåŒ¹é…æ­Œæ›²ç¿»é¡µ"""
    query = update.callback_query
    await query.answer()
    
    # è§£æé¡µç 
    data = query.data  # unmatched_page_1
    try:
        page = int(data.split('_')[-1])
    except:
        page = 0
    
    all_unmatched = context.user_data.get('all_unmatched_songs', [])
    if not all_unmatched:
        await query.edit_message_text("æœªåŒ¹é…æ­Œæ›²åˆ—è¡¨å·²è¿‡æœŸï¼Œè¯·é‡æ–°åŒæ­¥æ­Œå•")
        return
    
    page_size = 10
    total_pages = (len(all_unmatched) + page_size - 1) // page_size
    start_idx = page * page_size
    end_idx = min(start_idx + page_size, len(all_unmatched))
    
    # æ„å»ºæ¶ˆæ¯
    msg = f"**æœªåŒ¹é…æ­Œæ›²** (ç¬¬ {page + 1}/{total_pages} é¡µ)\n\n"
    for i, s in enumerate(all_unmatched[start_idx:end_idx], start=start_idx + 1):
        msg += f"`{i}. {s['title']} - {s['artist']}`\n"
    
    msg += f"\nğŸ“Š å…± {len(all_unmatched)} é¦–æœªåŒ¹é…"
    
    # æ„å»ºç¿»é¡µæŒ‰é’®
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("â¬…ï¸ ä¸Šä¸€é¡µ", callback_data=f"unmatched_page_{page - 1}"))
    if page < total_pages - 1:
        nav_buttons.append(InlineKeyboardButton("â¡ï¸ ä¸‹ä¸€é¡µ", callback_data=f"unmatched_page_{page + 1}"))
    
    keyboard_buttons = []
    if nav_buttons:
        keyboard_buttons.append(nav_buttons)
    
    # å¦‚æœæœ‰ç½‘æ˜“äº‘æ­Œæ›²ä¸”æ˜¯ç®¡ç†å‘˜ï¼Œæ˜¾ç¤ºä¸‹è½½æŒ‰é’®
    user_id = str(query.from_user.id)
    ncm_unmatched = context.user_data.get('unmatched_ncm_songs', [])
    if ncm_unmatched and user_id == ADMIN_USER_ID:
        keyboard_buttons.append([
            InlineKeyboardButton("ğŸ“¥ è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²", callback_data="download_missing")
        ])
    
    keyboard = InlineKeyboardMarkup(keyboard_buttons) if keyboard_buttons else None
    
    await query.edit_message_text(msg, parse_mode='Markdown', reply_markup=keyboard)


async def handle_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†è‡ªåŠ¨ä¸‹è½½å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
        return
    
    ncm_cookie = get_ncm_cookie()
    if not ncm_cookie:
        await query.edit_message_text("æœªé…ç½®ç½‘æ˜“äº‘ Cookieï¼Œæ— æ³•ä¸‹è½½\n\nè¯·åœ¨ Web ç•Œé¢ä½¿ç”¨æ‰«ç ç™»å½•æˆ–æ‰‹åŠ¨é…ç½® Cookie")
        return
    
    unmatched_songs = context.user_data.get('unmatched_ncm_songs', [])
    ncm_songs = [s for s in unmatched_songs if s.get('platform') == 'NCM']
    
    if not ncm_songs:
        await query.edit_message_text("æ²¡æœ‰éœ€è¦ä¸‹è½½çš„ç½‘æ˜“äº‘æ­Œæ›²")
        return
    
    await query.edit_message_text(f"ğŸ”„ æ­£åœ¨ä¸‹è½½ {len(ncm_songs)} é¦–æ­Œæ›²...\n\nè¯·è€å¿ƒç­‰å¾…ï¼Œä¸‹è½½å®Œæˆåä¼šé€šçŸ¥æ‚¨ã€‚")
    
    try:
        # åŠ¨æ€å¯¼å…¥ä¸‹è½½æ¨¡å—
        from bot.ncm_downloader import MusicAutoDownloader
        
        # ä»æ•°æ®åº“è¯»å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        
        # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
        qq_cookie = get_qq_cookie()
        
        downloader = MusicAutoDownloader(
            ncm_cookie, qq_cookie, str(download_path),
            proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
        )
        
        # æ£€æŸ¥ç™»å½•çŠ¶æ€
        logged_in, info = downloader.check_ncm_login()
        if not logged_in:
            await query.message.reply_text("âŒ ç½‘æ˜“äº‘ Cookie å·²å¤±æ•ˆï¼Œè¯·æ›´æ–°")
            return
        
        await query.message.reply_text(f"ğŸµ ç½‘æ˜“äº‘ç™»å½•æˆåŠŸ: {info.get('nickname')} (VIP: {'æ˜¯' if info.get('is_vip') else 'å¦'})")
        
        # åˆ›å»ºè¿›åº¦æ¶ˆæ¯
        progress_msg = await query.message.reply_text(
            make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", 0, len(ncm_songs), "å‡†å¤‡å¼€å§‹...")
        )
        last_update_time = [0]  # ç”¨åˆ—è¡¨æ¥å…è®¸åœ¨é—­åŒ…ä¸­ä¿®æ”¹
        main_loop = asyncio.get_running_loop()  # åœ¨ä¸»çº¿ç¨‹è·å– loop
        
        async def update_progress(current, total, song):
            """æ›´æ–°ä¸‹è½½è¿›åº¦"""
            import time as time_module
            now = time_module.time()
            # é™åˆ¶æ›´æ–°é¢‘ç‡ï¼Œé¿å… Telegram API é™æµ
            if now - last_update_time[0] < 1.5:
                return
            last_update_time[0] = now
            try:
                song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                await progress_msg.edit_text(
                    make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", current, total, song_name),
                    parse_mode='Markdown'
                )
            except:
                pass
        
        # åŒ…è£…åŒæ­¥å›è°ƒä¸ºå¼‚æ­¥
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        # å¼€å§‹ä¸‹è½½
        success_results, failed_songs = await asyncio.to_thread(
            downloader.download_missing_songs,
            ncm_songs,
            download_quality,
            sync_progress_callback
        )
        
        # æå–æˆåŠŸçš„æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        success_files = [r['file'] for r in success_results]
        
        # å¦‚æœè®¾ç½®äº† MusicTag æ¨¡å¼ï¼Œç§»åŠ¨æ–‡ä»¶åˆ° MusicTag ç›®å½•
        moved_files = []
        if download_mode == 'musictag' and musictag_dir and success_files:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            
            for i, file_path in enumerate(success_files):
                try:
                    src = Path(file_path)
                    if not src.exists():
                        logger.warning(f"æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨: {file_path}")
                        continue
                    dst = musictag_path / src.name
                    shutil.move(str(src), str(dst))
                    moved_files.append(str(dst))
                    # æ›´æ–° success_results ä¸­çš„æ–‡ä»¶è·¯å¾„ï¼Œä»¥ä¾¿æ­£ç¡®è®°å½•æ–‡ä»¶å¤§å°
                    success_results[i]['file'] = str(dst)
                    logger.info(f"å·²ç§»åŠ¨æ–‡ä»¶åˆ° MusicTag: {src.name}")
                except Exception as e:
                    logger.error(f"ç§»åŠ¨æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
        
        # åˆ é™¤è¿›åº¦æ¶ˆæ¯
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…ä¸‹è½½å¹³å°è®°å½•ï¼‰
        save_download_record_v2(success_results, failed_songs, download_quality, user_id)
        
        # æ„å»ºå®Œæˆæ¶ˆæ¯
        success_rate = len(success_files) / max(len(ncm_songs), 1) * 100
        msg = f"âœ… **ä¸‹è½½å®Œæˆ**\n\n"
        msg += f"{make_progress_bar(len(success_files), len(ncm_songs))}\n\n"
        msg += f"ğŸµ éŸ³è´¨: `{download_quality}`\n"
        msg += f"ğŸ“Š æˆåŠŸ: {len(success_files)}/{len(ncm_songs)} é¦–\n"
        
        # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        if qq_count > 0:
            msg += f"   â€¢ ç½‘æ˜“äº‘: {ncm_count} é¦–, QQéŸ³ä¹: {qq_count} é¦–\n"
        
        if success_files:
            if moved_files:
                msg += f"\nğŸ“ å·²è½¬ç§»åˆ° MusicTag\n"
            else:
                msg += f"\nğŸ“ å·²ä¿å­˜åˆ°æœ¬åœ°\n"
        
        if failed_songs and len(failed_songs) <= 5:
            msg += "\n**âŒ ä¸‹è½½å¤±è´¥ï¼š**\n"
            for s in failed_songs:
                msg += f"â€¢ `{s['title']}`\n"
        elif failed_songs:
            msg += f"\nâŒ {len(failed_songs)} é¦–ä¸‹è½½å¤±è´¥\n"
        
        await query.message.reply_text(msg, parse_mode='Markdown')
        
        # è‡ªåŠ¨è§¦å‘ Emby æ‰«åº“ï¼ˆä»…æœ¬åœ°æ¨¡å¼ï¼‰
        if success_files and not moved_files:
            binding = get_user_binding(user_id)
            if binding:
                try:
                    user_access_token, user_id_emby = authenticate_emby(
                        EMBY_URL, binding['emby_username'], decrypt_password(binding['emby_password'])
                    )
                    if user_access_token:
                        user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                        if trigger_emby_library_scan(user_auth):
                            await query.message.reply_text("ğŸ”„ å·²è‡ªåŠ¨è§¦å‘ Emby åª’ä½“åº“æ‰«æï¼Œè¯·ç¨ç­‰å‡ åˆ†é’Ÿåé‡æ–°åŒæ­¥æ­Œå•")
                        else:
                            await query.message.reply_text("ğŸ’¡ æç¤ºï¼šè¯·ä½¿ç”¨ /rescan åˆ·æ–° Emby åª’ä½“åº“")
                except Exception as e:
                    logger.exception(f"è‡ªåŠ¨æ‰«åº“å¤±è´¥: {e}")
                    await query.message.reply_text("ğŸ’¡ æç¤ºï¼šè¯·ä½¿ç”¨ /rescan åˆ·æ–° Emby åª’ä½“åº“")
        
    except ImportError as e:
        logger.error(f"å¯¼å…¥ä¸‹è½½æ¨¡å—å¤±è´¥: {e}")
        await query.message.reply_text("âŒ ä¸‹è½½æ¨¡å—æœªæ­£ç¡®å®‰è£…ï¼Œè¯·æ£€æŸ¥ pycryptodome å’Œ mutagen ä¾èµ–")
    except Exception as e:
        logger.exception(f"ä¸‹è½½å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - éŸ³ä¹ä¸Šä¼ 
# ============================================================

def check_user_permission(telegram_id: str, permission: str) -> bool:
    """æ£€æŸ¥ç”¨æˆ·æƒé™"""
    # ç®¡ç†å‘˜å§‹ç»ˆæœ‰æƒé™
    if telegram_id == ADMIN_USER_ID:
        return True
    
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT * FROM user_permissions WHERE telegram_id = ?', (telegram_id,))
            row = cursor.fetchone()
            if row:
                if permission == 'upload':
                    return bool(row['can_upload'] if isinstance(row, dict) else row[2])
                elif permission == 'request':
                    return bool(row['can_request'] if isinstance(row, dict) else row[3])
            # é»˜è®¤å…è®¸
            return True
    except Exception as e:
        logger.error(f"æ£€æŸ¥ç”¨æˆ·æƒé™å¤±è´¥: {e}")
    return True


async def handle_audio_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†éŸ³é¢‘ä¸Šä¼ """
    user_id = str(update.effective_user.id)
    message = update.message
    
    # æ£€æŸ¥ä¸Šä¼ æƒé™
    if not check_user_permission(user_id, 'upload'):
        await message.reply_text("âŒ ä½ æ²¡æœ‰ä¸Šä¼ æƒé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return True
    
    # è·å–æ–‡ä»¶ä¿¡æ¯
    if message.audio:
        file = message.audio
        original_name = file.file_name or f"{file.title or 'audio'}.mp3"
    elif message.document:
        file = message.document
        original_name = file.file_name or "unknown"
        # æ£€æŸ¥æ˜¯å¦æ˜¯éŸ³é¢‘æ–‡ä»¶
        mime = file.mime_type or ""
        if not (mime.startswith('audio/') or original_name.lower().endswith(ALLOWED_AUDIO_EXTENSIONS)):
            return False
    else:
        return False
    
    file_size = file.file_size or 0
    
    try:
        status_msg = await message.reply_text(f"ğŸ“¥ æ­£åœ¨ä¸‹è½½: {original_name}...")
        
        # è·å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        # ä¸‹è½½æ–‡ä»¶
        tg_file = await context.bot.get_file(file.file_id)
        temp_path = UPLOAD_DIR / original_name
        await tg_file.download_to_drive(temp_path)
        
        # æ¸…ç†æ–‡ä»¶åå¹¶ç§»åŠ¨åˆ°ä¸‹è½½ç›®å½•
        clean_name = clean_filename(original_name)
        target_path = download_path / clean_name
        
        # å¦‚æœç›®æ ‡å·²å­˜åœ¨ï¼Œåˆ é™¤
        if target_path.exists():
            target_path.unlink()
        
        shutil.move(str(temp_path), str(target_path))
        
        # å¦‚æœæ˜¯ MusicTag æ¨¡å¼ï¼Œç»§ç»­ç§»åŠ¨åˆ° MusicTag ç›®å½•
        final_path = target_path
        if download_mode == 'musictag' and musictag_dir:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            final_dest = musictag_path / clean_name
            shutil.move(str(target_path), str(final_dest))
            final_path = final_dest
            logger.info(f"å·²ç§»åŠ¨ä¸Šä¼ æ–‡ä»¶åˆ° MusicTag: {clean_name}")
        
        # è®°å½•
        save_upload_record(user_id, original_name, clean_name, file_size)
        
        size_mb = file_size / 1024 / 1024
        if download_mode == 'musictag' and musictag_dir:
            await status_msg.edit_text(f"âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB\nğŸ“‚ å·²è½¬ç§»åˆ° MusicTag ç›®å½•")
        else:
            await status_msg.edit_text(f"âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB")
        
    except Exception as e:
        logger.exception(f"ä¸Šä¼ å¤±è´¥: {e}")
        await message.reply_text(f"âŒ ä¸Šä¼ å¤±è´¥: {e}")
    
    return True


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - è®¾ç½®å’ŒçŠ¶æ€
# ============================================================

async def cmd_bind(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    
    if get_user_binding(user_id):
        await update.message.reply_text("æ‚¨å·²ç»‘å®šè´¦æˆ·ï¼Œå¦‚éœ€é‡æ–°ç»‘å®šè¯·å…ˆ /unbind")
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("æ ¼å¼: /bind <ç”¨æˆ·å> <å¯†ç >")
        return
    
    username = context.args[0]
    password = ' '.join(context.args[1:])
    
    token, emby_user_id = authenticate_emby(EMBY_URL, username, password)
    if not token:
        await update.message.reply_text("ç»‘å®šå¤±è´¥ï¼šEmby ç™»å½•å¤±è´¥")
        return
    
    if save_user_binding(user_id, username, password, emby_user_id):
        await update.message.reply_text(f"âœ… ç»‘å®šæˆåŠŸï¼\nç”¨æˆ·å: {username}")
    else:
        await update.message.reply_text("ç»‘å®šå¤±è´¥")

async def cmd_unbind(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    binding = get_user_binding(user_id)
    
    if not binding:
        await update.message.reply_text("æ‚¨å°šæœªç»‘å®šè´¦æˆ·")
        return
    
    if delete_user_binding(user_id):
        await update.message.reply_text(f"å·²è§£é™¤ç»‘å®š: {binding['emby_username']}")

async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    stats = get_stats()
    msg = f"""
ğŸ“Š **TGmusicbot çŠ¶æ€**

ğŸµ Emby åª’ä½“åº“: {stats.get('library_songs', 0)} é¦–æ­Œæ›²
ğŸ‘¥ ç»‘å®šç”¨æˆ·: {stats.get('users', 0)}
ğŸ“‹ åŒæ­¥æ­Œå•: {stats.get('playlists', 0)} ä¸ª
ğŸ¶ åŒæ­¥æ­Œæ›²: {stats.get('songs_synced', 0)} é¦–
ğŸ“¤ ä¸Šä¼ æ–‡ä»¶: {stats.get('uploads', 0)} ä¸ª
"""
    await update.message.reply_text(msg, parse_mode='Markdown')

async def cmd_ncm_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ£€æŸ¥ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    ncm_cookie = get_ncm_cookie()
    if not ncm_cookie:
        await update.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie\n\nè¯·åœ¨ Web ç•Œé¢ä½¿ç”¨æ‰«ç ç™»å½•ï¼Œæˆ–åœ¨ .env æ–‡ä»¶ä¸­æ·»åŠ  NCM_COOKIE")
        return
    
    await update.message.reply_text("ğŸ”„ æ­£åœ¨æ£€æŸ¥ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€...")
    
    try:
        from bot.ncm_downloader import NeteaseMusicAPI
        api = NeteaseMusicAPI(ncm_cookie)
        logged_in, info = api.check_login()
        
        # è·å–æ•°æ®åº“è®¾ç½®
        ncm_settings = get_ncm_settings()
        quality_names = {
            'standard': 'æ ‡å‡†éŸ³è´¨ (128kbps)',
            'higher': 'è¾ƒé«˜éŸ³è´¨ (192kbps)',
            'exhigh': 'æé«˜éŸ³è´¨ (320kbps)',
            'lossless': 'æ— æŸéŸ³è´¨ (FLAC)',
            'hires': 'Hi-Res'
        }
        quality_display = quality_names.get(ncm_settings['ncm_quality'], ncm_settings['ncm_quality'])
        
        if logged_in:
            msg = f"âœ… **ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€**\n\n"
            msg += f"ğŸ‘¤ æ˜µç§°: `{info.get('nickname', 'æœªçŸ¥')}`\n"
            msg += f"ğŸ†” ç”¨æˆ·ID: `{info.get('user_id', 'æœªçŸ¥')}`\n"
            msg += f"ğŸ’ VIP: {'æ˜¯' if info.get('is_vip') else 'å¦'}\n"
            msg += f"ğŸ“Š VIPç±»å‹: {info.get('vip_type', 0)}\n\n"
            msg += f"ğŸµ ä¸‹è½½éŸ³è´¨: `{quality_display}`\n"
            msg += f"ğŸ”„ è‡ªåŠ¨ä¸‹è½½: {'å·²å¯ç”¨' if ncm_settings['auto_download'] else 'æœªå¯ç”¨'}\n"
            msg += f"ğŸ“ ä¸‹è½½ç›®å½•: `{MUSIC_TARGET_DIR}`"
        else:
            msg = "âŒ ç½‘æ˜“äº‘ Cookie å·²å¤±æ•ˆ\n\nè¯·åœ¨ Web ç•Œé¢ä½¿ç”¨æ‰«ç ç™»å½•"
        
        await update.message.reply_text(msg, parse_mode='Markdown')
    except ImportError:
        await update.message.reply_text("âŒ ä¸‹è½½æ¨¡å—æœªå®‰è£…\n\nè¯·ç¡®ä¿å·²å®‰è£… pycryptodome å’Œ mutagen")
    except Exception as e:
        await update.message.reply_text(f"âŒ æ£€æŸ¥å¤±è´¥: {e}")

async def cmd_rescan(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    await update.message.reply_text("å¼€å§‹æ‰«æ Emby åª’ä½“åº“...")
    binding = get_user_binding(user_id)
    
    if binding:
        token, emby_user_id = authenticate_emby(EMBY_URL, binding['emby_username'], binding['emby_password'])
        new_data = await asyncio.to_thread(scan_emby_library, True, emby_user_id, token)
    else:
        new_data = await asyncio.to_thread(scan_emby_library, True)
    
    await update.message.reply_text(f"âœ… æ‰«æå®Œæˆï¼Œå…± {len(new_data)} é¦–æ­Œæ›²")


async def cmd_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æœç´¢æ­Œæ›²"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /search <å…³é”®è¯>\nä¾‹å¦‚: /search å‘¨æ°ä¼¦ æ™´å¤©")
        return
    
    keyword = ' '.join(context.args)
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await update.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = ('ncm', keyword.lower())
    cached = _cmd_search_cache.get(cache_key)
    if cached and time.time() - cached[0] < _cmd_search_cache_ttl:
        results = cached[1]
        logger.debug(f"ä½¿ç”¨ç¼“å­˜çš„æœç´¢ç»“æœ: {keyword}")
    else:
        await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢: {keyword}...")
        
        try:
            from bot.ncm_downloader import NeteaseMusicAPI
            api = NeteaseMusicAPI(ncm_cookie)
            results = api.search_song(keyword, limit=10)
            
            # ç¼“å­˜ç»“æœ
            _cmd_search_cache[cache_key] = (time.time(), results)
            
            # æ¸…ç†è¿‡æœŸç¼“å­˜
            if len(_cmd_search_cache) > 50:
                now = time.time()
                expired = [k for k, v in _cmd_search_cache.items() if now - v[0] > _cmd_search_cache_ttl]
                for k in expired:
                    _cmd_search_cache.pop(k, None)
        except Exception as e:
            logger.exception(f"æœç´¢å¤±è´¥: {e}")
            await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")
            return
    
    try:
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³æ­Œæ›²")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['search_results'] = results
        
        msg = f"ğŸµ *æœç´¢ç»“æœ* \\({len(results)} é¦–\\)\n\n"
        keyboard_buttons = []
        
        for i, song in enumerate(results):
            title = escape_markdown(song['title'])
            artist = escape_markdown(song['artist'])
            album = escape_markdown(song.get('album', 'æœªçŸ¥ä¸“è¾‘'))
            msg += f"`{i+1}\\.` {title} \\- {artist}\n"
            msg += f"    ğŸ“€ {album}\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {i+1}. {song['title'][:20]}", callback_data=f"dl_song_{i}")
            ])
        
        keyboard_buttons.append([InlineKeyboardButton("ğŸ“¥ å…¨éƒ¨ä¸‹è½½", callback_data="dl_song_all")])
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"æœç´¢å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


async def cmd_album(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æœç´¢å¹¶ä¸‹è½½ä¸“è¾‘"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /album <ä¸“è¾‘åæˆ–å…³é”®è¯>\nä¾‹å¦‚: /album èŒƒç‰¹è¥¿")
        return
    
    keyword = ' '.join(context.args)
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await update.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢ä¸“è¾‘: {keyword}...")
    
    try:
        from bot.ncm_downloader import NeteaseMusicAPI
        api = NeteaseMusicAPI(ncm_cookie)
        results = api.search_album(keyword, limit=5)
        
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³ä¸“è¾‘")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['album_results'] = results
        
        msg = f"ğŸ’¿ *ä¸“è¾‘æœç´¢ç»“æœ* \\({len(results)} å¼ \\)\n\n"
        keyboard_buttons = []
        
        for i, album in enumerate(results):
            album_name = escape_markdown(album['name'])
            artist = escape_markdown(album['artist'])
            msg += f"`{i+1}\\.` {album_name}\n"
            msg += f"    ğŸ¤ {artist} Â· {album['size']} é¦–æ­Œ\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {album['name'][:25]}", callback_data=f"dl_album_{i}")
            ])
        
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"æœç´¢ä¸“è¾‘å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


async def cmd_qq_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """QQéŸ³ä¹æœç´¢æ­Œæ›²"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /qs <å…³é”®è¯>\nä¾‹å¦‚: /qs å‘¨æ°ä¼¦ æ™´å¤©")
        return
    
    keyword = ' '.join(context.args)
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await update.message.reply_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookieï¼Œè¯·åœ¨ Web è®¾ç½®ä¸­é…ç½®")
        return
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = ('qq', keyword.lower())
    cached = _cmd_search_cache.get(cache_key)
    if cached and time.time() - cached[0] < _cmd_search_cache_ttl:
        results = cached[1]
        logger.debug(f"ä½¿ç”¨ç¼“å­˜çš„ QQ æœç´¢ç»“æœ: {keyword}")
    else:
        await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢ QQéŸ³ä¹: {keyword}...")
        
        try:
            from bot.ncm_downloader import QQMusicAPI
            api = QQMusicAPI(qq_cookie)
            results = api.search_song(keyword, limit=10)
            
            # ç¼“å­˜ç»“æœ
            _cmd_search_cache[cache_key] = (time.time(), results)
        except Exception as e:
            logger.exception(f"QQéŸ³ä¹æœç´¢å¤±è´¥: {e}")
            await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")
            return
    
    try:
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³æ­Œæ›²")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['qq_search_results'] = results
        
        msg = f"ğŸµ *QQéŸ³ä¹æœç´¢ç»“æœ* \\({len(results)} é¦–\\)\n\n"
        keyboard_buttons = []
        
        for i, song in enumerate(results):
            title = escape_markdown(song['title'])
            artist = escape_markdown(song['artist'])
            album = escape_markdown(song.get('album', 'æœªçŸ¥ä¸“è¾‘'))
            msg += f"`{i+1}\\.` {title} \\- {artist}\n"
            msg += f"    ğŸ“€ {album}\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {i+1}. {song['title'][:20]}", callback_data=f"qdl_song_{i}")
            ])
        
        keyboard_buttons.append([InlineKeyboardButton("ğŸ“¥ å…¨éƒ¨ä¸‹è½½", callback_data="qdl_song_all")])
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹æœç´¢å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


async def cmd_qq_album(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """QQéŸ³ä¹æœç´¢å¹¶ä¸‹è½½ä¸“è¾‘"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /qa <ä¸“è¾‘åæˆ–å…³é”®è¯>\nä¾‹å¦‚: /qa èŒƒç‰¹è¥¿")
        return
    
    keyword = ' '.join(context.args)
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await update.message.reply_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookieï¼Œè¯·åœ¨ Web è®¾ç½®ä¸­é…ç½®")
        return
    
    await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢ QQéŸ³ä¹ä¸“è¾‘: {keyword}...")
    
    try:
        from bot.ncm_downloader import QQMusicAPI
        api = QQMusicAPI(qq_cookie)
        results = api.search_album(keyword, limit=5)
        
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³ä¸“è¾‘")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['qq_album_results'] = results
        
        msg = f"ğŸ’¿ *QQéŸ³ä¹ä¸“è¾‘æœç´¢ç»“æœ* \\({len(results)} å¼ \\)\n\n"
        keyboard_buttons = []
        
        for i, album in enumerate(results):
            album_name = escape_markdown(album['name'])
            artist = escape_markdown(album['artist'])
            msg += f"`{i+1}\\.` {album_name}\n"
            msg += f"    ğŸ¤ {artist} Â· {album['size']} é¦–æ­Œ\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {album['name'][:25]}", callback_data=f"qdl_album_{i}")
            ])
        
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹æœç´¢ä¸“è¾‘å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


# ============================================================
# ä¸‹è½½ç®¡ç†å‘½ä»¤
# ============================================================

def format_file_size(size_bytes: int) -> str:
    """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"


async def cmd_download_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹ä¸‹è½½çŠ¶æ€ /ds"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    manager = get_download_manager()
    if not manager:
        await update.message.reply_text("ğŸ“Š ä¸‹è½½ç®¡ç†å™¨æœªå¯ç”¨\n\nä½¿ç”¨ä¼ ç»Ÿä¸‹è½½æ¨¡å¼")
        return
    
    stats = manager.get_stats()
    queue = stats['queue']
    today = stats['today']
    
    msg = "ğŸ“Š **ä¸‹è½½çŠ¶æ€**\n\n"
    
    # é˜Ÿåˆ—çŠ¶æ€
    msg += "**ğŸ“¥ ä¸‹è½½é˜Ÿåˆ—**\n"
    msg += f"â”œ ç­‰å¾…ä¸­: {queue['pending']}\n"
    msg += f"â”œ ä¸‹è½½ä¸­: {queue['downloading']}\n"
    msg += f"â”œ é‡è¯•ä¸­: {queue['retrying']}\n"
    msg += f"â”œ å·²å®Œæˆ: {queue['completed']}\n"
    msg += f"â”” å¤±è´¥: {queue['failed']}\n\n"
    
    # ä»Šæ—¥ç»Ÿè®¡
    msg += "**ğŸ“ˆ ä»Šæ—¥ç»Ÿè®¡**\n"
    msg += f"â”œ æˆåŠŸ: {today['total_success']} é¦–\n"
    msg += f"â”œ å¤±è´¥: {today['total_fail']} é¦–\n"
    msg += f"â”” æ€»å¤§å°: {format_file_size(today['total_size'])}\n\n"
    
    # å¹³å°åˆ†å¸ƒ
    if today['by_platform']:
        msg += "**ğŸµ å¹³å°åˆ†å¸ƒ**\n"
        for platform, data in today['by_platform'].items():
            msg += f"â”œ {platform}: {data['success']} æˆåŠŸ / {data['fail']} å¤±è´¥\n"
    
    await update.message.reply_text(msg, parse_mode='Markdown')


async def cmd_download_queue(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹ä¸‹è½½é˜Ÿåˆ— /dq"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    manager = get_download_manager()
    if not manager:
        await update.message.reply_text("ğŸ“­ ä¸‹è½½ç®¡ç†å™¨æœªå¯ç”¨")
        return
    
    queue_status = manager.get_queue_status()
    tasks = queue_status['tasks']
    
    if not tasks:
        await update.message.reply_text("ğŸ“­ ä¸‹è½½é˜Ÿåˆ—ä¸ºç©º")
        return
    
    msg = f"ğŸ“¥ **ä¸‹è½½é˜Ÿåˆ—** ({queue_status['total']} ä¸ªä»»åŠ¡)\n\n"
    
    status_emoji = {
        'pending': 'â³',
        'downloading': 'ğŸ“¥',
        'completed': 'âœ…',
        'failed': 'âŒ',
        'retrying': 'ğŸ”„',
        'cancelled': 'ğŸš«'
    }
    
    for i, task in enumerate(tasks[-10:], 1):
        emoji = status_emoji.get(task['status'], 'â“')
        name = task.get('title', 'æœªçŸ¥')[:25]
        artist = task.get('artist', '')[:15]
        msg += f"{emoji} `{name}` - {artist}\n"
    
    if len(tasks) > 10:
        msg += f"\n... è¿˜æœ‰ {len(tasks) - 10} ä¸ªä»»åŠ¡"
    
    await update.message.reply_text(msg, parse_mode='Markdown')


async def cmd_download_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹ä¸‹è½½å†å² /dh"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    manager = get_download_manager()
    if not manager:
        await update.message.reply_text("ğŸ“­ ä¸‹è½½ç®¡ç†å™¨æœªå¯ç”¨")
        return
    
    history = manager.stats.get_recent_history(20)
    
    if not history:
        await update.message.reply_text("ğŸ“­ æš‚æ— ä¸‹è½½å†å²")
        return
    
    msg = "ğŸ“œ **æœ€è¿‘ä¸‹è½½å†å²**\n\n"
    
    status_emoji = {
        'completed': 'âœ…',
        'failed': 'âŒ',
    }
    
    for item in history:
        emoji = status_emoji.get(item['status'], 'â“')
        title = (item.get('title') or 'æœªçŸ¥')[:20]
        artist = (item.get('artist') or '')[:12]
        platform = item.get('platform', '?')
        
        msg += f"{emoji} `{title}` - {artist} [{platform}]\n"
    
    await update.message.reply_text(msg, parse_mode='Markdown')


# ============================================================
# å®šæ—¶ä»»åŠ¡
# ============================================================

async def scheduled_sync_job(application):
    """å®šæ—¶åŒæ­¥æ­Œå•ä»»åŠ¡ - æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡"""
    # å¯åŠ¨åç­‰å¾… 5 åˆ†é’Ÿå†å¼€å§‹ç¬¬ä¸€æ¬¡æ£€æŸ¥ï¼ˆç­‰å¾…å…¶ä»–æœåŠ¡å°±ç»ªï¼‰
    await asyncio.sleep(300)
    
    while True:
        try:
            logger.info("å¼€å§‹å®šæ—¶æ£€æŸ¥æ­Œå•æ›´æ–°...")
            
            if not database_conn:
                await asyncio.sleep(6 * 3600)
                continue
            
            cursor = database_conn.cursor()
            # è·å–æ‰€æœ‰æ¿€æ´»çš„è®¢é˜…æ­Œå•
            try:
                cursor.execute('SELECT * FROM scheduled_playlists WHERE is_active = 1')
            except:
                # å…¼å®¹æ²¡æœ‰ is_active å­—æ®µçš„æ—§æ•°æ®åº“
                cursor.execute('SELECT * FROM scheduled_playlists')
            playlists = cursor.fetchall()
            
            for playlist in playlists:
                try:
                    playlist_url = playlist['playlist_url']
                    platform = playlist['platform']
                    old_song_ids = set(json.loads(playlist['last_song_ids'] or '[]'))
                    
                    # è·å–æœ€æ–°æ­Œæ›²åˆ—è¡¨
                    if platform == 'netease':
                        playlist_id = extract_playlist_id(playlist_url, 'netease')
                        _, songs = get_ncm_playlist_details(playlist_id)
                    elif platform == 'qq':
                        playlist_id = extract_playlist_id(playlist_url, 'qq')
                        _, songs = get_qq_playlist_details(playlist_id)
                    else:
                        continue
                    
                    if not songs:
                        continue
                    
                    current_song_ids = set(str(s.get('id', s.get('title', ''))) for s in songs)
                    new_songs = current_song_ids - old_song_ids
                    
                    if new_songs:
                        # å‘ç°æ–°æ­Œæ›²ï¼Œé€šçŸ¥ç®¡ç†å‘˜
                        new_count = len(new_songs)
                        msg = f"ğŸµ **æ­Œå•æ›´æ–°é€šçŸ¥**\n\n"
                        msg += f"ğŸ“‹ æ­Œå•: {playlist['playlist_name']}\n"
                        msg += f"ğŸ†• æ–°å¢: {new_count} é¦–æ­Œæ›²\n\n"
                        msg += "ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¸‹è½½æ–°æ­Œæ›²"
                        
                        keyboard = InlineKeyboardMarkup([
                            [InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{playlist['id']}")],
                            [InlineKeyboardButton("ğŸ”„ åŒæ­¥Emby", callback_data=f"sync_emby_{playlist['id']}")]
                        ])
                        
                        await application.bot.send_message(
                            chat_id=playlist['telegram_id'],
                            text=msg,
                            parse_mode='Markdown',
                            reply_markup=keyboard
                        )
                        
                        logger.info(f"æ­Œå• {playlist['playlist_name']} å‘ç° {new_count} é¦–æ–°æ­Œ")
                        
                except Exception as e:
                    logger.error(f"æ£€æŸ¥æ­Œå• {playlist.get('playlist_name', '?')} å¤±è´¥: {e}")
            
            # ç­‰å¾… 6 å°æ—¶åå†æ¬¡æ£€æŸ¥
            await asyncio.sleep(6 * 3600)
                    
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(60)


async def scheduled_emby_scan_job(application):
    """å®šæ—¶æ‰«æ Emby åª’ä½“åº“ä»»åŠ¡"""
    while True:
        try:
            # è·å–æ‰«æé—´éš”
            scan_interval = EMBY_SCAN_INTERVAL
            try:
                if database_conn:
                    cursor = database_conn.cursor()
                    cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                    row = cursor.fetchone()
                    if row:
                        scan_interval = int(row[0] if isinstance(row, tuple) else row['value'])
            except:
                pass
            
            if scan_interval <= 0:
                await asyncio.sleep(3600)  # ç¦ç”¨æ—¶æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡é…ç½®
                continue
            
            await asyncio.sleep(scan_interval * 3600)
            
            logger.info("å¼€å§‹å®šæ—¶æ‰«æ Emby åª’ä½“åº“...")
            
            if emby_auth['access_token']:
                scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
                trigger_emby_library_scan(emby_auth)
                logger.info("Emby åª’ä½“åº“æ‰«æå®Œæˆ")
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Emby æ‰«æä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(60)


async def daily_stats_job(application):
    """æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šä»»åŠ¡ - æ¯å¤©æ—©ä¸Š9ç‚¹å‘é€"""
    import datetime as dt
    
    while True:
        try:
            # è®¡ç®—åˆ°ä¸‹ä¸€ä¸ª9ç‚¹çš„æ—¶é—´
            now = dt.datetime.now()
            target = now.replace(hour=9, minute=0, second=0, microsecond=0)
            if now >= target:
                target += dt.timedelta(days=1)
            
            wait_seconds = (target - now).total_seconds()
            await asyncio.sleep(wait_seconds)
            
            logger.info("å‘é€æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š...")
            
            # è·å–ç»Ÿè®¡æ•°æ®
            if not database_conn:
                continue
            
            cursor = database_conn.cursor()
            
            # æ˜¨æ—¥ä¸‹è½½ç»Ÿè®¡
            yesterday = (dt.datetime.now() - dt.timedelta(days=1)).strftime('%Y-%m-%d')
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as success,
                    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
                    SUM(CASE WHEN status = 'completed' THEN file_size ELSE 0 END) as size
                FROM download_history 
                WHERE DATE(created_at) = ?
            ''', (yesterday,))
            row = cursor.fetchone()
            
            if row and row[0] > 0:
                total = row[0] or 0
                success = row[1] or 0
                failed = row[2] or 0
                size = row[3] or 0
                size_mb = size / (1024 * 1024) if size else 0
                
                # æ­Œå•åŒæ­¥ç»Ÿè®¡
                cursor.execute('''
                    SELECT COUNT(*) FROM playlist_records 
                    WHERE DATE(created_at) = ?
                ''', (yesterday,))
                playlists = cursor.fetchone()[0] or 0
                
                msg = f"ğŸ“Š **æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š** ({yesterday})\n\n"
                msg += f"**ğŸ“¥ ä¸‹è½½ç»Ÿè®¡**\n"
                msg += f"â”œ æˆåŠŸ: {success} é¦–\n"
                msg += f"â”œ å¤±è´¥: {failed} é¦–\n"
                msg += f"â”” å¤§å°: {size_mb:.1f} MB\n\n"
                msg += f"**ğŸ“‹ æ­Œå•åŒæ­¥**\n"
                msg += f"â”” åŒæ­¥: {playlists} æ¬¡\n"
                
                if ADMIN_USER_ID:
                    await application.bot.send_message(
                        chat_id=ADMIN_USER_ID,
                        text=msg,
                        parse_mode='Markdown'
                    )
                    logger.info("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šå·²å‘é€")
            
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"æ¯æ—¥ç»Ÿè®¡ä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(3600)


async def cookie_check_job(application):
    """Cookie è¿‡æœŸæ£€æŸ¥ä»»åŠ¡ - æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡"""
    # å¯åŠ¨åç­‰å¾… 1 åˆ†é’Ÿå†æ‰§è¡Œç¬¬ä¸€æ¬¡æ£€æŸ¥
    await asyncio.sleep(60)
    
    while True:
        try:
            logger.info("æ£€æŸ¥ Cookie çŠ¶æ€...")
            
            notifications = []
            
            # æ£€æŸ¥ç½‘æ˜“äº‘ Cookie
            ncm_cookie = get_ncm_cookie()
            if ncm_cookie:
                try:
                    from bot.ncm_downloader import NeteaseMusicAPI
                    api = NeteaseMusicAPI(ncm_cookie)
                    logged_in, info = api.check_login()
                    if not logged_in:
                        notifications.append("ğŸ”´ **ç½‘æ˜“äº‘ Cookie å·²å¤±æ•ˆ**\nè¯·é‡æ–°ç™»å½•è·å– Cookie")
                    else:
                        logger.info(f"ç½‘æ˜“äº‘ Cookie æœ‰æ•ˆ: {info.get('nickname', 'æœªçŸ¥')}")
                except Exception as e:
                    logger.error(f"æ£€æŸ¥ç½‘æ˜“äº‘ Cookie å¤±è´¥: {e}")
            
            # æ£€æŸ¥ QQ Cookie
            qq_cookie = get_qq_cookie()
            if qq_cookie:
                try:
                    from bot.ncm_downloader import QQMusicAPI
                    api = QQMusicAPI(qq_cookie)
                    logged_in, info = api.check_login()
                    if not logged_in:
                        notifications.append("ğŸ”´ **QQéŸ³ä¹ Cookie å·²å¤±æ•ˆ**\nè¯·é‡æ–°ç™»å½•è·å– Cookie")
                    else:
                        logger.info(f"QQéŸ³ä¹ Cookie æœ‰æ•ˆ: {info.get('nickname', 'æœªçŸ¥')}")
                except Exception as e:
                    logger.error(f"æ£€æŸ¥ QQ Cookie å¤±è´¥: {e}")
            
            # å‘é€é€šçŸ¥
            if notifications and ADMIN_USER_ID:
                msg = "âš ï¸ **Cookie çŠ¶æ€å‘Šè­¦**\n\n" + "\n\n".join(notifications)
                msg += "\n\nğŸ’¡ è¯·åœ¨ Web ç®¡ç†ç•Œé¢é‡æ–°é…ç½® Cookie"
                
                await application.bot.send_message(
                    chat_id=ADMIN_USER_ID,
                    text=msg,
                    parse_mode='Markdown'
                )
                logger.warning("å·²å‘é€ Cookie è¿‡æœŸé€šçŸ¥")
            
            # ç­‰å¾… 6 å°æ—¶åå†æ¬¡æ£€æŸ¥
            await asyncio.sleep(6 * 3600)
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Cookie æ£€æŸ¥ä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(3600)


# ============================================================
# Inline æ¨¡å¼æœç´¢ï¼ˆä»»æ„èŠå¤©ä¸­ @bot æ­Œå æœç´¢ï¼‰
# ============================================================

# æœç´¢ç»“æœç¼“å­˜
_search_cache = {}
_cache_ttl = 300  # 5åˆ†é’Ÿ

async def handle_inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† Inline æŸ¥è¯¢ - ä»»æ„èŠå¤©ä¸­ @bot æ­Œå æœç´¢"""
    query = update.inline_query
    search_text = query.query.strip()
    
    if not search_text or len(search_text) < 2:
        return
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = search_text.lower()
    if cache_key in _search_cache:
        cached_time, cached_results = _search_cache[cache_key]
        if time.time() - cached_time < _cache_ttl:
            await query.answer(cached_results, cache_time=60)
            return
    
    results = []
    
    try:
        # æœç´¢ç½‘æ˜“äº‘
        ncm_cookie = get_ncm_cookie()
        if ncm_cookie:
            from bot.ncm_downloader import NeteaseMusicAPI
            api = NeteaseMusicAPI(ncm_cookie)
            songs = api.search_songs(search_text, limit=5)
            
            for i, song in enumerate(songs):
                song_id = song.get('id', '')
                title = song.get('title', 'æœªçŸ¥')
                artist = song.get('artist', 'æœªçŸ¥')
                album = song.get('album', '')
                
                # åˆ›å»ºç»“æœ
                results.append(
                    InlineQueryResultArticle(
                        id=f"ncm_{song_id}",
                        title=f"ğŸ”´ {title}",
                        description=f"{artist} Â· {album}" if album else artist,
                        input_message_content=InputTextMessageContent(
                            message_text=f"ğŸµ *{title}*\nğŸ‘¤ {artist}\nğŸ’¿ {album}\n\nğŸ”— ç½‘æ˜“äº‘: https://music.163.com/song?id={song_id}",
                            parse_mode='Markdown'
                        ),
                        thumbnail_url=song.get('cover', '')
                    )
                )
        
        # æœç´¢ QQ éŸ³ä¹
        qq_cookie = get_qq_cookie()
        if qq_cookie:
            from bot.ncm_downloader import QQMusicAPI
            api = QQMusicAPI(qq_cookie)
            songs = api.search_songs(search_text, limit=5)
            
            for i, song in enumerate(songs):
                song_id = song.get('id', '')
                mid = song.get('mid', '')
                title = song.get('title', 'æœªçŸ¥')
                artist = song.get('artist', 'æœªçŸ¥')
                album = song.get('album', '')
                
                results.append(
                    InlineQueryResultArticle(
                        id=f"qq_{song_id}",
                        title=f"ğŸŸ¢ {title}",
                        description=f"{artist} Â· {album}" if album else artist,
                        input_message_content=InputTextMessageContent(
                            message_text=f"ğŸµ *{title}*\nğŸ‘¤ {artist}\nğŸ’¿ {album}\n\nğŸ”— QQéŸ³ä¹: https://y.qq.com/n/ryqq/songDetail/{mid}",
                            parse_mode='Markdown'
                        ),
                        thumbnail_url=song.get('cover', '')
                    )
                )
        
        # ç¼“å­˜ç»“æœ
        _search_cache[cache_key] = (time.time(), results)
        
        # æ¸…ç†è¿‡æœŸç¼“å­˜
        if len(_search_cache) > 100:
            now = time.time()
            _search_cache.clear()
        
    except Exception as e:
        logger.error(f"Inline æœç´¢å¤±è´¥: {e}")
    
    await query.answer(results, cache_time=60)


async def cmd_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹å®šæ—¶åŒæ­¥æ­Œå•"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    playlists = get_scheduled_playlists(user_id)
    
    if not playlists:
        await update.message.reply_text(
            "ğŸ“… **å®šæ—¶åŒæ­¥æ­Œå•**\n\n"
            "æš‚æ— è®¢é˜…çš„æ­Œå•\n\n"
            "ğŸ’¡ åŒæ­¥æ­Œå•åä¼šè‡ªåŠ¨æ·»åŠ åˆ°å®šæ—¶åŒæ­¥åˆ—è¡¨",
            parse_mode='Markdown'
        )
        return
    
    msg = "ğŸ“… **å®šæ—¶åŒæ­¥æ­Œå•**\n\n"
    for i, p in enumerate(playlists, 1):
        platform_icon = "ğŸ”´" if p['platform'] == 'netease' else "ğŸŸ¢"
        last_sync = p['last_sync_at'][:16] if p['last_sync_at'] else "æœªåŒæ­¥"
        msg += f"`{i}.` {platform_icon} {p['playlist_name']}\n"
        msg += f"    ğŸ“Š {len(p['last_song_ids'])} é¦– Â· æœ€ååŒæ­¥: {last_sync}\n\n"
    
    msg += f"ğŸ’¡ ä½¿ç”¨ `/unschedule <åºå·>` å–æ¶ˆè®¢é˜…"
    await update.message.reply_text(msg, parse_mode='Markdown')


async def cmd_scaninterval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """è®¾ç½® Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æé—´éš”"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    # è·å–å½“å‰è®¾ç½®
    current_interval = EMBY_SCAN_INTERVAL
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
            row = cursor.fetchone()
            if row:
                current_interval = int(row[0] if isinstance(row, tuple) else row['value'])
    except:
        pass
    
    if not context.args:
        status = f"æ¯ {current_interval} å°æ—¶" if current_interval > 0 else "å·²ç¦ç”¨"
        await update.message.reply_text(
            f"ğŸ”„ **Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æ**\n\n"
            f"å½“å‰çŠ¶æ€: {status}\n\n"
            f"ç”¨æ³•: `/scaninterval <å°æ—¶>`\n"
            f"ç¤ºä¾‹:\n"
            f"â€¢ `/scaninterval 6` - æ¯ 6 å°æ—¶æ‰«æ\n"
            f"â€¢ `/scaninterval 0` - ç¦ç”¨è‡ªåŠ¨æ‰«æ\n\n"
            f"ğŸ’¡ ä¹Ÿå¯åœ¨ Web è®¾ç½®é¡µé¢é…ç½®",
            parse_mode='Markdown'
        )
        return
    
    try:
        interval = int(context.args[0])
        if interval < 0:
            await update.message.reply_text("âŒ é—´éš”ä¸èƒ½ä¸ºè´Ÿæ•°")
            return
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO bot_settings (key, value, updated_at)
                VALUES (?, ?, ?)
            ''', ('emby_scan_interval', str(interval), datetime.now().isoformat()))
            database_conn.commit()
        
        if interval == 0:
            await update.message.reply_text("âœ… å·²ç¦ç”¨ Emby è‡ªåŠ¨æ‰«æ")
        else:
            await update.message.reply_text(f"âœ… å·²è®¾ç½® Emby è‡ªåŠ¨æ‰«æé—´éš”ä¸º {interval} å°æ—¶")
            
    except ValueError:
        await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")


async def cmd_unschedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å–æ¶ˆå®šæ—¶åŒæ­¥æ­Œå•"""
    user_id = str(update.effective_user.id)
    if user_id != ADMIN_USER_ID:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /unschedule <åºå·>\nä¾‹å¦‚: /unschedule 1")
        return
    
    try:
        index = int(context.args[0]) - 1
        playlists = get_scheduled_playlists(user_id)
        
        if index < 0 or index >= len(playlists):
            await update.message.reply_text("âŒ åºå·æ— æ•ˆ")
            return
        
        playlist = playlists[index]
        if delete_scheduled_playlist(playlist['id'], user_id):
            await update.message.reply_text(f"âœ… å·²å–æ¶ˆè®¢é˜…: {playlist['playlist_name']}")
        else:
            await update.message.reply_text("âŒ å–æ¶ˆå¤±è´¥")
    except ValueError:
        await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„åºå·")


async def handle_sync_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†å®šæ—¶åŒæ­¥ç›¸å…³çš„å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        await query.edit_message_text("æ— æƒæ‰§è¡Œæ­¤æ“ä½œ")
        return
    
    data = query.data
    
    if data.startswith("sync_dl_"):
        # ä¸‹è½½æ–°æ­Œ
        playlist_id = int(data.replace("sync_dl_", ""))
        playlists = get_scheduled_playlists(user_id)
        playlist = next((p for p in playlists if p['id'] == playlist_id), None)
        
        if not playlist:
            await query.edit_message_text("âŒ æ­Œå•ä¸å­˜åœ¨")
            return
        
        await query.edit_message_text("ğŸ“¥ æ­£åœ¨è·å–æ–°æ­Œæ›²...")
        
        # è·å–æ­Œå•å¹¶æ‰¾å‡ºæ–°æ­Œæ›²
        try:
            platform = playlist['platform']
            playlist_url = playlist['playlist_url']
            old_song_ids = set(playlist['last_song_ids'])
            
            if platform == 'netease':
                playlist_id_str = extract_playlist_id(playlist_url, 'netease')
                _, songs = get_ncm_playlist_details(playlist_id_str)
            elif platform == 'qq':
                playlist_id_str = extract_playlist_id(playlist_url, 'qq')
                _, songs = get_qq_playlist_details(playlist_id_str)
            else:
                await query.message.reply_text("âŒ ä¸æ”¯æŒçš„å¹³å°")
                return
            
            new_songs = [s for s in songs if str(s.get('id', s.get('title', ''))) not in old_song_ids]
            
            if not new_songs:
                await query.message.reply_text("æ²¡æœ‰æ–°æ­Œæ›²éœ€è¦ä¸‹è½½")
                return
            
            # å¼€å§‹ä¸‹è½½
            ncm_cookie = get_ncm_cookie()
            if not ncm_cookie:
                await query.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
                return
            
            from bot.ncm_downloader import MusicAutoDownloader
            ncm_settings = get_ncm_settings()
            download_quality = ncm_settings.get('ncm_quality', 'exhigh')
            download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
            
            download_path = Path(download_dir)
            download_path.mkdir(parents=True, exist_ok=True)
            
            # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
            qq_cookie = get_qq_cookie()
            
            downloader = MusicAutoDownloader(
                ncm_cookie, qq_cookie, str(download_path),
                proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
            )
            
            progress_msg = await query.message.reply_text(
                make_progress_message("ğŸ“¥ ä¸‹è½½æ–°æ­Œæ›²", 0, len(new_songs), "å‡†å¤‡å¼€å§‹...")
            )
            main_loop = asyncio.get_running_loop()
            last_update_time = [0]
            
            async def update_progress(current, total, song):
                import time as time_module
                now = time_module.time()
                if now - last_update_time[0] < 1.5:
                    return
                last_update_time[0] = now
                try:
                    song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                    await progress_msg.edit_text(
                        make_progress_message("ğŸ“¥ ä¸‹è½½æ–°æ­Œæ›²", current, total, song_name),
                        parse_mode='Markdown'
                    )
                except:
                    pass
            
            def sync_progress_callback(current, total, song, status=None):
                main_loop.call_soon_threadsafe(
                    lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
                )
            
            success_results, failed = await asyncio.to_thread(
                downloader.download_missing_songs,
                new_songs,
                download_quality,
                sync_progress_callback
            )
            
            # æå–æ–‡ä»¶åˆ—è¡¨
            success_files = [r['file'] for r in success_results]
            
            try:
                await progress_msg.delete()
            except:
                pass
            
            # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰
            save_download_record_v2(success_results, failed, download_quality, user_id)
            
            # æ›´æ–°æ­Œæ›²åˆ—è¡¨
            current_song_ids = [str(s.get('id', s.get('title', ''))) for s in songs]
            update_scheduled_playlist_songs(playlist['id'], current_song_ids)
            
            # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
            ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
            qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
            platform_info = f"\nâ€¢ ç½‘æ˜“äº‘: {ncm_count}, QQéŸ³ä¹: {qq_count}" if qq_count > 0 else ""
            
            await query.message.reply_text(
                f"âœ… ä¸‹è½½å®Œæˆ\næˆåŠŸ: {len(success_files)} é¦–{platform_info}\nå¤±è´¥: {len(failed)} é¦–"
            )
            
        except Exception as e:
            logger.exception(f"ä¸‹è½½æ–°æ­Œæ›²å¤±è´¥: {e}")
            await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")
    
    elif data.startswith("sync_emby_"):
        # åŒæ­¥åˆ° Emby
        playlist_id = int(data.replace("sync_emby_", ""))
        playlists = get_scheduled_playlists(user_id)
        playlist = next((p for p in playlists if p['id'] == playlist_id), None)
        
        if not playlist:
            await query.edit_message_text("âŒ æ­Œå•ä¸å­˜åœ¨")
            return
        
        # é‡æ–°åŒæ­¥æ•´ä¸ªæ­Œå•åˆ° Emby
        await query.edit_message_text("ğŸ”„ æ­£åœ¨åŒæ­¥åˆ° Emby...")
        
        # è§¦å‘æ­Œå•åŒæ­¥
        context.user_data['sync_playlist_url'] = playlist['playlist_url']
        context.user_data['sync_from_scheduled'] = True
        
        # æ¨¡æ‹Ÿå‘é€æ­Œå•é“¾æ¥
        await query.message.reply_text(f"è¯·ç¨å€™ï¼Œæ­£åœ¨å¤„ç†æ­Œå•...")


async def cmd_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç”³è¯·åŒæ­¥æ­Œå• - ç”¨æˆ·æäº¤æ­Œå•é“¾æ¥ï¼Œç®¡ç†å‘˜å®¡æ ¸åä¸‹è½½ç¼ºå¤±æ­Œæ›²"""
    user_id = str(update.effective_user.id)
    
    # æ£€æŸ¥ç”³è¯·æƒé™
    if not check_user_permission(user_id, 'request'):
        await update.message.reply_text("âŒ ä½ æ²¡æœ‰ç”³è¯·æƒé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return
    
    args = ' '.join(context.args) if context.args else ''
    
    if not args:
        await update.message.reply_text(
            "ğŸ“ **ç”³è¯·åŒæ­¥æ­Œå•**\n\n"
            "å‘é€æ­Œå•é“¾æ¥ç”³è¯·åŒæ­¥åˆ°éŸ³ä¹åº“ï¼Œç®¡ç†å‘˜å®¡æ ¸é€šè¿‡åä¼šè‡ªåŠ¨ä¸‹è½½ç¼ºå¤±çš„æ­Œæ›²ã€‚\n\n"
            "**ç”¨æ³•ï¼š**\n"
            "`/request <æ­Œå•é“¾æ¥>`\n\n"
            "**æ”¯æŒå¹³å°ï¼š**\n"
            "â€¢ ç½‘æ˜“äº‘éŸ³ä¹\n"
            "â€¢ QQéŸ³ä¹\n"
            "â€¢ Spotify\n\n"
            "**ç¤ºä¾‹ï¼š**\n"
            "`/request https://music.163.com/playlist?id=123456`\n"
            "`/request https://y.qq.com/n/ryqq/playlist/123456`\n"
            "`/request https://open.spotify.com/playlist/xxxxx`",
            parse_mode='Markdown'
        )
        return
    
    # è§£ææ­Œå•é“¾æ¥
    import re
    playlist_url = args.strip()
    
    # æ£€æµ‹å¹³å°
    platform = None
    playlist_id = None
    playlist_name = "æœªçŸ¥æ­Œå•"
    song_count = 0
    
    if 'music.163.com' in playlist_url or 'y.music.163.com' in playlist_url:
        platform = 'netease'
        playlist_id = extract_playlist_id(playlist_url, 'netease')
    elif 'y.qq.com' in playlist_url or 'qq.com' in playlist_url:
        platform = 'qq'
        playlist_id = extract_playlist_id(playlist_url, 'qq')
    elif 'spotify.com' in playlist_url or 'spotify:' in playlist_url:
        platform = 'spotify'
        playlist_id = extract_playlist_id(playlist_url, 'spotify')
    
    if not platform or not playlist_id:
        await update.message.reply_text(
            "âŒ æ— æ³•è¯†åˆ«æ­Œå•é“¾æ¥\n\n"
            "æ”¯æŒçš„å¹³å°ï¼šç½‘æ˜“äº‘éŸ³ä¹ã€QQéŸ³ä¹ã€Spotify"
        )
        return
    
    # è·å–æ­Œå•ä¿¡æ¯
    try:
        if platform == 'netease':
            playlist_name, songs = get_ncm_playlist_details(playlist_id)
        elif platform == 'spotify':
            playlist_name, songs = get_spotify_playlist_details(playlist_id)
        else:
            playlist_name, songs = get_qq_playlist_details(playlist_id)
        song_count = len(songs) if songs else 0
    except Exception as e:
        logger.warning(f"è·å–æ­Œå•ä¿¡æ¯å¤±è´¥: {e}")
        playlist_name = f"æ­Œå• {playlist_id}"
    
    # æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒç”³è¯·
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            SELECT id, status FROM playlist_requests 
            WHERE telegram_id = ? AND playlist_url = ? AND status = 'pending'
        ''', (user_id, playlist_url))
        existing = cursor.fetchone()
        if existing:
            await update.message.reply_text("â³ ä½ å·²ç»ç”³è¯·è¿‡è¿™ä¸ªæ­Œå•ï¼Œè¯·ç­‰å¾…ç®¡ç†å‘˜å®¡æ ¸")
            return
    except:
        pass
    
    # åˆ›å»ºç”³è¯·è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS playlist_requests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id TEXT NOT NULL,
                playlist_url TEXT NOT NULL,
                playlist_name TEXT,
                platform TEXT,
                song_count INTEGER DEFAULT 0,
                status TEXT DEFAULT 'pending',
                admin_note TEXT,
                download_count INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                processed_at TIMESTAMP
            )
        ''')
        database_conn.commit()
    except:
        pass
    
    # æäº¤ç”³è¯·
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            INSERT INTO playlist_requests (telegram_id, playlist_url, playlist_name, platform, song_count)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, playlist_url, playlist_name, platform, song_count))
        database_conn.commit()
        request_id = cursor.lastrowid
        
        platform_name = "ç½‘æ˜“äº‘éŸ³ä¹" if platform == 'netease' else "QQéŸ³ä¹"
        
        await update.message.reply_text(
            f"âœ… **ç”³è¯·å·²æäº¤**\n\n"
            f"ğŸ“‹ æ­Œå•: {playlist_name}\n"
            f"ğŸµ å¹³å°: {platform_name}\n"
            f"ğŸ”¢ æ­Œæ›²æ•°: {song_count}\n\n"
            f"ç®¡ç†å‘˜å®¡æ ¸é€šè¿‡åä¼šè‡ªåŠ¨ä¸‹è½½ç¼ºå¤±çš„æ­Œæ›²",
            parse_mode='Markdown'
        )
        
        # é€šçŸ¥ç®¡ç†å‘˜
        if ADMIN_USER_ID:
            user = update.effective_user
            user_info = f"@{user.username}" if user.username else f"{user.first_name} ({user_id})"
            
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("âœ… æ‰¹å‡†å¹¶ä¸‹è½½", callback_data=f"req_approve_{request_id}"),
                    InlineKeyboardButton("âŒ æ‹’ç»", callback_data=f"req_reject_{request_id}")
                ],
                [
                    InlineKeyboardButton("ğŸ‘ï¸ é¢„è§ˆæ­Œå•", callback_data=f"req_preview_{request_id}")
                ]
            ])
            
            admin_msg = (
                f"ğŸ“ **æ–°æ­Œå•åŒæ­¥ç”³è¯·**\n\n"
                f"ğŸ‘¤ ç”¨æˆ·: {user_info}\n"
                f"ğŸ“‹ æ­Œå•: {playlist_name}\n"
                f"ğŸµ å¹³å°: {platform_name}\n"
                f"ğŸ”¢ æ­Œæ›²æ•°: {song_count}\n"
                f"ğŸ”— é“¾æ¥: {playlist_url}"
            )
            
            try:
                await context.bot.send_message(
                    chat_id=ADMIN_USER_ID,
                    text=admin_msg,
                    parse_mode='Markdown',
                    reply_markup=keyboard
                )
            except Exception as e:
                logger.error(f"é€šçŸ¥ç®¡ç†å‘˜å¤±è´¥: {e}")
                
    except Exception as e:
        logger.error(f"æäº¤æ­Œå•ç”³è¯·å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æäº¤å¤±è´¥: {e}")


async def cmd_myrequests(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹æˆ‘çš„æ­Œå•ç”³è¯·"""
    user_id = str(update.effective_user.id)
    
    try:
        if database_conn:
            cursor = database_conn.cursor()
            
            # å…ˆæŸ¥æ­Œå•ç”³è¯·
            cursor.execute('''
                SELECT * FROM playlist_requests 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC 
                LIMIT 10
            ''', (user_id,))
            rows = cursor.fetchall()
            
            if not rows:
                await update.message.reply_text("ğŸ“ ä½ è¿˜æ²¡æœ‰æäº¤è¿‡ç”³è¯·")
                return
            
            msg = "ğŸ“ **æˆ‘çš„æ­Œå•ç”³è¯·**\n\n"
            for row in rows:
                status_emoji = {'pending': 'â³', 'approved': 'âœ…', 'rejected': 'âŒ'}.get(row['status'], 'â“')
                platform_name = "ç½‘æ˜“äº‘" if row['platform'] == 'netease' else "QQéŸ³ä¹"
                msg += f"{status_emoji} {row['playlist_name']}\n"
                msg += f"   ğŸµ {platform_name} Â· {row['song_count']} é¦–\n"
                msg += f"   çŠ¶æ€: {row['status']}"
                if row['download_count']:
                    msg += f" (å·²ä¸‹è½½ {row['download_count']} é¦–)"
                if row['admin_note']:
                    msg += f"\n   å¤‡æ³¨: {row['admin_note']}"
                msg += "\n\n"
            
            await update.message.reply_text(msg, parse_mode='Markdown')
    except Exception as e:
        await update.message.reply_text(f"âŒ æŸ¥è¯¢å¤±è´¥: {e}")


async def handle_request_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æ­Œå•ç”³è¯·å®¡æ ¸å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        await query.answer("ä»…ç®¡ç†å‘˜å¯æ“ä½œ", show_alert=True)
        return
    
    data = query.data
    
    if data.startswith("req_approve_"):
        request_id = int(data.replace("req_approve_", ""))
        await process_playlist_request(query, context, request_id, 'approved')
        
    elif data.startswith("req_reject_"):
        request_id = int(data.replace("req_reject_", ""))
        await process_playlist_request(query, context, request_id, 'rejected')
    
    elif data.startswith("req_preview_"):
        request_id = int(data.replace("req_preview_", ""))
        await preview_playlist_request(query, context, request_id)


async def preview_playlist_request(query, context, request_id: int):
    """é¢„è§ˆæ­Œå•å†…å®¹"""
    try:
        cursor = database_conn.cursor()
        cursor.execute('SELECT * FROM playlist_requests WHERE id = ?', (request_id,))
        row = cursor.fetchone()
        
        if not row:
            await query.message.reply_text("âŒ ç”³è¯·ä¸å­˜åœ¨")
            return
        
        playlist_url = row['playlist_url']
        platform = row['platform']
        
        # è·å–æ­Œå•è¯¦æƒ…
        if platform == 'netease':
            playlist_id = extract_playlist_id(playlist_url, 'netease')
            playlist_name, songs = get_ncm_playlist_details(playlist_id)
        else:
            playlist_id = extract_playlist_id(playlist_url, 'qq')
            playlist_name, songs = get_qq_playlist_details(playlist_id)
        
        if not songs:
            await query.message.reply_text("âŒ è·å–æ­Œå•å†…å®¹å¤±è´¥")
            return
        
        # æ˜¾ç¤ºå‰10é¦–
        msg = f"ğŸ“‹ **{playlist_name}** ({len(songs)} é¦–)\n\n"
        for i, song in enumerate(songs[:10]):
            msg += f"{i+1}. {song.get('title', 'æœªçŸ¥')} - {song.get('artist', 'æœªçŸ¥')}\n"
        
        if len(songs) > 10:
            msg += f"\n... è¿˜æœ‰ {len(songs) - 10} é¦–"
        
        await query.message.reply_text(msg, parse_mode='Markdown')
        
    except Exception as e:
        await query.message.reply_text(f"âŒ é¢„è§ˆå¤±è´¥: {e}")


async def process_playlist_request(query, context, request_id: int, action: str):
    """å¤„ç†æ­Œå•ç”³è¯·ï¼ˆæ‰¹å‡†/æ‹’ç»ï¼‰"""
    try:
        cursor = database_conn.cursor()
        cursor.execute('SELECT * FROM playlist_requests WHERE id = ?', (request_id,))
        row = cursor.fetchone()
        
        if not row:
            await query.message.reply_text("âŒ ç”³è¯·ä¸å­˜åœ¨")
            return
        
        requester_id = row['telegram_id']
        playlist_url = row['playlist_url']
        playlist_name = row['playlist_name']
        platform = row['platform']
        
        if action == 'rejected':
            # æ‹’ç»ç”³è¯·
            cursor.execute('''
                UPDATE playlist_requests 
                SET status = 'rejected', processed_at = CURRENT_TIMESTAMP 
                WHERE id = ?
            ''', (request_id,))
            database_conn.commit()
            
            await query.edit_message_text(
                query.message.text + "\n\nâŒ **å·²æ‹’ç»**",
                parse_mode='Markdown'
            )
            
            # é€šçŸ¥ç”¨æˆ·
            try:
                await context.bot.send_message(
                    chat_id=requester_id,
                    text=f"âŒ ä½ çš„æ­Œå•ç”³è¯·è¢«æ‹’ç»\n\nğŸ“‹ æ­Œå•: {playlist_name}"
                )
            except:
                pass
            return
        
        # æ‰¹å‡†å¹¶ä¸‹è½½
        await query.edit_message_text(
            query.message.text + "\n\nâ³ **æ­£åœ¨åŒ¹é…å¹¶ä¸‹è½½ç¼ºå¤±æ­Œæ›²...**",
            parse_mode='Markdown'
        )
        
        # è·å–æ­Œå•å†…å®¹
        if platform == 'netease':
            playlist_id = extract_playlist_id(playlist_url, 'netease')
            _, songs = get_ncm_playlist_details(playlist_id)
        else:
            playlist_id = extract_playlist_id(playlist_url, 'qq')
            _, songs = get_qq_playlist_details(playlist_id)
        
        if not songs:
            await query.message.reply_text("âŒ è·å–æ­Œå•å†…å®¹å¤±è´¥")
            return
        
        # åŒ¹é… Emby åª’ä½“åº“ï¼Œæ‰¾å‡ºç¼ºå¤±æ­Œæ›²
        admin_binding = get_user_binding(ADMIN_USER_ID)
        if not admin_binding:
            await query.message.reply_text("âŒ ç®¡ç†å‘˜æœªç»‘å®š Emby")
            return
        
        # è·å–åª’ä½“åº“
        library_songs = load_library_cache()
        if not library_songs:
            await query.message.reply_text("âŒ åª’ä½“åº“ç¼“å­˜ä¸ºç©ºï¼Œè¯·å…ˆ /rescan")
            return
        
        # åŒ¹é…
        missing_songs = []
        for song in songs:
            matched = False
            song_title = song.get('title', '')
            song_artist = song.get('artist', '')
            
            for lib_song in library_songs:
                lib_title = lib_song.get('Name', '')
                lib_artist = lib_song.get('Artists', [''])[0] if lib_song.get('Artists') else ''
                
                # æ¨¡ç³ŠåŒ¹é…
                title_ratio = fuzz.ratio(song_title.lower(), lib_title.lower())
                if title_ratio > 85:
                    artist_ratio = fuzz.ratio(song_artist.lower(), lib_artist.lower())
                    if artist_ratio > 70 or not song_artist:
                        matched = True
                        break
            
            if not matched:
                missing_songs.append(song)
        
        if not missing_songs:
            # æ›´æ–°çŠ¶æ€
            cursor.execute('''
                UPDATE playlist_requests 
                SET status = 'approved', download_count = 0, processed_at = CURRENT_TIMESTAMP 
                WHERE id = ?
            ''', (request_id,))
            database_conn.commit()
            
            await query.edit_message_text(
                query.message.text.replace("â³ **æ­£åœ¨åŒ¹é…å¹¶ä¸‹è½½ç¼ºå¤±æ­Œæ›²...**", "") +
                "\n\nâœ… **å·²æ‰¹å‡†** - æ‰€æœ‰æ­Œæ›²å·²åœ¨åª’ä½“åº“ä¸­",
                parse_mode='Markdown'
            )
            
            try:
                await context.bot.send_message(
                    chat_id=requester_id,
                    text=f"âœ… ä½ çš„æ­Œå•ç”³è¯·å·²é€šè¿‡ï¼\n\nğŸ“‹ æ­Œå•: {playlist_name}\nğŸµ æ‰€æœ‰æ­Œæ›²å·²åœ¨éŸ³ä¹åº“ä¸­"
                )
            except:
                pass
            return
        
        # ä¸‹è½½ç¼ºå¤±æ­Œæ›²
        ncm_cookie = get_ncm_cookie()
        if not ncm_cookie:
            await query.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
            return
        
        from bot.ncm_downloader import MusicAutoDownloader
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        
        # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
        qq_cookie = get_qq_cookie()
        
        downloader = MusicAutoDownloader(
            ncm_cookie, qq_cookie, download_dir,
            proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
        )
        
        progress_msg = await query.message.reply_text(
            f"ğŸ“¥ æ­£åœ¨ä¸‹è½½ {len(missing_songs)} é¦–ç¼ºå¤±æ­Œæ›²..."
        )
        
        main_loop = asyncio.get_running_loop()
        last_update_time = [0]
        
        async def update_progress(current, total, song):
            import time as time_module
            now = time_module.time()
            if now - last_update_time[0] < 2:
                return
            last_update_time[0] = now
            try:
                await progress_msg.edit_text(
                    f"ğŸ“¥ ä¸‹è½½ä¸­ ({current}/{total})\nğŸµ {song.get('title', '')} - {song.get('artist', '')}"
                )
            except:
                pass
        
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        success_results, failed_songs = await asyncio.to_thread(
            downloader.download_missing_songs,
            missing_songs,
            download_quality,
            sync_progress_callback
        )
        
        # æå–æ–‡ä»¶åˆ—è¡¨
        success_files = [r['file'] for r in success_results]
        
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰
        save_download_record_v2(success_results, failed_songs, download_quality, ADMIN_USER_ID)
        
        # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        platform_info = f"\n   â€¢ ç½‘æ˜“äº‘: {ncm_count}, QQéŸ³ä¹: {qq_count}" if qq_count > 0 else ""
        
        # æ›´æ–°ç”³è¯·çŠ¶æ€
        cursor.execute('''
            UPDATE playlist_requests 
            SET status = 'approved', download_count = ?, processed_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        ''', (len(success_files), request_id))
        database_conn.commit()
        
        await query.edit_message_text(
            query.message.text.replace("â³ **æ­£åœ¨åŒ¹é…å¹¶ä¸‹è½½ç¼ºå¤±æ­Œæ›²...**", "") +
            f"\n\nâœ… **å·²æ‰¹å‡†å¹¶ä¸‹è½½**\n"
            f"ğŸ“Š ç¼ºå¤±: {len(missing_songs)} é¦–\n"
            f"âœ… æˆåŠŸ: {len(success_files)} é¦–{platform_info}\n"
            f"âŒ å¤±è´¥: {len(failed_songs)} é¦–",
            parse_mode='Markdown'
        )
        
        # é€šçŸ¥ç”¨æˆ·
        try:
            await context.bot.send_message(
                chat_id=requester_id,
                text=f"âœ… ä½ çš„æ­Œå•ç”³è¯·å·²é€šè¿‡ï¼\n\n"
                     f"ğŸ“‹ æ­Œå•: {playlist_name}\n"
                     f"ğŸ“¥ å·²ä¸‹è½½ {len(success_files)} é¦–æ–°æ­Œæ›²åˆ°éŸ³ä¹åº“"
            )
        except:
            pass
        
        # è§¦å‘ Emby æ‰«åº“
        if success_files:
            try:
                user_access_token, user_id_emby = authenticate_emby(
                    EMBY_URL, admin_binding['emby_username'], decrypt_password(admin_binding['emby_password'])
                )
                if user_access_token:
                    user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                    trigger_emby_library_scan(user_auth)
            except:
                pass
                
    except Exception as e:
        logger.exception(f"å¤„ç†æ­Œå•ç”³è¯·å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ å¤„ç†å¤±è´¥: {e}")


async def handle_preview_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†ç½‘æ˜“äº‘è¯•å¬å›è°ƒ"""
    query = update.callback_query
    await query.answer("ğŸ§ æ­£åœ¨è·å–è¯•å¬...")
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        return
    
    data = query.data
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await query.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    try:
        idx = int(data.replace("preview_song_", ""))
        search_results = context.user_data.get('search_results', [])
        
        if not search_results or idx >= len(search_results):
            await query.message.reply_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
            return
        
        song = search_results[idx]
        song_id = song['source_id']
        
        from bot.ncm_downloader import NeteaseMusicAPI
        api = NeteaseMusicAPI(ncm_cookie)
        
        # è·å–æ­Œæ›²URLï¼ˆä½¿ç”¨æ ‡å‡†éŸ³è´¨ä»¥åŠ å¿«é€Ÿåº¦ï¼‰
        song_urls = api.get_song_url([song_id], 'standard')
        
        if not song_urls or song_id not in song_urls:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥ï¼Œå¯èƒ½æ˜¯ç‰ˆæƒé™åˆ¶")
            return
        
        url_info = song_urls[song_id]
        audio_url = url_info.get('url')
        
        if not audio_url:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥")
            return
        
        # å‘é€éŸ³é¢‘
        caption = f"ğŸµ {song['title']}\nğŸ¤ {song['artist']}\nğŸ“€ {song.get('album', 'æœªçŸ¥ä¸“è¾‘')}"
        await query.message.reply_audio(
            audio=audio_url,
            caption=caption,
            title=song['title'],
            performer=song['artist']
        )
        
    except Exception as e:
        logger.exception(f"è¯•å¬å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ è¯•å¬å¤±è´¥: {e}")


async def handle_qq_preview_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†QQéŸ³ä¹è¯•å¬å›è°ƒ"""
    query = update.callback_query
    await query.answer("ğŸ§ æ­£åœ¨è·å–è¯•å¬...")
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        return
    
    data = query.data
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await query.message.reply_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookie")
        return
    
    try:
        idx = int(data.replace("qpreview_song_", ""))
        search_results = context.user_data.get('qq_search_results', [])
        
        if not search_results or idx >= len(search_results):
            await query.message.reply_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
            return
        
        song = search_results[idx]
        song_mid = song['source_id']
        
        from bot.ncm_downloader import QQMusicAPI
        api = QQMusicAPI(qq_cookie)
        
        # è·å–æ­Œæ›²URLï¼ˆä½¿ç”¨æ ‡å‡†éŸ³è´¨ï¼‰
        song_urls = api.get_song_url([song_mid], 'standard')
        
        if not song_urls or song_mid not in song_urls:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥ï¼Œå¯èƒ½æ˜¯ç‰ˆæƒé™åˆ¶")
            return
        
        url_info = song_urls[song_mid]
        audio_url = url_info.get('url')
        
        if not audio_url:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥")
            return
        
        # å‘é€éŸ³é¢‘
        caption = f"ğŸµ {song['title']}\nğŸ¤ {song['artist']}\nğŸ“€ {song.get('album', 'æœªçŸ¥ä¸“è¾‘')}"
        await query.message.reply_audio(
            audio=audio_url,
            caption=caption,
            title=song['title'],
            performer=song['artist']
        )
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹è¯•å¬å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ è¯•å¬å¤±è´¥: {e}")


async def handle_search_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æœç´¢ç»“æœä¸‹è½½å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
        return
    
    data = query.data
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await query.edit_message_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    try:
        from bot.ncm_downloader import MusicAutoDownloader, NeteaseMusicAPI
        
        # è·å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        organize_dir = ncm_settings.get('organize_dir', '')
        
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
        qq_cookie = get_qq_cookie()
        
        downloader = MusicAutoDownloader(
            ncm_cookie, qq_cookie, str(download_path),
            proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
        )
        
        songs_to_download = []
        
        if data.startswith("dl_song_"):
            # ä¸‹è½½å•æ›²æˆ–å…¨éƒ¨
            search_results = context.user_data.get('search_results', [])
            if not search_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            if data == "dl_song_all":
                songs_to_download = search_results
            else:
                idx = int(data.replace("dl_song_", ""))
                if idx < len(search_results):
                    songs_to_download = [search_results[idx]]
        
        elif data.startswith("dl_album_"):
            # ä¸‹è½½ä¸“è¾‘
            album_results = context.user_data.get('album_results', [])
            if not album_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            idx = int(data.replace("dl_album_", ""))
            if idx < len(album_results):
                album = album_results[idx]
                await query.edit_message_text(f"ğŸ“¥ æ­£åœ¨è·å–ä¸“è¾‘ `{album['name']}` çš„æ­Œæ›²åˆ—è¡¨...", parse_mode='Markdown')
                
                api = NeteaseMusicAPI(ncm_cookie)
                songs_to_download = api.get_album_songs(album['album_id'])
                
                if not songs_to_download:
                    await query.message.reply_text("âŒ è·å–ä¸“è¾‘æ­Œæ›²å¤±è´¥")
                    return
        
        if not songs_to_download:
            await query.edit_message_text("æ²¡æœ‰å¯ä¸‹è½½çš„æ­Œæ›²")
            return
        
        # éŸ³è´¨æ˜¾ç¤º
        quality_names = {
            'standard': 'æ ‡å‡†',
            'higher': 'è¾ƒé«˜',
            'exhigh': 'æé«˜',
            'lossless': 'æ— æŸ',
            'hires': 'Hi-Res'
        }
        quality_name = quality_names.get(download_quality, download_quality)
        
        await query.edit_message_text(f"ğŸ”„ å¼€å§‹ä¸‹è½½ {len(songs_to_download)} é¦–æ­Œæ›²...\nğŸ“Š éŸ³è´¨: {quality_name}")
        
        # è¿›åº¦æ¶ˆæ¯
        progress_msg = await query.message.reply_text(
            make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", 0, len(songs_to_download), "å‡†å¤‡å¼€å§‹...")
        )
        last_update_time = [0]
        main_loop = asyncio.get_running_loop()
        
        async def update_progress(current, total, song):
            import time as time_module
            now = time_module.time()
            if now - last_update_time[0] < 1.5:
                return
            last_update_time[0] = now
            try:
                song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                await progress_msg.edit_text(
                    make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", current, total, song_name),
                    parse_mode='Markdown'
                )
            except:
                pass
        
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        # å¼€å§‹ä¸‹è½½
        # organize æ¨¡å¼ï¼šæŒ‰è‰ºæœ¯å®¶/ä¸“è¾‘æ•´ç†
        is_organize_mode = download_mode == 'organize' and organize_dir
        # æœç´¢ä¸‹è½½ï¼šä¸å›é€€åˆ° QQ éŸ³ä¹ï¼Œåªç”¨ç½‘æ˜“äº‘ä¸‹è½½
        success_results, failed_songs = await asyncio.to_thread(
            downloader.download_missing_songs,
            songs_to_download,
            download_quality,
            sync_progress_callback,
            is_organize_mode,
            organize_dir if is_organize_mode else None,
            False  # fallback_to_qq=Falseï¼Œæœç´¢ä¸‹è½½ä¸å›é€€
        )
        
        # æå–æ–‡ä»¶åˆ—è¡¨
        success_files = [r['file'] for r in success_results]
        
        # MusicTag æ¨¡å¼ç§»åŠ¨æ–‡ä»¶
        moved_files = []
        if download_mode == 'musictag' and musictag_dir and success_files:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            for i, file_path in enumerate(success_files):
                try:
                    src = Path(file_path)
                    if not src.exists():
                        logger.warning(f"æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨: {file_path}")
                        continue
                    dst = musictag_path / src.name
                    shutil.move(str(src), str(dst))
                    moved_files.append(str(dst))
                    # æ›´æ–° success_results ä¸­çš„æ–‡ä»¶è·¯å¾„
                    success_results[i]['file'] = str(dst)
                except Exception as e:
                    logger.error(f"ç§»åŠ¨æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
        
        # åˆ é™¤è¿›åº¦æ¶ˆæ¯
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰
        save_download_record_v2(success_results, failed_songs, download_quality, user_id)
        
        # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        platform_info = f"\n   â€¢ ç½‘æ˜“äº‘: {ncm_count}, QQéŸ³ä¹: {qq_count}" if qq_count > 0 else ""
        
        msg = f"ğŸ“¥ **ä¸‹è½½å®Œæˆ** (éŸ³è´¨: {quality_name})\n\n"
        msg += f"âœ… æˆåŠŸ: {len(success_files)} é¦–{platform_info}\n"
        msg += f"âŒ å¤±è´¥: {len(failed_songs)} é¦–\n"
        
        # æ˜¾ç¤ºæ–‡ä»¶å¤§å°
        if success_files:
            total_size = sum(Path(f).stat().st_size for f in success_files if Path(f).exists())
            if total_size > 1024 * 1024:
                size_str = f"{total_size / 1024 / 1024:.1f} MB"
            else:
                size_str = f"{total_size / 1024:.1f} KB"
            msg += f"ğŸ“¦ æ€»å¤§å°: {size_str}\n"
            
            if moved_files:
                msg += f"\nğŸ“ å·²è½¬ç§»åˆ° MusicTag ç›®å½•"
            elif is_organize_mode:
                msg += f"\nğŸ“ å·²æ•´ç†åˆ°: `{organize_dir}`"
            else:
                msg += f"\nğŸ“ å·²ä¿å­˜åˆ°: `{download_dir}`"
        
        # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ é‡è¯•æŒ‰é’®
        retry_keyboard = None
        if failed_songs:
            # ä¿å­˜å¤±è´¥æ­Œæ›²ä»¥ä¾¿é‡è¯•
            context.user_data['failed_songs_ncm'] = failed_songs
            context.user_data['failed_quality_ncm'] = download_quality
            msg += f"\n\nğŸ’¡ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é‡è¯•å¤±è´¥çš„æ­Œæ›²"
            retry_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(f"ğŸ”„ é‡è¯• {len(failed_songs)} é¦–å¤±è´¥æ­Œæ›²", callback_data="retry_ncm_failed")]
            ])
        
        await query.message.reply_text(msg, parse_mode='Markdown', reply_markup=retry_keyboard)
        
        # å¦‚æœåªä¸‹è½½äº†ä¸€é¦–æ­Œï¼Œå‘é€éŸ³é¢‘é¢„è§ˆ
        if len(songs_to_download) == 1 and success_files:
            audio_path = Path(success_files[0])
            if audio_path.exists() and audio_path.stat().st_size < 50 * 1024 * 1024:  # å°äº 50MB
                try:
                    song = songs_to_download[0]
                    with open(str(audio_path), 'rb') as audio_file:
                        await query.message.reply_audio(
                            audio=audio_file,
                            title=song.get('title', audio_path.stem),
                            performer=song.get('artist', 'Unknown'),
                            caption=f"ğŸµ {song.get('title', '')} - {song.get('artist', '')}"
                        )
                except Exception as e:
                    logger.warning(f"å‘é€éŸ³é¢‘é¢„è§ˆå¤±è´¥: {e}")
        
        # è‡ªåŠ¨æ‰«åº“ï¼ˆorganize æ¨¡å¼ä¹Ÿè§¦å‘ï¼‰
        if success_files and (not moved_files or is_organize_mode):
            binding = get_user_binding(user_id)
            if binding:
                try:
                    user_access_token, user_id_emby = authenticate_emby(
                        EMBY_URL, binding['emby_username'], decrypt_password(binding['emby_password'])
                    )
                    if user_access_token:
                        user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                        if trigger_emby_library_scan(user_auth):
                            await query.message.reply_text("ğŸ”„ å·²è‡ªåŠ¨è§¦å‘ Emby æ‰«åº“")
                except:
                    pass
        
    except Exception as e:
        logger.exception(f"ä¸‹è½½å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")


async def handle_qq_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† QQ éŸ³ä¹æœç´¢ç»“æœä¸‹è½½å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
        return
    
    data = query.data
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await query.edit_message_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookie")
        return
    
    try:
        from bot.ncm_downloader import QQMusicAPI
        
        # è·å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        organize_dir = ncm_settings.get('organize_dir', '')
        
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        api = QQMusicAPI(qq_cookie, proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY)
        
        songs_to_download = []
        
        if data.startswith("qdl_song_"):
            # ä¸‹è½½å•æ›²æˆ–å…¨éƒ¨
            search_results = context.user_data.get('qq_search_results', [])
            if not search_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            if data == "qdl_song_all":
                songs_to_download = search_results
            else:
                idx = int(data.replace("qdl_song_", ""))
                if idx < len(search_results):
                    songs_to_download = [search_results[idx]]
        
        elif data.startswith("qdl_album_"):
            # ä¸‹è½½ä¸“è¾‘
            album_results = context.user_data.get('qq_album_results', [])
            if not album_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            idx = int(data.replace("qdl_album_", ""))
            if idx < len(album_results):
                album = album_results[idx]
                await query.edit_message_text(f"ğŸ“¥ æ­£åœ¨è·å– QQéŸ³ä¹ä¸“è¾‘ `{album['name']}` çš„æ­Œæ›²åˆ—è¡¨...", parse_mode='Markdown')
                
                songs_to_download = api.get_album_songs(album['album_id'])
                
                if not songs_to_download:
                    await query.message.reply_text("âŒ è·å–ä¸“è¾‘æ­Œæ›²å¤±è´¥")
                    return
        
        if not songs_to_download:
            await query.edit_message_text("æ²¡æœ‰å¯ä¸‹è½½çš„æ­Œæ›²")
            return
        
        # éŸ³è´¨æ˜¾ç¤º
        quality_names = {
            'standard': 'æ ‡å‡†',
            'higher': 'è¾ƒé«˜',
            'exhigh': 'æé«˜',
            'lossless': 'æ— æŸ',
            'hires': 'Hi-Res'
        }
        quality_name = quality_names.get(download_quality, download_quality)
        
        await query.edit_message_text(f"ğŸ”„ å¼€å§‹ä» QQéŸ³ä¹ ä¸‹è½½ {len(songs_to_download)} é¦–æ­Œæ›²...\nğŸ“Š éŸ³è´¨: {quality_name}")
        
        # è¿›åº¦æ¶ˆæ¯
        progress_msg = await query.message.reply_text(
            make_progress_message("ğŸ“¥ QQéŸ³ä¹ä¸‹è½½ä¸­", 0, len(songs_to_download), "å‡†å¤‡å¼€å§‹...")
        )
        last_update_time = [0]
        main_loop = asyncio.get_running_loop()
        
        async def update_progress(current, total, song):
            import time as time_module
            now = time_module.time()
            if now - last_update_time[0] < 1.5:
                return
            last_update_time[0] = now
            try:
                song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                await progress_msg.edit_text(
                    make_progress_message("ğŸ“¥ QQéŸ³ä¹ä¸‹è½½ä¸­", current, total, song_name),
                    parse_mode='Markdown'
                )
            except:
                pass
        
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        # å¼€å§‹ä¸‹è½½
        # organize æ¨¡å¼ï¼šæŒ‰è‰ºæœ¯å®¶/ä¸“è¾‘æ•´ç†
        is_organize_mode = download_mode == 'organize' and organize_dir
        success_files, failed_songs = await asyncio.to_thread(
            api.batch_download,
            songs_to_download,
            str(download_path),
            download_quality,
            sync_progress_callback,
            is_organize_mode,
            organize_dir if is_organize_mode else None
        )
        
        # MusicTag æ¨¡å¼ç§»åŠ¨æ–‡ä»¶
        moved_files = []
        if download_mode == 'musictag' and musictag_dir and success_files:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            new_success_files = []
            for file_path in success_files:
                try:
                    src = Path(file_path)
                    if not src.exists():
                        logger.warning(f"æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨: {file_path}")
                        new_success_files.append(file_path)  # ä¿ç•™åŸè·¯å¾„
                        continue
                    dst = musictag_path / src.name
                    shutil.move(str(src), str(dst))
                    moved_files.append(str(dst))
                    new_success_files.append(str(dst))  # ä½¿ç”¨æ–°è·¯å¾„
                except Exception as e:
                    logger.error(f"ç§»åŠ¨æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
                    new_success_files.append(file_path)  # å¤±è´¥æ—¶ä¿ç•™åŸè·¯å¾„
            success_files = new_success_files  # æ›´æ–°æ–‡ä»¶åˆ—è¡¨ç”¨äºåç»­è®°å½•
        
        # åˆ é™¤è¿›åº¦æ¶ˆæ¯
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•
        save_download_record(songs_to_download, success_files, failed_songs, 'QQ', download_quality, user_id)
        
        msg = f"ğŸ“¥ **QQéŸ³ä¹ä¸‹è½½å®Œæˆ** (éŸ³è´¨: {quality_name})\n\n"
        msg += f"âœ… æˆåŠŸ: {len(success_files)} é¦–\n"
        msg += f"âŒ å¤±è´¥: {len(failed_songs)} é¦–\n"
        
        # æ˜¾ç¤ºæ–‡ä»¶å¤§å°
        if success_files:
            total_size = sum(Path(f).stat().st_size for f in success_files if Path(f).exists())
            if total_size > 1024 * 1024:
                size_str = f"{total_size / 1024 / 1024:.1f} MB"
            else:
                size_str = f"{total_size / 1024:.1f} KB"
            msg += f"ğŸ“¦ æ€»å¤§å°: {size_str}\n"
            
            if moved_files:
                msg += f"\nğŸ“ å·²è½¬ç§»åˆ° MusicTag ç›®å½•"
            elif is_organize_mode:
                msg += f"\nğŸ“ å·²æ•´ç†åˆ°: `{organize_dir}`"
            else:
                msg += f"\nğŸ“ å·²ä¿å­˜åˆ°: `{download_dir}`"
        
        # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ é‡è¯•æŒ‰é’®
        retry_keyboard = None
        if failed_songs:
            # ä¿å­˜å¤±è´¥æ­Œæ›²ä»¥ä¾¿é‡è¯•
            context.user_data['failed_songs_qq'] = failed_songs
            context.user_data['failed_quality_qq'] = download_quality
            msg += f"\n\nğŸ’¡ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é‡è¯•å¤±è´¥çš„æ­Œæ›²"
            retry_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(f"ğŸ”„ é‡è¯• {len(failed_songs)} é¦–å¤±è´¥æ­Œæ›²", callback_data="retry_qq_failed")]
            ])
        
        await query.message.reply_text(msg, parse_mode='Markdown', reply_markup=retry_keyboard)
        
        # å¦‚æœåªä¸‹è½½äº†ä¸€é¦–æ­Œï¼Œå‘é€éŸ³é¢‘é¢„è§ˆ
        if len(songs_to_download) == 1 and success_files:
            audio_path = Path(success_files[0])
            if audio_path.exists() and audio_path.stat().st_size < 50 * 1024 * 1024:  # å°äº 50MB
                try:
                    song = songs_to_download[0]
                    with open(str(audio_path), 'rb') as audio_file:
                        await query.message.reply_audio(
                            audio=audio_file,
                            title=song.get('title', audio_path.stem),
                            performer=song.get('artist', 'Unknown'),
                            caption=f"ğŸµ {song.get('title', '')} - {song.get('artist', '')}"
                        )
                except Exception as e:
                    logger.warning(f"å‘é€éŸ³é¢‘é¢„è§ˆå¤±è´¥: {e}")
        
        # è‡ªåŠ¨æ‰«åº“ï¼ˆorganize æ¨¡å¼ä¹Ÿè§¦å‘ï¼‰
        if success_files and (not moved_files or is_organize_mode):
            binding = get_user_binding(user_id)
            if binding:
                try:
                    user_access_token, user_id_emby = authenticate_emby(
                        EMBY_URL, binding['emby_username'], decrypt_password(binding['emby_password'])
                    )
                    if user_access_token:
                        user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                        if trigger_emby_library_scan(user_auth):
                            await query.message.reply_text("ğŸ”„ å·²è‡ªåŠ¨è§¦å‘ Emby æ‰«åº“")
                except:
                    pass
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹ä¸‹è½½å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")


# ============================================================
# èœå•å›è°ƒå¤„ç†
# ============================================================

async def handle_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    
    if data == "menu_playlist":
        await query.edit_message_text(
            "ğŸ“‹ **æ­Œå•åŒæ­¥**\n\n"
            "ç›´æ¥å‘é€ QQéŸ³ä¹ æˆ– ç½‘æ˜“äº‘éŸ³ä¹ çš„æ­Œå•é“¾æ¥å³å¯ã€‚\n\n"
            "æ”¯æŒçš„é“¾æ¥æ ¼å¼ï¼š\n"
            "â€¢ `https://y.qq.com/n/ryqq/playlist/...`\n"
            "â€¢ `https://music.163.com/playlist?id=...`\n"
            "â€¢ çŸ­é“¾æ¥ä¹Ÿæ”¯æŒ",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]])
        )
    
    elif data == "menu_upload":
        await query.edit_message_text(
            "ğŸ“¤ **éŸ³ä¹ä¸Šä¼ **\n\n"
            "ç›´æ¥å‘é€éŸ³é¢‘æ–‡ä»¶å³å¯è‡ªåŠ¨ä¸Šä¼ åˆ°æœåŠ¡å™¨ã€‚\n\n"
            "æ”¯æŒæ ¼å¼ï¼šMP3, FLAC, M4A, WAV, OGG, AAC\n\n"
            f"ğŸ“ ä¿å­˜è·¯å¾„: `{MUSIC_TARGET_DIR}`",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]])
        )
    
    elif data == "menu_settings":
        user_id = str(query.from_user.id)
        binding = get_user_binding(user_id)
        
        text = "âš™ï¸ **è®¾ç½®**\n\n"
        if binding:
            text += f"âœ… å·²ç»‘å®š Emby: `{binding['emby_username']}`\n\n"
            text += "ä½¿ç”¨ /unbind è§£é™¤ç»‘å®š\n"
            text += "ä½¿ç”¨ /bind <ç”¨æˆ·å> <å¯†ç > é‡æ–°ç»‘å®š"
        else:
            text += "âŒ å°šæœªç»‘å®š Emby è´¦æˆ·\n\n"
            text += "ä½¿ç”¨ /bind <ç”¨æˆ·å> <å¯†ç > è¿›è¡Œç»‘å®š"
        
        await query.edit_message_text(text, parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]]))
    
    elif data == "menu_status":
        stats = get_stats()
        text = f"""
ğŸ“Š **çŠ¶æ€**

ğŸµ åª’ä½“åº“: {stats.get('library_songs', 0)} é¦–
ğŸ‘¥ ç”¨æˆ·: {stats.get('users', 0)}
ğŸ“‹ æ­Œå•: {stats.get('playlists', 0)} ä¸ª
ğŸ“¤ ä¸Šä¼ : {stats.get('uploads', 0)} ä¸ª
"""
        await query.edit_message_text(text, parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]]))
    
    elif data == "menu_back":
        await query.edit_message_text("è¯·é€‰æ‹©åŠŸèƒ½ï¼š", reply_markup=get_main_menu_keyboard())


async def handle_retry_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†ä¸‹è½½å¤±è´¥é‡è¯•å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id != ADMIN_USER_ID:
        await query.edit_message_text("æ— æƒæ‰§è¡Œæ­¤æ“ä½œ")
        return
    
    data = query.data
    
    if data == "retry_ncm_failed":
        # é‡è¯•ç½‘æ˜“äº‘å¤±è´¥çš„æ­Œæ›²
        failed_songs = context.user_data.get('failed_songs_ncm', [])
        quality = context.user_data.get('failed_quality_ncm', 'exhigh')
        
        if not failed_songs:
            await query.edit_message_text("âŒ æ²¡æœ‰éœ€è¦é‡è¯•çš„æ­Œæ›²")
            return
        
        await query.edit_message_text(f"ğŸ”„ æ­£åœ¨é‡è¯• {len(failed_songs)} é¦–æ­Œæ›²...")
        
        # é‡æ–°è®¾ç½®æœç´¢ç»“æœå¹¶è§¦å‘ä¸‹è½½
        context.user_data['search_results'] = failed_songs
        context.user_data['failed_songs_ncm'] = []  # æ¸…ç©º
        
        # æ„é€ ä¸€ä¸ªå‡çš„ callback data æ¥å¤ç”¨ä¸‹è½½é€»è¾‘
        query.data = "dl_song_all"
        await handle_search_download_callback(update, context)
        
    elif data == "retry_qq_failed":
        # é‡è¯• QQ éŸ³ä¹å¤±è´¥çš„æ­Œæ›²
        failed_songs = context.user_data.get('failed_songs_qq', [])
        quality = context.user_data.get('failed_quality_qq', 'exhigh')
        
        if not failed_songs:
            await query.edit_message_text("âŒ æ²¡æœ‰éœ€è¦é‡è¯•çš„æ­Œæ›²")
            return
        
        await query.edit_message_text(f"ğŸ”„ æ­£åœ¨é‡è¯• {len(failed_songs)} é¦–æ­Œæ›²...")
        
        # é‡æ–°è®¾ç½®æœç´¢ç»“æœå¹¶è§¦å‘ä¸‹è½½
        context.user_data['qq_search_results'] = failed_songs
        context.user_data['failed_songs_qq'] = []  # æ¸…ç©º
        
        # æ„é€ ä¸€ä¸ªå‡çš„ callback data æ¥å¤ç”¨ä¸‹è½½é€»è¾‘
        query.data = "qdl_song_all"
        await handle_qq_download_callback(update, context)


# ============================================================
# æ–‡ä»¶æ•´ç†å™¨
# ============================================================

# å…¨å±€å˜é‡å­˜å‚¨ application å®ä¾‹ï¼Œç”¨äºå‘é€é€šçŸ¥
_telegram_app = None


def file_organizer_callback(source_path: str, target_path: str):
    """æ–‡ä»¶æ•´ç†å®Œæˆåçš„å›è°ƒ - æ—¥å¿—å·²åœ¨ file_organizer ä¸­è®°å½•"""
    pass  # æ—¥å¿—å·²åœ¨ file_organizer.py ä¸­ç¾åŒ–è¾“å‡º


async def start_file_organizer_if_enabled(application):
    """å¦‚æœé…ç½®äº†å¹¶å¯ç”¨äº†æ–‡ä»¶æ•´ç†å™¨ï¼Œåˆ™å¯åŠ¨å®ƒ"""
    global _telegram_app
    _telegram_app = application
    
    try:
        if not database_conn:
            return
        
        cursor = database_conn.cursor()
        
        # æ£€æŸ¥æ˜¯å¦å¯ç”¨
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_enabled',))
        row = cursor.fetchone()
        enabled = row and (row[0] if isinstance(row, tuple) else row['value']) == 'true'
        
        if not enabled:
            logger.info("ğŸ“ æ–‡ä»¶æ•´ç†å™¨æœªå¯ç”¨")
            return
        
        # è·å–é…ç½®
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_source_dir',))
        row = cursor.fetchone()
        source_dir = (row[0] if isinstance(row, tuple) else row['value']) if row else ''
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_target_dir',))
        row = cursor.fetchone()
        target_dir = (row[0] if isinstance(row, tuple) else row['value']) if row else ''
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_template',))
        row = cursor.fetchone()
        template = (row[0] if isinstance(row, tuple) else row['value']) if row else '{album_artist}/{album}'
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_on_conflict',))
        row = cursor.fetchone()
        on_conflict = (row[0] if isinstance(row, tuple) else row['value']) if row else 'skip'
        
        if not source_dir or not target_dir:
            logger.info("ğŸ“ æ–‡ä»¶æ•´ç†å™¨æœªé…ç½®æºç›®å½•æˆ–ç›®æ ‡ç›®å½•")
            return
        
        # å¯åŠ¨ç›‘æ§
        from bot.file_organizer import start_watcher
        watcher = start_watcher(
            source_dir, target_dir, template, on_conflict,
            callback=file_organizer_callback
        )
        
        # å‘é€ Telegram é€šçŸ¥
        if ADMIN_USER_ID:
            try:
                msg = (
                    "ğŸ“ *æ–‡ä»¶æ•´ç†å™¨å·²å¯åŠ¨*\n\n"
                    f"ğŸ“‚ ç›‘æ§ç›®å½•: `{source_dir}`\n"
                    f"ğŸµ æ•´ç†ç›®å½•: `{target_dir}`\n"
                    f"ğŸ“‹ æ•´ç†æ¨¡æ¿: `{template}`\n"
                    f"âš™ï¸ å†²çªå¤„ç†: `{on_conflict}`"
                )
                await application.bot.send_message(
                    chat_id=ADMIN_USER_ID,
                    text=msg,
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.debug(f"å‘é€æ•´ç†å™¨å¯åŠ¨é€šçŸ¥å¤±è´¥: {e}")
        
    except Exception as e:
        logger.error(f"å¯åŠ¨æ–‡ä»¶æ•´ç†å™¨å¤±è´¥: {e}")


# ============================================================
# å®šæ—¶ä»»åŠ¡
# ============================================================

async def scheduled_sync_job(application):
    """å®šæ—¶æ£€æŸ¥è®¢é˜…æ­Œå•æ›´æ–°"""
    await asyncio.sleep(300)  # å¯åŠ¨å 5 åˆ†é’Ÿå¼€å§‹ç¬¬ä¸€æ¬¡æ£€æŸ¥
    
    while True:
        try:
            logger.info("å¼€å§‹å®šæ—¶æ­Œå•åŒæ­¥æ£€æŸ¥...")
            
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('''
                    SELECT id, telegram_id, playlist_url, playlist_name, platform
                    FROM scheduled_playlists WHERE is_active = 1
                ''')
                playlists = cursor.fetchall()
                
                for playlist in playlists:
                    try:
                        playlist_id = playlist[0] if isinstance(playlist, tuple) else playlist['id']
                        telegram_id = playlist[1] if isinstance(playlist, tuple) else playlist['telegram_id']
                        playlist_url = playlist[2] if isinstance(playlist, tuple) else playlist['playlist_url']
                        playlist_name = playlist[3] if isinstance(playlist, tuple) else playlist['playlist_name']
                        
                        logger.info(f"æ£€æŸ¥æ­Œå•æ›´æ–°: {playlist_name}")
                        # è¿™é‡Œå¯ä»¥æ·»åŠ æ­Œå•åŒæ­¥é€»è¾‘
                        
                    except Exception as e:
                        logger.error(f"åŒæ­¥æ­Œå•å¤±è´¥: {e}")
                        
        except Exception as e:
            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å‡ºé”™: {e}")
        
        await asyncio.sleep(6 * 3600)  # æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡


async def scheduled_emby_scan_job(application):
    """å®šæ—¶æ‰«æ Emby åª’ä½“åº“"""
    await asyncio.sleep(600)  # å¯åŠ¨å 10 åˆ†é’Ÿå¼€å§‹
    
    while True:
        try:
            # è·å–æ‰«æé—´éš”è®¾ç½®
            scan_interval = EMBY_SCAN_INTERVAL
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                row = cursor.fetchone()
                if row:
                    scan_interval = int(row[0] if isinstance(row, tuple) else row['value'])
            
            if scan_interval <= 0:
                await asyncio.sleep(3600)  # æœªå¯ç”¨æ—¶ï¼Œæ¯å°æ—¶æ£€æŸ¥é…ç½®
                continue
            
            logger.info(f"å¼€å§‹å®šæ—¶ Emby åª’ä½“åº“æ‰«æ...")
            
            # æ‰«æå¹¶æ›´æ–°ç¼“å­˜
            if emby_auth.get('access_token') and emby_auth.get('user_id'):
                await sync_library_cache()
                logger.info("Emby åª’ä½“åº“æ‰«æå®Œæˆ")
            
        except Exception as e:
            logger.error(f"å®šæ—¶æ‰«æä»»åŠ¡å‡ºé”™: {e}")
        
        # ç­‰å¾…ä¸‹ä¸€æ¬¡æ‰«æ
        interval_hours = scan_interval if scan_interval > 0 else 1
        await asyncio.sleep(interval_hours * 3600)


async def daily_stats_job(application):
    """æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š"""
    import datetime as dt
    
    while True:
        try:
            now = dt.datetime.now()
            # è®¡ç®—åˆ°æ˜å¤©æ—©ä¸Š 9 ç‚¹çš„ç§’æ•°
            target = now.replace(hour=9, minute=0, second=0, microsecond=0)
            if now >= target:
                target += dt.timedelta(days=1)
            wait_seconds = (target - now).total_seconds()
            
            await asyncio.sleep(wait_seconds)
            
            # å‘é€æ¯æ—¥ç»Ÿè®¡
            if ADMIN_USER_ID and database_conn:
                cursor = database_conn.cursor()
                today = dt.datetime.now().strftime('%Y-%m-%d')
                
                # ä»Šæ—¥ä¸‹è½½æ•°
                cursor.execute('''
                    SELECT COUNT(*) FROM download_history 
                    WHERE date(download_time) = ?
                ''', (today,))
                today_downloads = cursor.fetchone()[0]
                
                # æ€»ä¸‹è½½æ•°
                cursor.execute('SELECT COUNT(*) FROM download_history')
                total_downloads = cursor.fetchone()[0]
                
                # æ´»è·ƒç”¨æˆ·æ•°
                cursor.execute('SELECT COUNT(DISTINCT telegram_id) FROM users WHERE emby_token IS NOT NULL')
                active_users = cursor.fetchone()[0]
                
                msg = (
                    f"ğŸ“Š *æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š*\n"
                    f"ğŸ“… æ—¥æœŸ: {today}\n\n"
                    f"â¬‡ï¸ ä»Šæ—¥ä¸‹è½½: {today_downloads} é¦–\n"
                    f"ğŸ“¥ æ€»ä¸‹è½½æ•°: {total_downloads} é¦–\n"
                    f"ğŸ‘¥ ç»‘å®šç”¨æˆ·: {active_users} äºº"
                )
                
                try:
                    await application.bot.send_message(
                        chat_id=ADMIN_USER_ID,
                        text=msg,
                        parse_mode='Markdown'
                    )
                except Exception as e:
                    logger.debug(f"å‘é€æ¯æ—¥æŠ¥å‘Šå¤±è´¥: {e}")
                    
        except Exception as e:
            logger.error(f"æ¯æ—¥ç»Ÿè®¡ä»»åŠ¡å‡ºé”™: {e}")
            await asyncio.sleep(3600)  # å‡ºé”™åç­‰å¾… 1 å°æ—¶å†è¯•


async def cookie_check_job(application):
    """å®šæ—¶æ£€æŸ¥ Cookie æ˜¯å¦è¿‡æœŸ"""
    await asyncio.sleep(1800)  # å¯åŠ¨å 30 åˆ†é’Ÿå¼€å§‹
    
    while True:
        try:
            issues = []
            
            # æ£€æŸ¥ç½‘æ˜“äº‘ Cookie
            ncm_cookie = get_ncm_cookie()
            if ncm_cookie:
                try:
                    from bot.ncm_downloader import check_ncm_cookie
                    if not check_ncm_cookie(ncm_cookie):
                        issues.append("âš ï¸ ç½‘æ˜“äº‘ Cookie å¯èƒ½å·²è¿‡æœŸ")
                except:
                    pass
            
            # æ£€æŸ¥ QQ éŸ³ä¹ Cookie
            qq_cookie = get_qq_cookie()
            if qq_cookie:
                try:
                    from bot.ncm_downloader import check_qq_cookie
                    if not check_qq_cookie(qq_cookie):
                        issues.append("âš ï¸ QQéŸ³ä¹ Cookie å¯èƒ½å·²è¿‡æœŸ")
                except:
                    pass
            
            # å‘é€å‘Šè­¦
            if issues and ADMIN_USER_ID:
                msg = "ğŸ”” *Cookie æ£€æŸ¥å‘Šè­¦*\n\n" + "\n".join(issues)
                msg += "\n\nè¯·åŠæ—¶åœ¨ Web ç®¡ç†ç•Œé¢æ›´æ–° Cookie"
                
                try:
                    await application.bot.send_message(
                        chat_id=ADMIN_USER_ID,
                        text=msg,
                        parse_mode='Markdown'
                    )
                except:
                    pass
                    
        except Exception as e:
            logger.error(f"Cookie æ£€æŸ¥ä»»åŠ¡å‡ºé”™: {e}")
        
        await asyncio.sleep(6 * 3600)  # æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡


async def emby_webhook_notify_job(application):
    """å¤„ç† Emby Webhook é€šçŸ¥å¹¶å‘é€åˆ° Telegram"""
    from bot.web import get_webhook_notifications, set_webhook_bot
    
    # è®¾ç½® Bot å®ä¾‹å¼•ç”¨
    set_webhook_bot(application.bot)
    
    while True:
        try:
            if not EMBY_WEBHOOK_NOTIFY:
                await asyncio.sleep(60)
                continue
            
            # è·å–å¾…å¤„ç†çš„é€šçŸ¥
            notifications = get_webhook_notifications()
            
            if notifications and ADMIN_USER_ID:
                for notif in notifications:
                    try:
                        if notif.get('type') == 'library_new':
                            title = notif.get('title', 'æœªçŸ¥')
                            artist = notif.get('artist', '')
                            album = notif.get('album', '')
                            item_type = notif.get('item_type', '').lower()
                            
                            if item_type == 'audio':
                                emoji = "ğŸµ"
                                type_name = "æ­Œæ›²"
                            elif item_type == 'musicalbum':
                                emoji = "ğŸ’¿"
                                type_name = "ä¸“è¾‘"
                            elif item_type == 'musicartist':
                                emoji = "ğŸ¤"
                                type_name = "è‰ºæœ¯å®¶"
                            else:
                                emoji = "ğŸ“€"
                                type_name = "åª’ä½“"
                            
                            msg = f"{emoji} *Emby æ–°{type_name}å…¥åº“*\n\n"
                            msg += f"ğŸµ åç§°: {title}\n"
                            if artist:
                                msg += f"ğŸ¤ è‰ºæœ¯å®¶: {artist}\n"
                            if album:
                                msg += f"ğŸ’¿ ä¸“è¾‘: {album}"
                            
                            await application.bot.send_message(
                                chat_id=ADMIN_USER_ID,
                                text=msg,
                                parse_mode='Markdown'
                            )
                            
                    except Exception as e:
                        logger.debug(f"å‘é€ Webhook é€šçŸ¥å¤±è´¥: {e}")
            
        except Exception as e:
            logger.error(f"Webhook é€šçŸ¥ä»»åŠ¡å‡ºé”™: {e}")
        
        await asyncio.sleep(30)  # æ¯ 30 ç§’æ£€æŸ¥ä¸€æ¬¡


async def sync_library_cache():
    """åŒæ­¥ Emby åª’ä½“åº“ç¼“å­˜"""
    global emby_library_data
    
    try:
        if not emby_auth.get('access_token') or not emby_auth.get('user_id'):
            return
        
        headers = {
            'X-Emby-Token': emby_auth['access_token'],
            'X-Emby-Client': EMBY_CLIENT_NAME,
            'X-Emby-Device-Name': DEVICE_ID,
            'X-Emby-Device-Id': DEVICE_ID
        }
        
        # è·å–éŸ³ä¹åº“
        url = f"{EMBY_URL}/Users/{emby_auth['user_id']}/Items"
        params = {
            'IncludeItemTypes': 'Audio',
            'Recursive': 'true',
            'Fields': 'Artists,Album,AlbumArtist',
            'Limit': 50000
        }
        
        resp = requests_session.get(url, headers=headers, params=params, timeout=60)
        if resp.status_code == 200:
            data = resp.json()
            items = data.get('Items', [])
            
            # è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼ï¼ˆä¸ scan_emby_library ä¸€è‡´ï¼‰
            converted_items = []
            for item in items:
                artists = "/".join([a.get('Name', '') for a in item.get('ArtistItems', [])])
                if not artists:
                    # å…¼å®¹ä¸åŒçš„ Artists æ ¼å¼
                    artists = "/".join(item.get('Artists', []))
                converted_items.append({
                    'id': str(item.get('Id', '')),
                    'title': html.unescape(item.get('Name', '')),
                    'artist': html.unescape(artists)
                })
            
            emby_library_data = converted_items
            
            # ä¿å­˜åˆ°ç¼“å­˜æ–‡ä»¶
            with open(LIBRARY_CACHE_FILE, 'w', encoding='utf-8') as f:
                json.dump(converted_items, f, ensure_ascii=False)
            
            logger.info(f"åª’ä½“åº“ç¼“å­˜å·²æ›´æ–°: {len(converted_items)} é¦–æ­Œæ›²")
            
    except Exception as e:
        logger.error(f"åŒæ­¥åª’ä½“åº“ç¼“å­˜å¤±è´¥: {e}")


# ============================================================
# æ¶ˆæ¯å¤„ç†
# ============================================================

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message
    
    # å¤„ç†éŸ³é¢‘/æ–‡æ¡£ä¸Šä¼ 
    if message.audio or message.document:
        handled = await handle_audio_upload(update, context)
        if handled:
            return
    
    # å¤„ç†æ–‡æœ¬æ¶ˆæ¯ï¼ˆæ­Œå•é“¾æ¥ï¼‰
    if message.text:
        handled = await handle_playlist_url(update, context)
        if handled:
            return


# ============================================================
# ä¸»ç¨‹åº
# ============================================================

def main():
    global requests_session
    
    if not TELEGRAM_TOKEN:
        logger.critical("ç¼ºå°‘ TELEGRAM_BOT_TOKENï¼ˆæˆ– TELEGRAM_TOKENï¼‰ï¼")
        return
    if not EMBY_URL:
        logger.critical("ç¼ºå°‘ EMBY_URLï¼")
        return
    
    requests_session = create_requests_session()
    init_database()
    
    # Emby è®¤è¯
    if EMBY_USERNAME and EMBY_PASSWORD:
        token, user_id = authenticate_emby(EMBY_URL, EMBY_USERNAME, EMBY_PASSWORD)
        if token:
            emby_auth['access_token'] = token
            emby_auth['user_id'] = user_id
    
    # åŠ è½½åª’ä½“åº“ç¼“å­˜
    global emby_library_data
    if LIBRARY_CACHE_FILE.exists():
        try:
            with open(LIBRARY_CACHE_FILE, 'r', encoding='utf-8') as f:
                cached_data = json.load(f)
            
            # æ£€æŸ¥ç¼“å­˜æ ¼å¼ï¼Œå¦‚æœæ˜¯æ—§æ ¼å¼ï¼ˆæœ‰ Name å­—æ®µï¼‰åˆ™è½¬æ¢
            if cached_data and isinstance(cached_data, list) and len(cached_data) > 0:
                first_item = cached_data[0]
                if 'Name' in first_item and 'title' not in first_item:
                    # æ—§æ ¼å¼ï¼Œéœ€è¦è½¬æ¢
                    logger.info("æ£€æµ‹åˆ°æ—§æ ¼å¼ç¼“å­˜ï¼Œæ­£åœ¨è½¬æ¢...")
                    converted = []
                    for item in cached_data:
                        artists = "/".join([a.get('Name', '') for a in item.get('ArtistItems', [])])
                        if not artists:
                            artists = "/".join(item.get('Artists', []))
                        converted.append({
                            'id': str(item.get('Id', '')),
                            'title': html.unescape(item.get('Name', '')),
                            'artist': html.unescape(artists)
                        })
                    emby_library_data = converted
                    # ä¿å­˜è½¬æ¢åçš„ç¼“å­˜
                    with open(LIBRARY_CACHE_FILE, 'w', encoding='utf-8') as f:
                        json.dump(converted, f, ensure_ascii=False)
                    logger.info(f"ç¼“å­˜æ ¼å¼å·²è½¬æ¢: {len(converted)} é¦–æ­Œæ›²")
                else:
                    # æ–°æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
                    emby_library_data = cached_data
                    logger.info(f"ä»ç¼“å­˜åŠ è½½ {len(emby_library_data)} é¦–æ­Œæ›²")
            else:
                emby_library_data = cached_data
                logger.info(f"ä»ç¼“å­˜åŠ è½½ {len(emby_library_data)} é¦–æ­Œæ›²")
        except Exception as e:
            logger.warning(f"åŠ è½½ç¼“å­˜å¤±è´¥: {e}")
            if emby_auth['access_token']:
                scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
    else:
        if emby_auth['access_token']:
            scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
    
    # åˆå§‹åŒ–ä¸‹è½½ç®¡ç†å™¨
    global download_manager
    download_manager = _init_dm(str(DATABASE_FILE), max_concurrent=3, max_retries=3, retry_delay=2.0)
    logger.info("ä¸‹è½½ç®¡ç†å™¨å·²åˆå§‹åŒ–")
    
    # å¯åŠ¨ Bot
    builder = Application.builder().token(TELEGRAM_TOKEN).connect_timeout(30).read_timeout(30).write_timeout(30)
    
    # å¦‚æœé…ç½®äº† Local Bot API Server
    if TELEGRAM_API_URL:
        builder = builder.base_url(TELEGRAM_API_URL).base_file_url(TELEGRAM_API_URL.replace('/bot', '/file/bot'))
        logger.info(f"ä½¿ç”¨ Local Bot API Server: {TELEGRAM_API_URL}")
    
    app = builder.build()
    
    # å‘½ä»¤ï¼ˆæ”¯æŒçŸ­å‘½ä»¤å’Œå®Œæ•´å‘½ä»¤ï¼‰
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("help", cmd_help))
    app.add_handler(CommandHandler(["bind", "b"], cmd_bind))  # /b ç»‘å®š
    app.add_handler(CommandHandler("unbind", cmd_unbind))
    app.add_handler(CommandHandler(["status", "s"], cmd_status))  # /s çŠ¶æ€
    app.add_handler(CommandHandler(["rescan", "scan", "rs"], cmd_rescan))  # /scan /rs æ‰«åº“
    app.add_handler(CommandHandler("ncmstatus", cmd_ncm_status))
    app.add_handler(CommandHandler(["search", "ss"], cmd_search))  # /ss ç½‘æ˜“äº‘æœç´¢
    app.add_handler(CommandHandler(["album", "al"], cmd_album))  # /al ç½‘æ˜“äº‘ä¸“è¾‘
    app.add_handler(CommandHandler(["qqsearch", "qs"], cmd_qq_search))  # /qs QQéŸ³ä¹æœç´¢
    app.add_handler(CommandHandler(["qqalbum", "qa"], cmd_qq_album))  # /qa QQéŸ³ä¹ä¸“è¾‘
    app.add_handler(CommandHandler(["schedule", "sub"], cmd_schedule))  # /sub è®¢é˜…åˆ—è¡¨
    app.add_handler(CommandHandler(["unschedule", "unsub"], cmd_unschedule))  # /unsub å–æ¶ˆè®¢é˜…
    app.add_handler(CommandHandler(["scaninterval", "si"], cmd_scaninterval))  # /si æ‰«æé—´éš”
    app.add_handler(CommandHandler(["request", "req"], cmd_request))  # /req ç”³è¯·
    app.add_handler(CommandHandler(["myrequests", "mr"], cmd_myrequests))  # /mr æˆ‘çš„ç”³è¯·
    app.add_handler(CommandHandler(["dlstatus", "ds"], cmd_download_status))  # /ds ä¸‹è½½çŠ¶æ€
    app.add_handler(CommandHandler(["dlqueue", "dq"], cmd_download_queue))  # /dq ä¸‹è½½é˜Ÿåˆ—
    app.add_handler(CommandHandler(["dlhistory", "dh"], cmd_download_history))  # /dh ä¸‹è½½å†å²
    
    # å›è°ƒ
    app.add_handler(CallbackQueryHandler(handle_match_callback, pattern='^match_'))
    app.add_handler(CallbackQueryHandler(handle_download_callback, pattern='^download_'))
    app.add_handler(CallbackQueryHandler(handle_unmatched_page_callback, pattern='^unmatched_page_'))  # æœªåŒ¹é…æ­Œæ›²ç¿»é¡µ
    app.add_handler(CallbackQueryHandler(handle_preview_callback, pattern='^preview_'))  # ç½‘æ˜“äº‘è¯•å¬
    app.add_handler(CallbackQueryHandler(handle_qq_preview_callback, pattern='^qpreview_'))  # QQéŸ³ä¹è¯•å¬
    app.add_handler(CallbackQueryHandler(handle_search_download_callback, pattern='^dl_'))
    app.add_handler(CallbackQueryHandler(handle_qq_download_callback, pattern='^qdl_'))  # QQéŸ³ä¹ä¸‹è½½
    app.add_handler(CallbackQueryHandler(handle_sync_callback, pattern='^sync_'))
    app.add_handler(CallbackQueryHandler(handle_request_callback, pattern='^req_'))
    app.add_handler(CallbackQueryHandler(handle_retry_callback, pattern='^retry_'))  # é‡è¯•å¤±è´¥ä¸‹è½½
    app.add_handler(CallbackQueryHandler(handle_menu_callback, pattern='^menu_'))
    
    # Inline æŸ¥è¯¢ï¼ˆä»»æ„èŠå¤©ä¸­ @bot æ­Œåï¼‰
    app.add_handler(InlineQueryHandler(handle_inline_query))
    
    # æ¶ˆæ¯
    app.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_message))
    
    logger.info("Bot å¯åŠ¨æˆåŠŸï¼")
    ncm_cookie = get_ncm_cookie()
    if ncm_cookie:
        logger.info("å·²é…ç½®ç½‘æ˜“äº‘ Cookieï¼Œè‡ªåŠ¨ä¸‹è½½åŠŸèƒ½å·²å¯ç”¨")
    
    # å¯åŠ¨å®šæ—¶åŒæ­¥ä»»åŠ¡ & æ³¨å†Œå‘½ä»¤èœå•
    async def post_init(application):
        # æ³¨å†Œå‘½ä»¤èœå•ï¼ˆç”¨æˆ·è¾“å…¥ / æ—¶æ˜¾ç¤ºï¼‰
        from telegram import BotCommand
        commands = [
            BotCommand("start", "ğŸ  ä¸»èœå•"),
            BotCommand("help", "â“ å¸®åŠ©"),
            BotCommand("b", "ğŸ”‘ ç»‘å®šEmby (bind)"),
            BotCommand("s", "ğŸ“Š çŠ¶æ€ (status)"),
            BotCommand("ss", "ğŸ” ç½‘æ˜“äº‘æœæ­Œ"),
            BotCommand("al", "ğŸ’¿ ç½‘æ˜“äº‘ä¸“è¾‘"),
            BotCommand("qs", "ğŸ” QQéŸ³ä¹æœæ­Œ"),
            BotCommand("qa", "ğŸ’¿ QQéŸ³ä¹ä¸“è¾‘"),
            BotCommand("req", "ğŸ“ ç”³è¯·æ­Œæ›²"),
            BotCommand("mr", "ğŸ“‹ æˆ‘çš„ç”³è¯·"),
            BotCommand("sub", "ğŸ“… è®¢é˜…åˆ—è¡¨"),
            BotCommand("unsub", "âŒ å–æ¶ˆè®¢é˜…"),
            BotCommand("scan", "ğŸ”„ æ‰«æEmby"),
            BotCommand("si", "â±ï¸ æ‰«æé—´éš”"),
            BotCommand("ds", "ğŸ“Š ä¸‹è½½çŠ¶æ€"),
            BotCommand("dq", "ğŸ“¥ ä¸‹è½½é˜Ÿåˆ—"),
        ]
        await application.bot.set_my_commands(commands)
        logger.info("å·²æ³¨å†Œ Telegram å‘½ä»¤èœå•")
        
        # å¯åŠ¨ä¸‹è½½ç®¡ç†å™¨
        if download_manager:
            await download_manager.start()
            logger.info("ä¸‹è½½ç®¡ç†å™¨å·²å¯åŠ¨")
        
        # å¯åŠ¨å®šæ—¶åŒæ­¥ä»»åŠ¡
        asyncio.create_task(scheduled_sync_job(application))
        logger.info("å®šæ—¶åŒæ­¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡)")
        
        # å¯åŠ¨å®šæ—¶æ‰«æ Emby åª’ä½“åº“ä»»åŠ¡
        asyncio.create_task(scheduled_emby_scan_job(application))
        scan_interval = EMBY_SCAN_INTERVAL
        try:
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                row = cursor.fetchone()
                if row:
                    scan_interval = int(row[0] if isinstance(row, tuple) else row['value'])
        except:
            pass
        if scan_interval > 0:
            logger.info(f"Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æå·²å¯åŠ¨ (æ¯ {scan_interval} å°æ—¶)")
        else:
            logger.info("Emby åª’ä½“åº“è‡ªåŠ¨æ‰«ææœªå¯ç”¨")
        
        # å¯åŠ¨æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šä»»åŠ¡
        asyncio.create_task(daily_stats_job(application))
        logger.info("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šä»»åŠ¡å·²å¯åŠ¨ (æ¯å¤© 9:00)")
        
        # å¯åŠ¨ Cookie è¿‡æœŸæ£€æŸ¥ä»»åŠ¡
        asyncio.create_task(cookie_check_job(application))
        logger.info("Cookie è¿‡æœŸæ£€æŸ¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯6å°æ—¶)")
        
        # è®¾ç½® Webhook Bot å®ä¾‹ï¼ˆç”¨äºç›´æ¥å‘é€é€šçŸ¥ï¼‰
        from bot.web import set_webhook_bot
        set_webhook_bot(application.bot)
        logger.info("Webhook Bot å®ä¾‹å·²è®¾ç½®")
        
        # å¯åŠ¨ Emby Webhook é€šçŸ¥ä»»åŠ¡
        asyncio.create_task(emby_webhook_notify_job(application))
        if EMBY_WEBHOOK_NOTIFY:
            logger.info("Emby Webhook é€šçŸ¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯30ç§’æ£€æŸ¥)")
        else:
            logger.info("Emby Webhook é€šçŸ¥å·²ç¦ç”¨")
        
        # å¯åŠ¨æ–‡ä»¶æ•´ç†å™¨ï¼ˆå¦‚æœå·²é…ç½®å¹¶å¯ç”¨ï¼‰
        await start_file_organizer_if_enabled(application)
    
    app.post_init = post_init
    
    # å¦‚æœé…ç½®äº† Pyrogramï¼Œå¯åŠ¨å¤§æ–‡ä»¶æ¥æ”¶åŠŸèƒ½
    if TG_API_ID and TG_API_HASH:
        asyncio.get_event_loop().run_until_complete(start_pyrogram_client())
    
    app.run_polling()


if __name__ == '__main__':
    main()
