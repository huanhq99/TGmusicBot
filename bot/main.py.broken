                # ä½¿ç”¨ Pyrogram ä¸‹è½½å¤§æ–‡ä»¶
                temp_path = UPLOAD_DIR / original_name
                await message.download(file_name=str(temp_path))
                
                # æ¸…ç†æ–‡ä»¶åå¹¶ç§»åŠ¨åˆ°ä¸‹è½½ç›®å½•
                clean_name = clean_filename(original_name)
                target_path = download_path / clean_name
                
                if target_path.exists():
                    target_path.unlink()
                
                shutil.move(str(temp_path), str(target_path))
                
                # å¦‚æœæ˜¯ MusicTag æ¨¡å¼
                final_path = target_path
                if download_mode == 'musictag' and musictag_dir:
                    musictag_path = Path(musictag_dir)
                    musictag_path.mkdir(parents=True, exist_ok=True)
                    final_dest = musictag_path / clean_name
                    shutil.move(str(target_path), str(final_dest))
                    final_path = final_dest
                    logger.info(f"å·²ç§»åŠ¨å¤§æ–‡ä»¶åˆ° MusicTag: {clean_name}")
                
                # è®°å½•
                save_upload_record(user_id, original_name, clean_name, file_size)
                
                size_mb = file_size / 1024 / 1024
                if download_mode == 'musictag' and musictag_dir:
                    await status_msg.edit_text(f"âœ… å¤§æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB\nğŸ“‚ å·²è½¬ç§»åˆ° MusicTag ç›®å½•")
                else:
                    await status_msg.edit_text(f"âœ… å¤§æ–‡ä»¶ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB\nğŸ“‚ ä¿å­˜ä½ç½®: {download_path}")
                
                logger.info(f"ç”¨æˆ· {user_id} ä¸Šä¼ å¤§æ–‡ä»¶: {clean_name} ({size_mb:.2f} MB)")
                
            except Exception as e:
                logger.error(f"å¤§æ–‡ä»¶ä¸Šä¼ å¤±è´¥: {e}")
                await message.reply_text(f"âŒ ä¸Šä¼ å¤±è´¥: {str(e)}")
        
        await pyrogram_client.start()
        logger.info("âœ… Pyrogram å®¢æˆ·ç«¯å·²å¯åŠ¨ï¼Œå¤§æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½å·²å¯ç”¨ (æœ€å¤§ 2GB)")
        
    except ImportError:
        logger.warning("Pyrogram æœªå®‰è£…ï¼Œå¤§æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½ä¸å¯ç”¨")
    except Exception as e:
        logger.error(f"Pyrogram å¯åŠ¨å¤±è´¥: {e}")


# --- æ—¥å¿—è®¾ç½® ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE, encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# é™ä½ç¬¬ä¸‰æ–¹åº“çš„æ—¥å¿—çº§åˆ«ï¼Œé¿å…åˆ·å±
logging.getLogger('httpx').setLevel(logging.WARNING)
logging.getLogger('httpcore').setLevel(logging.WARNING)
logging.getLogger('telegram').setLevel(logging.WARNING)
logging.getLogger('apscheduler').setLevel(logging.WARNING)

# ============================================================
# å·¥å…·å‡½æ•°
# ============================================================

def create_requests_session():
    session = requests.Session()
    retry_strategy = Retry(total=3, status_forcelist=[429, 500, 502, 503, 504], 
                          allowed_methods=["HEAD", "GET", "POST", "DELETE"], backoff_factor=1)
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session

def strip_jsonp(jsonp_str):
    match = re.match(r'^[^{]*\(({.*?})\)[^}]*$', jsonp_str.strip())
    return match.group(1) if match else jsonp_str

def encrypt_password(password):
    return fernet.encrypt(password.encode()).decode()

def decrypt_password(encrypted_password):
    try:
        return fernet.decrypt(encrypted_password.encode()).decode()
    except Exception:
        # è§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ—§ key åŠ å¯†çš„ï¼Œè¿”å›åŸæ–‡ï¼ˆå‡è®¾æ˜¯æ˜æ–‡ï¼‰
        logger.warning("å¯†ç è§£å¯†å¤±è´¥ï¼Œå¯èƒ½éœ€è¦é‡æ–°ç»‘å®šè´¦å·")
        return encrypted_password

def _normalize_artists(artist_str: str) -> set:
    if not isinstance(artist_str, str): return set()
    s = artist_str.lower()
    s = re.sub(r'\s*[\(ï¼ˆ].*?[\)ï¼‰]', '', s)
    s = re.sub(r'\s*[\[ã€].*?[\]ã€‘]', '', s)
    s = re.sub(r'\s+(feat|ft|with|vs|presents|pres\.|starring)\.?\s+', '/', s)
    s = re.sub(r'\s*&\s*', '/', s)
    return {artist.strip() for artist in re.split(r'\s*[/â€¢,ã€]\s*', s) if artist.strip()}

def _get_title_lookup_key(title: str) -> str:
    if not isinstance(title, str): return ""
    key = title.lower()
    key = re.sub(r'\s*[\(ï¼ˆã€\[].*?[\)ï¼‰ã€‘\]]', '', key).strip()
    return key

def _resolve_short_url(url: str) -> str:
    try:
        headers = {'User-Agent': 'Mozilla/5.0', 'Accept': 'text/html'}
        response = requests_session.get(url, headers=headers, timeout=(10, 20), allow_redirects=True)
        if response.url != url:
            logger.info(f"çŸ­é“¾æ¥è§£æ: {url} -> {response.url}")
        return response.url
    except:
        return url

def clean_filename(name: str) -> str:
    """æ¸…ç†æ–‡ä»¶å"""
    name = re.sub(r'^\d+\s*[-_. ]+\s*', '', name)
    name = re.sub(r'[_]+', ' ', name)
    name = re.sub(r'\s*\(\d+\)\s*', '', name)
    # ç§»é™¤éæ³•å­—ç¬¦
    name = re.sub(r'[<>:"/\\|?*]', '', name)
    return name.strip()


# ============================================================
# Emby API
# ============================================================

def authenticate_emby(base_url, username, password):
    api_url = urljoin(base_url, "/emby/Users/AuthenticateByName")
    auth_header = f'Emby Client="{EMBY_CLIENT_NAME}", Device="Docker", DeviceId="{DEVICE_ID}", Version="{APP_VERSION}"'
    headers = {
        'X-Emby-Authorization': auth_header,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    try:
        response = requests_session.post(api_url, params={'format': 'json'},
                                        json={"Username": username, "Pw": password},
                                        headers=headers, timeout=(10, 20))
        response.raise_for_status()
        data = response.json()
        if data and 'AccessToken' in data and 'User' in data:
            logger.info(f"Emby è®¤è¯æˆåŠŸ: {username}")
            return data['AccessToken'], data['User']['Id']
    except requests.RequestException as e:
        logger.error(f"Emby è®¤è¯å¤±è´¥: {e}")
    return None, None

def call_emby_api(endpoint, params=None, method='GET', data=None, user_auth=None, timeout=(15, 60)):
    auth = user_auth or emby_auth
    access_token = auth.get('access_token')
    user_id = auth.get('user_id')
    if not access_token or not user_id:
        return None
    
    api_url = urljoin(EMBY_URL, f"/emby/{endpoint.lstrip('/')}")
    auth_header = f'Emby UserId="{user_id}", Client="{EMBY_CLIENT_NAME}", Device="Docker", DeviceId="{DEVICE_ID}", Version="{APP_VERSION}", Token="{access_token}"'
    headers = {
        'X-Emby-Authorization': auth_header,
        'X-Emby-Token': access_token,
        'Accept': 'application/json'
    }
    query_params = {'format': 'json', **(params or {})}
    
    try:
        if method.upper() == 'GET':
            response = requests_session.get(api_url, params=query_params, headers=headers, timeout=timeout)
        elif method.upper() == 'POST':
            headers['Content-Type'] = 'application/json'
            response = requests_session.post(api_url, params=params, json=data, headers=headers, timeout=timeout)
        elif method.upper() == 'DELETE':
            response = requests_session.delete(api_url, params=params, headers=headers, timeout=timeout)
        else:
            return None
        
        if response.status_code == 204:
            return {"status": "ok"}
        response.raise_for_status()
        try:
            return response.json()
        except:
            return {"status": "ok"}
    except requests.RequestException as e:
        logger.error(f"Emby API ({endpoint}) å¤±è´¥: {e}")
        return None


def trigger_emby_library_scan(user_auth=None):
    """è§¦å‘ Emby åª’ä½“åº“æ‰«æ"""
    try:
        # åˆ·æ–°æ•´ä¸ªåª’ä½“åº“
        result = call_emby_api("Library/Refresh", method='POST', user_auth=user_auth)
        if result:
            logger.info("å·²è§¦å‘ Emby åª’ä½“åº“æ‰«æ")
            return True
        return False
    except Exception as e:
        logger.error(f"è§¦å‘ Emby æ‰«åº“å¤±è´¥: {e}")
        return False


# ============================================================
# åª’ä½“åº“æ‰«æ
# ============================================================

def scan_emby_library(save_to_cache=True, user_id=None, access_token=None):
    global emby_library_data
    logger.info("å¼€å§‹æ‰«æ Emby åª’ä½“åº“...")
    scanned_songs = []
    start_index = 0
    
    scan_user_id = user_id or emby_auth['user_id']
    scan_access_token = access_token or emby_auth['access_token']
    if not scan_user_id or not scan_access_token:
        return []
    
    temp_auth = {'user_id': scan_user_id, 'access_token': scan_access_token}
    
    while True:
        params = {
            'IncludeItemTypes': 'Audio', 'Recursive': 'true',
            'Limit': EMBY_SCAN_PAGE_SIZE, 'StartIndex': start_index,
            'Fields': 'Id,Name,ArtistItems'
        }
        response = call_emby_api(f"Users/{scan_user_id}/Items", params, user_auth=temp_auth, timeout=(15, 180))
        
        if response and 'Items' in response:
            items = response['Items']
            if not items: break
            for item in items:
                artists = "/".join([a.get('Name', '') for a in item.get('ArtistItems', [])])
                scanned_songs.append({
                    'id': str(item.get('Id')),
                    'title': html.unescape(item.get('Name', '')),
                    'artist': html.unescape(artists)
                })
            logger.info(f"å·²æ‰«æ {len(scanned_songs)} é¦–æ­Œæ›²...")
            if len(items) < EMBY_SCAN_PAGE_SIZE: break
            start_index += EMBY_SCAN_PAGE_SIZE
        else:
            break
    
    emby_library_data = scanned_songs
    logger.info(f"æ‰«æå®Œæˆï¼Œå…± {len(emby_library_data)} é¦–æ­Œæ›²")
    
    if save_to_cache:
        try:
            with open(LIBRARY_CACHE_FILE, 'w', encoding='utf-8') as f:
                json.dump(emby_library_data, f, ensure_ascii=False)
        except Exception as e:
            logger.error(f"ä¿å­˜ç¼“å­˜å¤±è´¥: {e}")
    
    return emby_library_data


def get_user_emby_playlists(user_auth):
    if not user_auth: return []
    params = {'IncludeItemTypes': 'Playlist', 'Recursive': 'true', 'Fields': 'Id,Name'}
    response = call_emby_api(f"Users/{user_auth['user_id']}/Items", params, user_auth=user_auth)
    if response and 'Items' in response:
        return [{'id': p.get('Id'), 'name': p.get('Name')} for p in response['Items']]
    return []

def delete_emby_playlist(playlist_id, user_auth):
    return call_emby_api(f"Items/{playlist_id}", {}, method='DELETE', user_auth=user_auth) is not None


# ============================================================
# æ­Œå•è§£æ
# ============================================================

def parse_playlist_input(input_str: str):
    input_str = input_str.strip()
    url_match = re.search(r'https?://\S+', input_str)
    url = url_match.group(0) if url_match else input_str
    
    if '163cn.tv' in url or 'c6.y.qq.com' in url:
        url = _resolve_short_url(url)
    
    # ç½‘æ˜“äº‘
    for pattern in [r"music\.163\.com.*[?&/#]id=(\d+)", r"music\.163\.com/playlist/(\d+)"]:
        match = re.search(pattern, url)
        if match: return "netease", match.group(1)
    
    # QQéŸ³ä¹
    for pattern in [r"y\.qq\.com/n/ryqq/playlist/(\d+)", r"(?:y|i)\.qq\.com/.*?[?&](id|dissid)=(\d+)"]:
        match = re.search(pattern, url)
        if match:
            return "qq", match.group(2) if len(match.groups()) > 1 and match.group(2) else match.group(1)
    
    # Spotify
    for pattern in [r"open\.spotify\.com/playlist/([a-zA-Z0-9]+)", r"spotify:playlist:([a-zA-Z0-9]+)"]:
        match = re.search(pattern, url)
        if match: return "spotify", match.group(1)
    
    return None, None


def extract_playlist_id(playlist_url: str, platform: str) -> str:
    """ä»æ­Œå• URL ä¸­æå– ID"""
    playlist_type, playlist_id = parse_playlist_input(playlist_url)
    if playlist_type == platform or (platform == 'netease' and playlist_type == 'ncm'):
        return playlist_id
    return None

def get_qq_playlist_details(playlist_id):
    params = {'type': 1, 'utf8': 1, 'disstid': playlist_id, 'loginUin': 0}
    headers = {'Referer': 'https://y.qq.com/', 'User-Agent': 'Mozilla/5.0'}
    try:
        response = requests_session.get(QQ_API_GET_PLAYLIST_URL, params=params, headers=headers, timeout=(10, 15))
        response.raise_for_status()
        data = json.loads(strip_jsonp(response.text))
        if not data or 'cdlist' not in data or not data['cdlist']:
            return None, []
        playlist = data['cdlist'][0]
        name = html.unescape(playlist.get('dissname', f"QQæ­Œå•{playlist_id}"))
        songs = []
        for s in playlist.get('songlist', []):
            if s:
                artists = "/".join([a.get('name', '') for a in s.get('singer', [])])
                songs.append({
                    'source_id': str(s.get('songid') or s.get('id')),
                    'title': html.unescape(s.get('songname') or s.get('title', '')),
                    'artist': html.unescape(artists),
                    'platform': 'QQ'
                })
        return name, songs
    except Exception as e:
        logger.error(f"è·å– QQ æ­Œå•å¤±è´¥: {e}")
        return None, []

def get_ncm_playlist_details(playlist_id):
    headers = {'Referer': 'https://music.163.com/', 'User-Agent': 'Mozilla/5.0'}
    try:
        response = requests_session.get(NCM_API_PLAYLIST_DETAIL_URL, 
                                        params={'id': playlist_id, 'n': 100000},
                                        headers=headers, timeout=(10, 20))
        response.raise_for_status()
        data = response.json()
        playlist = data.get('playlist')
        if not playlist: return None, []
        
        name = html.unescape(playlist.get('name', f"ç½‘æ˜“äº‘æ­Œå•{playlist_id}"))
        track_ids = [str(t['id']) for t in playlist.get('trackIds', [])]
        
        songs = []
        for i in range(0, len(track_ids), 200):
            batch_ids = track_ids[i:i + 200]
            detail_response = requests_session.get(NCM_API_SONG_DETAIL_URL,
                                                   params={'ids': f"[{','.join(batch_ids)}]"},
                                                   headers=headers, timeout=(10, 15))
            detail_response.raise_for_status()
            for s in detail_response.json().get('songs', []):
                artist_list = s.get('ar') or s.get('artists') or []
                artists = "/".join([a.get('name', '') for a in artist_list])
                songs.append({
                    'source_id': str(s.get('id')),
                    'title': html.unescape(s.get('name', '')),
                    'artist': html.unescape(artists),
                    'platform': 'NCM'
                })
        return name, songs
    except Exception as e:
        logger.error(f"è·å–ç½‘æ˜“äº‘æ­Œå•å¤±è´¥: {e}")
        return None, []


def get_spotify_playlist_details(playlist_id: str):
    """
    è·å– Spotify æ­Œå•è¯¦æƒ…ï¼ˆé€šè¿‡ç½‘é¡µè§£æï¼Œæ— éœ€ API Keyï¼‰
    
    Args:
        playlist_id: Spotify æ­Œå• ID
        
    Returns:
        (æ­Œå•åç§°, æ­Œæ›²åˆ—è¡¨)
    """
    try:
        # ä½¿ç”¨ Spotify embed é¡µé¢è·å–æ­Œå•ä¿¡æ¯
        embed_url = f"https://open.spotify.com/embed/playlist/{playlist_id}"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
        }
        
        response = requests_session.get(embed_url, headers=headers, timeout=15)
        response.raise_for_status()
        
        # ä» HTML ä¸­æå– JSON æ•°æ®
        html_content = response.text
        
        # å°è¯•æ‰¾åˆ°æ­Œå•æ•°æ®
        import re
        
        # æ–¹æ³•1: æ‰¾ <script id="__NEXT_DATA__" 
        json_match = re.search(r'<script id="__NEXT_DATA__"[^>]*>(.*?)</script>', html_content, re.DOTALL)
        if json_match:
            try:
                data = json.loads(json_match.group(1))
                # è§£ææ­Œå•ä¿¡æ¯
                playlist_data = data.get('props', {}).get('pageProps', {})
                
                playlist_name = playlist_data.get('state', {}).get('data', {}).get('entity', {}).get('name', f'Spotify æ­Œå•')
                tracks_data = playlist_data.get('state', {}).get('data', {}).get('entity', {}).get('trackList', [])
                
                songs = []
                for track in tracks_data:
                    title = track.get('title', '')
                    artists = track.get('subtitle', '')  # Spotify embed ä¸­ subtitle æ˜¯è‰ºæœ¯å®¶
                    
                    if title:
                        songs.append({
                            'source_id': track.get('uri', ''),
                            'title': title,
                            'artist': artists,
                            'platform': 'Spotify'
                        })
                
                if songs:
                    logger.info(f"æˆåŠŸè·å– Spotify æ­Œå•: {playlist_name}, {len(songs)} é¦–æ­Œæ›²")
                    return playlist_name, songs
            except json.JSONDecodeError:
                pass
        
        # æ–¹æ³•2: ä½¿ç”¨ Spotify oembed API
        oembed_url = f"https://open.spotify.com/oembed?url=https://open.spotify.com/playlist/{playlist_id}"
        oembed_resp = requests_session.get(oembed_url, headers=headers, timeout=10)
        if oembed_resp.status_code == 200:
            oembed_data = oembed_resp.json()
            playlist_name = oembed_data.get('title', 'Spotify æ­Œå•')
            # oembed ä¸åŒ…å«æ­Œæ›²åˆ—è¡¨ï¼Œä½†è‡³å°‘èƒ½è·å–æ­Œå•åç§°
            logger.info(f"è·å–åˆ° Spotify æ­Œå•åç§°: {playlist_name}")
            
            # å°è¯•ä»ç½‘é¡µç‰ˆè·å–æ­Œæ›²åˆ—è¡¨
            web_url = f"https://open.spotify.com/playlist/{playlist_id}"
            web_resp = requests_session.get(web_url, headers=headers, timeout=15)
            
            # ä½¿ç”¨æ­£åˆ™æå–æ­Œæ›²ä¿¡æ¯
            # Spotify ç½‘é¡µä¸­æ­Œæ›²é€šå¸¸åœ¨ data-testid="tracklist-row" å…ƒç´ ä¸­
            track_pattern = r'"name":"([^"]+)"[^}]*"artists":\[(\{[^]]+\})\]'
            matches = re.findall(track_pattern, web_resp.text)
            
            songs = []
            seen = set()
            for title, artists_json in matches:
                try:
                    # è§£æè‰ºæœ¯å®¶
                    artist_names = re.findall(r'"name":"([^"]+)"', artists_json)
                    artist = '/'.join(artist_names) if artist_names else ''
                    
                    key = f"{title}|{artist}"
                    if key not in seen and title:
                        seen.add(key)
                        songs.append({
                            'source_id': '',
                            'title': html.unescape(title),
                            'artist': html.unescape(artist),
                            'platform': 'Spotify'
                        })
                except:
                    continue
            
            if songs:
                logger.info(f"ä» Spotify ç½‘é¡µè§£æåˆ° {len(songs)} é¦–æ­Œæ›²")
                return playlist_name, songs
        
        logger.warning(f"æ— æ³•è§£æ Spotify æ­Œå•: {playlist_id}")
        return None, []
        
    except Exception as e:
        logger.error(f"è·å– Spotify æ­Œå•å¤±è´¥: {e}")
        return None, []


# ============================================================
# åŒ¹é…é€»è¾‘
# ============================================================

def find_best_match(source_track, candidates, match_mode):
    if not candidates: return None
    source_title = source_track.get('title', '').strip()
    source_artist = source_track.get('artist', '').strip()
    
    if match_mode == "å®Œå…¨åŒ¹é…":
        source_artists_norm = sorted(list(_normalize_artists(source_artist)))
        for track in candidates:
            if source_title == track.get('title', '').strip():
                track_artists_norm = sorted(list(_normalize_artists(track.get('artist', ''))))
                if source_artists_norm == track_artists_norm:
                    return track
        return None
    
    # æ¨¡ç³ŠåŒ¹é…
    best_match, best_score = None, -1
    source_title_lower = source_title.lower()
    source_artists_norm = _normalize_artists(source_artist)
    
    for track in candidates:
        track_title_lower = track.get('title', '').lower()
        title_sim = fuzz.ratio(source_title_lower, track_title_lower)
        
        title_pts = 10 if title_sim >= 95 else (8 if title_sim >= 88 else (5 if title_sim >= 75 else 0))
        
        track_artists_norm = _normalize_artists(track.get('artist', ''))
        artist_pts = 0
        if source_artists_norm and track_artists_norm:
            if source_artists_norm == track_artists_norm: artist_pts = 5
            elif source_artists_norm.issubset(track_artists_norm) or track_artists_norm.issubset(source_artists_norm): artist_pts = 4
            elif source_artists_norm.intersection(track_artists_norm): artist_pts = 2
        
        score = title_pts + artist_pts
        if score > best_score:
            best_match, best_score = track, score
    
    return best_match if best_score >= MATCH_THRESHOLD else None


def process_playlist(playlist_url, user_id=None, force_public=False, user_binding=None, match_mode="æ¨¡ç³ŠåŒ¹é…"):
    playlist_type, playlist_id = parse_playlist_input(playlist_url)
    async def check_playlist_updates(app):
        """æ ¹æ®å„è‡ªé—´éš”æ£€æŸ¥æ­Œå•æ›´æ–°å¹¶åŒæ­¥æ–°æ­Œæ›²"""
        playlists = get_scheduled_playlists()
        if not playlists:
            logger.debug("æ²¡æœ‰è®¢é˜…æ­Œå•ï¼Œè·³è¿‡åŒæ­¥æ£€æŸ¥")
            return
        default_interval = get_playlist_sync_interval()
        now = dt.datetime.utcnow()
        due_found = False
        for playlist in playlists:
            try:
                if not playlist.get('is_active', 1):
                    continue
                interval = playlist.get('sync_interval') or default_interval
                interval = max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, interval)
                last_sync_at = _parse_db_timestamp(playlist.get('last_sync_at'))
                if last_sync_at:
                    elapsed_minutes = (now - last_sync_at).total_seconds() / 60
                    if elapsed_minutes < 0:
                        elapsed_minutes = interval
                    if elapsed_minutes < interval:
                        continue
                due_found = True
                telegram_id = playlist['telegram_id']
                playlist_url = playlist['playlist_url']
                platform = playlist['platform']
                old_song_ids = set(str(sid) for sid in playlist['last_song_ids'])
            
                # è·å–æ­Œå•æœ€æ–°æ­Œæ›²
                playlist_name = playlist.get('playlist_name') or 'æœªçŸ¥æ­Œå•'
                songs = []
                remote_name = None
                if platform == 'netease':
                    playlist_id = extract_playlist_id(playlist_url, 'netease')
                    if not playlist_id:
                        logger.warning(f"æ— æ³•è§£æç½‘æ˜“äº‘æ­Œå•é“¾æ¥: {playlist_url}")
                        continue
                    remote_name, songs = get_ncm_playlist_details(playlist_id)
                elif platform == 'qq':
                    playlist_id = extract_playlist_id(playlist_url, 'qq')
                    if not playlist_id:
                        logger.warning(f"æ— æ³•è§£æ QQ æ­Œå•é“¾æ¥: {playlist_url}")
                        continue
                    remote_name, songs = get_qq_playlist_details(playlist_id)
                else:
                    logger.debug(f"æš‚ä¸æ”¯æŒçš„å¹³å° {platform}")
                    continue
                if remote_name:
                    playlist_name = remote_name
                if not songs:
                    logger.debug(f"{playlist_name} æ— å¯ç”¨æ­Œæ›²ï¼Œè·³è¿‡")
                    continue
            
                # è®¡ç®—æ–°å¢æ­Œæ›²
                current_song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
                new_songs = [s for s in songs if str(s.get('source_id') or s.get('id') or s.get('title', '')) not in old_song_ids]
            
                if new_songs:
                    logger.info(f"æ­Œå• '{playlist_name}' å‘ç° {len(new_songs)} é¦–æ–°æ­Œæ›² (é—´éš” {interval} åˆ†é’Ÿ)")
                    try:
                        message = f"ğŸ”” **æ­Œå•æ›´æ–°é€šçŸ¥**\n\n"
                        message += f"ğŸ“‹ æ­Œå•: `{playlist_name}`\n"
                        message += f"ğŸ†• æ–°å¢: {len(new_songs)} é¦–æ­Œæ›²\n\n"
                        for i, s in enumerate(new_songs[:5]):
                            message += f"{i+1}. {s['title']} - {s['artist']}\n"
                        if len(new_songs) > 5:
                            message += f"... è¿˜æœ‰ {len(new_songs) - 5} é¦–\n"
                        keyboard = [[
                            InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{playlist['id']}"),
                            InlineKeyboardButton("ğŸ”„ åŒæ­¥åˆ°Emby", callback_data=f"sync_emby_{playlist['id']}")
                        ]]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await app.bot.send_message(
                            chat_id=int(telegram_id),
                            text=message,
                            parse_mode='Markdown',
                            reply_markup=reply_markup
                        )
                    except Exception as e:
                        logger.error(f"å‘é€æ­Œå•æ›´æ–°é€šçŸ¥å¤±è´¥: {e}")
                else:
                    logger.debug(f"æ­Œå• '{playlist_name}' æœªå‘ç°æ–°æ­Œæ›²")
                # æ— è®ºæ˜¯å¦æœ‰æ–°æ­Œï¼Œåªè¦æ‹‰å–æˆåŠŸå°±æ›´æ–°åŒæ­¥æ—¶é—´
                update_scheduled_playlist_songs(playlist['id'], current_song_ids, playlist_name)
            except Exception as e:
                logger.error(f"æ£€æŸ¥æ­Œå• '{playlist.get('playlist_name', '')}' æ›´æ–°å¤±è´¥: {e}")
        if not due_found:
            logger.debug("æ²¡æœ‰åˆ°è¾¾åŒæ­¥é—´éš”çš„æ­Œå•ï¼Œç­‰å¾…ä¸‹ä¸€ä¸ªå‘¨æœŸ")
        time.sleep(0.3)
    
    # è®°å½•åˆ°æ•°æ®åº“
    save_playlist_record(user_id, source_name, playlist_type, len(source_songs), len(matched_ids))
    
    result = {
        'name': source_name,
        'total': len(source_songs),
        'matched': len(matched_ids),
        'unmatched': len(unmatched),
        'unmatched_songs': unmatched[:15],  # æ˜¾ç¤ºå‰15é¦–
        'all_unmatched': unmatched,  # ä¿å­˜æ‰€æœ‰æœªåŒ¹é…æ­Œæ›²ç”¨äºä¸‹è½½
        'mode': match_mode
    }
    return result, None


# ============================================================
# æ•°æ®åº“æ“ä½œ
# ============================================================

def init_database():
    global database_conn
    database_conn = sqlite3.connect(str(DATABASE_FILE), check_same_thread=False)
    database_conn.row_factory = sqlite3.Row  # è®©æŸ¥è¯¢ç»“æœå¯ä»¥ç”¨å­—å…¸æ–¹å¼è®¿é—®
    cursor = database_conn.cursor()
    
    # ç”¨æˆ·ç»‘å®šè¡¨
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_bindings (
            telegram_id TEXT PRIMARY KEY,
            emby_username TEXT NOT NULL,
            emby_password TEXT NOT NULL,
            emby_user_id TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # æ­Œå•åŒæ­¥è®°å½•
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS playlist_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id TEXT,
            playlist_name TEXT,
            platform TEXT,
            total_songs INTEGER,
            matched_songs INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # ä¸Šä¼ è®°å½•
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS upload_records (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id TEXT,
            original_name TEXT,
            saved_name TEXT,
            file_size INTEGER,
            status TEXT DEFAULT 'completed',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # å®šæ—¶åŒæ­¥æ­Œå•
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS scheduled_playlists (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            telegram_id TEXT NOT NULL,
            playlist_url TEXT NOT NULL,
            playlist_name TEXT,
            platform TEXT,
            last_song_ids TEXT,
            last_sync_at TIMESTAMP,
            is_active INTEGER DEFAULT 1,
            sync_interval INTEGER DEFAULT 6,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(telegram_id, playlist_url)
        )
    ''')
    
    # æ·»åŠ  is_active å­—æ®µï¼ˆå…¼å®¹æ—§æ•°æ®åº“ï¼‰
    try:
        cursor.execute('ALTER TABLE scheduled_playlists ADD COLUMN is_active INTEGER DEFAULT 1')
    except:
        pass  # å­—æ®µå·²å­˜åœ¨
    
    # æ·»åŠ  sync_interval å­—æ®µï¼ˆå…¼å®¹æ—§æ•°æ®åº“ï¼‰
    try:
        cursor.execute('ALTER TABLE scheduled_playlists ADD COLUMN sync_interval INTEGER DEFAULT 6')
    except:
        pass  # å­—æ®µå·²å­˜åœ¨
    
    database_conn.commit()
    logger.info(f"æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ: {DATABASE_FILE}")

def get_user_binding(telegram_id):
    if not database_conn: return None
    cursor = database_conn.cursor()
    cursor.execute('SELECT emby_username, emby_password, emby_user_id FROM user_bindings WHERE telegram_id = ?',
                  (str(telegram_id),))
    result = cursor.fetchone()
    if result:
        try:
            return {'emby_username': result[0], 'emby_password': decrypt_password(result[1]), 'emby_user_id': result[2]}
        except:
            return None
    return None

def save_user_binding(telegram_id, emby_username, emby_password, emby_user_id=None):
    if not database_conn: return False
    try:
        cursor = database_conn.cursor()
        cursor.execute('INSERT OR REPLACE INTO user_bindings VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)',
                      (str(telegram_id), emby_username, encrypt_password(emby_password), emby_user_id))
        database_conn.commit()
        return True
    except:
        return False

def delete_user_binding(telegram_id):
    if not database_conn: return False
    try:
        cursor = database_conn.cursor()
        cursor.execute('DELETE FROM user_bindings WHERE telegram_id = ?', (str(telegram_id),))
        database_conn.commit()
        return True
    except:
        return False

def save_playlist_record(telegram_id, name, platform, total, matched):
    if not database_conn: return
    try:
        cursor = database_conn.cursor()
        cursor.execute('INSERT INTO playlist_records (telegram_id, playlist_name, platform, total_songs, matched_songs) VALUES (?, ?, ?, ?, ?)',
                      (str(telegram_id), name, platform, total, matched))
        database_conn.commit()
    except:
        pass

def save_upload_record(telegram_id, original_name, saved_name, file_size):
    if not database_conn: return
    try:
        cursor = database_conn.cursor()
        cursor.execute('INSERT INTO upload_records (telegram_id, original_name, saved_name, file_size) VALUES (?, ?, ?, ?)',
                      (str(telegram_id), original_name, saved_name, file_size))
        database_conn.commit()
    except:
        pass


def save_download_record(songs: list, success_files: list, failed_songs: list, 
                         platform: str, quality: str, user_id: str = None):
    """ä¿å­˜ä¸‹è½½è®°å½•åˆ°å†å²è¡¨"""
    if not database_conn:
        return
    try:
        cursor = database_conn.cursor()
        
        # ç¡®ä¿è¡¨å­˜åœ¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS download_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id TEXT,
                song_id TEXT,
                title TEXT,
                artist TEXT,
                platform TEXT,
                quality TEXT,
                status TEXT,
                file_path TEXT,
                file_size INTEGER DEFAULT 0,
                duration REAL DEFAULT 0,
                error_message TEXT,
                user_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        import uuid
        
        # è®°å½•æˆåŠŸçš„ä¸‹è½½
        for i, file_path in enumerate(success_files):
            song = songs[i] if i < len(songs) else {}
            
            # è·å–æ–‡ä»¶å¤§å°
            file_size = 0
            if file_path:
                try:
                    p = Path(file_path)
                    if p.exists():
                        file_size = p.stat().st_size
                        logger.debug(f"è·å–æ–‡ä»¶å¤§å°æˆåŠŸ: {file_size} bytes")
                    else:
                        logger.warning(f"ä¿å­˜ä¸‹è½½è®°å½•æ—¶æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
                except Exception as e:
                    logger.warning(f"è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {e}")
            
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, file_path, file_size, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', '')),
                song.get('title', Path(file_path).stem if file_path else ''),
                song.get('artist', ''),
                platform,
                quality,
                'completed',
                file_path,
                file_size,
                user_id
            ))
        
        # è®°å½•å¤±è´¥çš„ä¸‹è½½
        for song in failed_songs:
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, error_message, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', '')),
                song.get('title', ''),
                song.get('artist', ''),
                platform,
                quality,
                'failed',
                song.get('error', 'ä¸‹è½½å¤±è´¥'),
                user_id
            ))
        
        database_conn.commit()
        logger.debug(f"ä¿å­˜ä¸‹è½½è®°å½•: {len(success_files)} æˆåŠŸ, {len(failed_songs)} å¤±è´¥")
    except Exception as e:
        logger.error(f"ä¿å­˜ä¸‹è½½è®°å½•å¤±è´¥: {e}")


def save_download_record_v2(success_results: list, failed_songs: list, 
                            quality: str, user_id: str = None):
    """ä¿å­˜ä¸‹è½½è®°å½•åˆ°å†å²è¡¨ï¼ˆæ”¯æŒæŒ‰å®é™…å¹³å°è®°å½•ï¼‰
    
    Args:
        success_results: [{'file': path, 'platform': 'NCM'/'QQ', 'song': song_info}, ...]
        failed_songs: å¤±è´¥çš„æ­Œæ›²åˆ—è¡¨
        quality: ä¸‹è½½éŸ³è´¨
        user_id: ç”¨æˆ·ID
    """
    if not database_conn:
        return
    try:
        cursor = database_conn.cursor()
        
        # ç¡®ä¿è¡¨å­˜åœ¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS download_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_id TEXT,
                song_id TEXT,
                title TEXT,
                artist TEXT,
                platform TEXT,
                quality TEXT,
                status TEXT,
                file_path TEXT,
                file_size INTEGER DEFAULT 0,
                duration REAL DEFAULT 0,
                error_message TEXT,
                user_id TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        import uuid
        
        # è®°å½•æˆåŠŸçš„ä¸‹è½½ï¼ˆæŒ‰å®é™…ä¸‹è½½å¹³å°ï¼‰
        for result in success_results:
            file_path = result.get('file', '')
            platform = result.get('platform', 'NCM')
            song = result.get('song', {})
            
            # ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ file_sizeï¼ˆåœ¨ä¸‹è½½æ—¶ç«‹å³è·å–çš„ï¼‰ï¼Œé¿å…æ–‡ä»¶è¢«å¤–éƒ¨ç¨‹åºç§»èµ°åæ— æ³•è·å–
            file_size = result.get('file_size', 0)
            
            # å¦‚æœæ²¡æœ‰é¢„å…ˆè·å–çš„å¤§å°ï¼Œå°è¯•ä»æ–‡ä»¶è·å–
            if not file_size and file_path:
                try:
                    p = Path(file_path)
                    if p.exists():
                        file_size = p.stat().st_size
                        logger.debug(f"è·å–æ–‡ä»¶å¤§å°æˆåŠŸ: {file_size} bytes, è·¯å¾„: {file_path}")
                    else:
                        logger.warning(f"ä¿å­˜ä¸‹è½½è®°å½•æ—¶æ–‡ä»¶ä¸å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«å¤–éƒ¨ç¨‹åºç§»èµ°ï¼‰: {file_path}")
                except Exception as e:
                    logger.warning(f"è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {e}, è·¯å¾„: {file_path}")
            
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, file_path, file_size, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', song.get('source_id', ''))),
                song.get('title', Path(file_path).stem if file_path else ''),
                song.get('artist', ''),
                platform,
                quality,
                'completed',
                file_path,
                file_size,
                user_id
            ))
        
        # è®°å½•å¤±è´¥çš„ä¸‹è½½
        for song in failed_songs:
            cursor.execute('''
                INSERT INTO download_history 
                (task_id, song_id, title, artist, platform, quality, status, error_message, user_id)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                str(uuid.uuid4())[:8],
                str(song.get('id', song.get('source_id', ''))),
                song.get('title', ''),
                song.get('artist', ''),
                song.get('platform', 'NCM'),  # å¤±è´¥çš„è®°å½•åŸå§‹å¹³å°
                quality,
                'failed',
                song.get('error', 'ä¸‹è½½å¤±è´¥'),
                user_id
            ))
        
        database_conn.commit()
        
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        logger.debug(f"ä¿å­˜ä¸‹è½½è®°å½•: NCM {ncm_count} é¦–, QQ {qq_count} é¦–, å¤±è´¥ {len(failed_songs)} é¦–")
    except Exception as e:
        logger.error(f"ä¿å­˜ä¸‹è½½è®°å½•å¤±è´¥: {e}")


# ============================================================
# å®šæ—¶åŒæ­¥æ­Œå•
# ============================================================

DEFAULT_PLAYLIST_SYNC_INTERVAL_MINUTES = max(1, int(os.environ.get('PLAYLIST_SYNC_INTERVAL', os.environ.get('PLAYLIST_SYNC_INTERVAL_MINUTES', '360'))))
MIN_PLAYLIST_SYNC_INTERVAL_MINUTES = max(1, int(os.environ.get('PLAYLIST_SYNC_MIN_INTERVAL', '1')))
PLAYLIST_SYNC_POLL_INTERVAL_SECONDS = max(30, int(os.environ.get('PLAYLIST_SYNC_POLL_INTERVAL', '60')))
PLAYLIST_SYNC_INITIAL_DELAY_SECONDS = max(0, int(os.environ.get('PLAYLIST_SYNC_INITIAL_DELAY', '10')))


def _parse_db_timestamp(value):
    if not value:
        return None
    value = value.strip()
    if not value:
        return None
    # å¸¸è§æ ¼å¼ï¼š"2024-07-12 06:30:00" æˆ– ISO8601
    for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%dT%H:%M:%S.%f"):
        try:
            return dt.datetime.strptime(value, fmt)
        except ValueError:
            continue
    try:
        normalized = value.replace('Z', '+00:00')
        return dt.datetime.fromisoformat(normalized)
    except Exception:
        logger.debug(f"æ— æ³•è§£ææ—¶é—´æˆ³: {value}")
        return None


def get_playlist_sync_interval():
    """è·å–å…¨å±€é»˜è®¤æ­Œå•åŒæ­¥é—´éš”ï¼ˆå•ä½ï¼šåˆ†é’Ÿï¼‰"""
    default_interval = max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, DEFAULT_PLAYLIST_SYNC_INTERVAL_MINUTES)
    if not database_conn:
        return default_interval
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS bot_settings (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('playlist_sync_interval',))
        row = cursor.fetchone()
        if row:
            raw_value = row[0] if isinstance(row, tuple) else row['value']
            try:
                interval = int(raw_value)
                return max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, interval)
            except ValueError:
                logger.warning(f"æ— æ•ˆçš„ playlist_sync_interval é…ç½®: {raw_value}")
        return default_interval
    except Exception as e:
        logger.error(f"è¯»å–é»˜è®¤æ­Œå•åŒæ­¥é—´éš”å¤±è´¥: {e}")
        return default_interval

def add_scheduled_playlist(telegram_id: str, playlist_url: str, playlist_name: str, platform: str, song_ids: list):
    """æ·»åŠ å®šæ—¶åŒæ­¥æ­Œå•"""
    if not database_conn:
        return False
    try:
        cursor = database_conn.cursor()
        song_ids_json = json.dumps(song_ids)
        default_interval = get_playlist_sync_interval()
        cursor.execute('''
            INSERT INTO scheduled_playlists 
            (telegram_id, playlist_url, playlist_name, platform, last_song_ids, last_sync_at, sync_interval, is_active)
            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, ?, 1)
            ON CONFLICT(telegram_id, playlist_url) DO UPDATE SET
                playlist_name=excluded.playlist_name,
                platform=excluded.platform,
                last_song_ids=excluded.last_song_ids,
                last_sync_at=excluded.last_sync_at,
                is_active=1,
                sync_interval=CASE
                    WHEN scheduled_playlists.sync_interval IS NULL OR scheduled_playlists.sync_interval < 1
                        THEN excluded.sync_interval
                    ELSE scheduled_playlists.sync_interval
                END
        ''', (str(telegram_id), playlist_url, playlist_name, platform, song_ids_json, default_interval))
        database_conn.commit()
        return True
    except Exception as e:
        logger.error(f"æ·»åŠ å®šæ—¶åŒæ­¥æ­Œå•å¤±è´¥: {e}")
        return False

def get_scheduled_playlists(telegram_id: str = None):
    """è·å–å®šæ—¶åŒæ­¥æ­Œå•åˆ—è¡¨"""
    if not database_conn:
        return []
    try:
        cursor = database_conn.cursor()
        if telegram_id:
            cursor.execute('''
                SELECT id, telegram_id, playlist_url, playlist_name, platform,
                       last_song_ids, last_sync_at, sync_interval, is_active
                FROM scheduled_playlists WHERE telegram_id = ? ORDER BY created_at DESC
            ''', (str(telegram_id),))
        else:
            cursor.execute('''
                SELECT id, telegram_id, playlist_url, playlist_name, platform,
                       last_song_ids, last_sync_at, sync_interval, is_active
                FROM scheduled_playlists ORDER BY created_at DESC
            ''')
        rows = cursor.fetchall()
        playlists = []
        for row in rows:
            last_song_ids = []
            try:
                last_song_ids = json.loads(row['last_song_ids']) if row['last_song_ids'] else []
            except Exception:
                logger.debug(f"æ— æ³•è§£æ last_song_ids: {row['last_song_ids']}")
            playlists.append({
                'id': row['id'],
                'telegram_id': row['telegram_id'],
                'playlist_url': row['playlist_url'],
                'playlist_name': row['playlist_name'],
                'platform': row['platform'],
                'last_song_ids': last_song_ids,
                'last_sync_at': row['last_sync_at'],
                'sync_interval': row['sync_interval'],
                'is_active': row['is_active'] if row['is_active'] is not None else 1
            })
        return playlists
    except Exception as e:
        logger.error(f"è·å–å®šæ—¶åŒæ­¥æ­Œå•å¤±è´¥: {e}")
        return []

def delete_scheduled_playlist(playlist_id: int, telegram_id: str = None):
    """åˆ é™¤å®šæ—¶åŒæ­¥æ­Œå•"""
    if not database_conn:
        return False
    try:
        cursor = database_conn.cursor()
        if telegram_id:
            cursor.execute('DELETE FROM scheduled_playlists WHERE id = ? AND telegram_id = ?', 
                          (playlist_id, str(telegram_id)))
        else:
            cursor.execute('DELETE FROM scheduled_playlists WHERE id = ?', (playlist_id,))
        database_conn.commit()
        return cursor.rowcount > 0
    except:
        return False

def update_scheduled_playlist_songs(playlist_id: int, song_ids: list, playlist_name: str = None):
    """æ›´æ–°æ­Œå•çš„æ­Œæ›²åˆ—è¡¨åŠæœ€ååŒæ­¥æ—¶é—´"""
    if not database_conn:
        return False
    try:
        cursor = database_conn.cursor()
        song_ids_json = json.dumps(song_ids)
        fields = ['last_song_ids = ?', 'last_sync_at = CURRENT_TIMESTAMP']
        params = [song_ids_json]
        if playlist_name:
            fields.append('playlist_name = ?')
            params.append(playlist_name)
        params.append(playlist_id)
        cursor.execute(f"""
            UPDATE scheduled_playlists SET {', '.join(fields)}
            WHERE id = ?
        """, params)
        database_conn.commit()
        return True
    except Exception as e:
        logger.error(f"æ›´æ–°æ­Œå• {playlist_id} å¤±è´¥: {e}")
        return False


async def check_playlist_updates(app):
    """æ£€æŸ¥æ­Œå•æ›´æ–°å¹¶åŒæ­¥æ–°æ­Œæ›²"""
    logger.info("å¼€å§‹æ£€æŸ¥æ­Œå•æ›´æ–°...")
    
    playlists = get_scheduled_playlists()
    if not playlists:
        return
    
    for playlist in playlists:
        try:
            telegram_id = playlist['telegram_id']
            playlist_url = playlist['playlist_url']
            platform = playlist['platform']
            old_song_ids = set(playlist['last_song_ids'])
            
            # è·å–æ­Œå•æœ€æ–°æ­Œæ›²
            if platform == 'netease':
                playlist_id = extract_playlist_id(playlist_url, 'netease')
                if not playlist_id:
                    continue
                playlist_name, songs = get_ncm_playlist_details(playlist_id)
            elif platform == 'qq':
                playlist_id = extract_playlist_id(playlist_url, 'qq')
                if not playlist_id:
                    continue
                playlist_name, songs = get_qq_playlist_details(playlist_id)
            else:
                continue
            
            if not songs:
                continue
            
            # è®¡ç®—æ–°å¢æ­Œæ›²
            current_song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
            new_songs = [s for s in songs if str(s.get('source_id') or s.get('id') or s.get('title', '')) not in old_song_ids]
            
            if new_songs:
                logger.info(f"æ­Œå• '{playlist['playlist_name']}' å‘ç° {len(new_songs)} é¦–æ–°æ­Œæ›²")
                
                # å‘é€é€šçŸ¥
                try:
                    message = f"ğŸ”” **æ­Œå•æ›´æ–°é€šçŸ¥**\n\n"
                    message += f"ğŸ“‹ æ­Œå•: `{playlist['playlist_name']}`\n"
                    message += f"ğŸ†• æ–°å¢: {len(new_songs)} é¦–æ­Œæ›²\n\n"
                    for i, s in enumerate(new_songs[:5]):
                        message += f"{i+1}. {s['title']} - {s['artist']}\n"
                    if len(new_songs) > 5:
                        message += f"... è¿˜æœ‰ {len(new_songs) - 5} é¦–\n"
                    
                    # æ·»åŠ ä¸‹è½½æŒ‰é’®
                    keyboard = [
                        [
                            InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{playlist['id']}"),
                            InlineKeyboardButton("ğŸ”„ åŒæ­¥åˆ°Emby", callback_data=f"sync_emby_{playlist['id']}")
                        ]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    await app.bot.send_message(
                        chat_id=int(telegram_id),
                        text=message,
                        parse_mode='Markdown',
                        reply_markup=reply_markup
                    )
                except Exception as e:
                    logger.error(f"å‘é€æ­Œå•æ›´æ–°é€šçŸ¥å¤±è´¥: {e}")
            
            # æ›´æ–°æ­Œæ›²åˆ—è¡¨
            update_scheduled_playlist_songs(playlist['id'], current_song_ids)
            
        except Exception as e:
            logger.error(f"æ£€æŸ¥æ­Œå• '{playlist.get('playlist_name', '')}' æ›´æ–°å¤±è´¥: {e}")
    
    logger.info("æ­Œå•æ›´æ–°æ£€æŸ¥å®Œæˆ")


async def scheduled_sync_job(app):
    """åå°è½®è¯¢æ­Œå•åŒæ­¥ä»»åŠ¡"""
    poll_interval = PLAYLIST_SYNC_POLL_INTERVAL_SECONDS
    initial_delay = PLAYLIST_SYNC_INITIAL_DELAY_SECONDS
    if initial_delay:
        await asyncio.sleep(initial_delay)
    logger.info(
        f"æ­Œå•åŒæ­¥ä»»åŠ¡å·²å¯åŠ¨ (é»˜è®¤ {get_playlist_sync_interval()} åˆ†é’Ÿ / è½®è¯¢ {poll_interval} ç§’)"
    )
    while True:
        try:
            await check_playlist_updates(app)
        except asyncio.CancelledError:
            logger.info("æ­Œå•åŒæ­¥ä»»åŠ¡å·²å–æ¶ˆ")
            break
        except Exception as e:
            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å‡ºé”™: {e}")
        await asyncio.sleep(poll_interval)


async def scheduled_emby_scan_job(app):
    """å®šæ—¶æ‰«æ Emby åª’ä½“åº“"""
    # è·å–æ‰«æé—´éš”ï¼ˆä¼˜å…ˆæ•°æ®åº“é…ç½®ï¼‰
    def get_scan_interval():
        try:
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                row = cursor.fetchone()
                if row:
                    return int(row[0] if isinstance(row, tuple) else row['value'])
        except:
            pass
        return EMBY_SCAN_INTERVAL
    
    while True:
        try:
            interval = get_scan_interval()
            if interval <= 0:
                # ç¦ç”¨å®šæ—¶æ‰«æï¼Œæ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡é…ç½®æ˜¯å¦å˜åŒ–
                await asyncio.sleep(60 * 60)
                continue
            
            # ç­‰å¾…æŒ‡å®šæ—¶é—´
            await asyncio.sleep(interval * 60 * 60)
            
            # æ‰§è¡Œæ‰«æ
            logger.info("å¼€å§‹å®šæ—¶æ‰«æ Emby åª’ä½“åº“...")
            if emby_auth.get('access_token'):
                old_count = len(emby_library_data)
                scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
                new_count = len(emby_library_data)
                
                if new_count != old_count:
                    logger.info(f"Emby åª’ä½“åº“æ›´æ–°: {old_count} -> {new_count} é¦–")
                    # é€šçŸ¥æ‰€æœ‰ç®¡ç†å‘˜
                    for admin_id in ADMIN_USER_IDS:
                        try:
                            await app.bot.send_message(
                                chat_id=admin_id,
                                text=f"ğŸ”„ Emby åª’ä½“åº“å·²è‡ªåŠ¨æ›´æ–°\n\n"
                                     f"ğŸ“Š æ­Œæ›²æ•°é‡: {old_count} â†’ {new_count}\n"
                                     f"ğŸ“ˆ å˜åŒ–: {'+' if new_count > old_count else ''}{new_count - old_count}"
                            )
                        except:
                            pass
                else:
                    logger.info(f"Emby åª’ä½“åº“æ— å˜åŒ–: {new_count} é¦–")
            else:
                logger.warning("Emby æœªè®¤è¯ï¼Œè·³è¿‡å®šæ—¶æ‰«æ")
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"å®šæ—¶æ‰«æ Emby å‡ºé”™: {e}")
            await asyncio.sleep(60)

def get_ncm_settings():
    """è·å–ç½‘æ˜“äº‘ä¸‹è½½è®¾ç½®ï¼ˆä¼˜å…ˆä»æ•°æ®åº“è¯»å–ï¼Œå¦åˆ™ä»ç¯å¢ƒå˜é‡ï¼‰"""
    default_settings = {
        'ncm_quality': os.environ.get('NCM_QUALITY', 'exhigh'),
        'auto_download': os.environ.get('AUTO_DOWNLOAD', 'false').lower() == 'true',
        'download_mode': 'local',
        'download_dir': str(MUSIC_TARGET_DIR),
        'musictag_dir': '',
        'organize_dir': ''
    }
    
    if not database_conn:
        return default_settings
    
    try:
        cursor = database_conn.cursor()
        
        # ç¡®ä¿è®¾ç½®è¡¨å­˜åœ¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS bot_settings (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('ncm_quality',))
        row = cursor.fetchone()
        ncm_quality = row[0] if row else default_settings['ncm_quality']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('auto_download',))
        row = cursor.fetchone()
        auto_download = row[0] == 'true' if row else default_settings['auto_download']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('download_mode',))
        row = cursor.fetchone()
        download_mode = row[0] if row else default_settings['download_mode']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('download_dir',))
        row = cursor.fetchone()
        download_dir = row[0] if row else default_settings['download_dir']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('musictag_dir',))
        row = cursor.fetchone()
        musictag_dir = row[0] if row else default_settings['musictag_dir']
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_dir',))
        row = cursor.fetchone()
        organize_dir = row[0] if row else default_settings['organize_dir']
        
        return {
            'ncm_quality': ncm_quality,
            'auto_download': auto_download,
            'download_mode': download_mode,
            'download_dir': download_dir,
            'musictag_dir': musictag_dir,
            'organize_dir': organize_dir
        }
    except:
        return default_settings

def get_stats():
    """è·å–ç»Ÿè®¡æ•°æ®"""
    if not database_conn: return {}
    cursor = database_conn.cursor()
    
    cursor.execute('SELECT COUNT(*) FROM user_bindings')
    users = cursor.fetchone()[0]
    
    cursor.execute('SELECT COUNT(*), SUM(matched_songs) FROM playlist_records')
    row = cursor.fetchone()
    playlists, songs_synced = row[0] or 0, row[1] or 0
    
    cursor.execute('SELECT COUNT(*), SUM(file_size) FROM upload_records')
    row = cursor.fetchone()
    uploads, upload_size = row[0] or 0, row[1] or 0
    
    return {
        'users': users,
        'playlists': playlists,
        'songs_synced': songs_synced,
        'uploads': uploads,
        'upload_size': upload_size,
        'library_songs': len(emby_library_data)
    }

def get_recent_records(limit=20):
    """è·å–æœ€è¿‘è®°å½•"""
    if not database_conn: return [], []
    cursor = database_conn.cursor()
    
    cursor.execute('SELECT playlist_name, platform, total_songs, matched_songs, created_at FROM playlist_records ORDER BY created_at DESC LIMIT ?', (limit,))
    playlists = cursor.fetchall()
    
    cursor.execute('SELECT original_name, saved_name, file_size, created_at FROM upload_records ORDER BY created_at DESC LIMIT ?', (limit,))
    uploads = cursor.fetchall()
    
    return playlists, uploads


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - ä¸»èœå•
# ============================================================

def get_main_menu_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ“‹ æ­Œå•åŒæ­¥", callback_data="menu_playlist"),
         InlineKeyboardButton("ğŸ“¤ éŸ³ä¹ä¸Šä¼ ", callback_data="menu_upload")],
        [InlineKeyboardButton("âš™ï¸ è®¾ç½®", callback_data="menu_settings"),
         InlineKeyboardButton("ğŸ“Š çŠ¶æ€", callback_data="menu_status")]
    ])

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    binding = get_user_binding(user_id)
    
    welcome = f"ğŸ‘‹ æ¬¢è¿ä½¿ç”¨ **{APP_NAME}**ï¼\n\n"
    if binding:
        welcome += f"å·²ç»‘å®š Emby: `{binding['emby_username']}`\n\n"
    else:
        welcome += "âš ï¸ å°šæœªç»‘å®š Emby è´¦æˆ·\n\n"
    welcome += "è¯·é€‰æ‹©åŠŸèƒ½ï¼š"
    
    await update.message.reply_text(welcome, reply_markup=get_main_menu_keyboard(), parse_mode='Markdown')

async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
**ğŸ“– TGmusicbot ä½¿ç”¨å¸®åŠ©**

**ğŸµ æ­Œå•åŒæ­¥ï¼š** ç›´æ¥å‘é€æ­Œå•é“¾æ¥
**ğŸ“¤ ä¸Šä¼ éŸ³ä¹ï¼š** ç›´æ¥å‘é€éŸ³é¢‘æ–‡ä»¶

**ğŸ“‹ æœç´¢ä¸‹è½½ï¼š**
`/ss å…³é”®è¯` - ç½‘æ˜“äº‘æœç´¢æ­Œæ›²
`/al ä¸“è¾‘å` - ç½‘æ˜“äº‘æœç´¢ä¸“è¾‘
`/qs å…³é”®è¯` - QQéŸ³ä¹æœç´¢æ­Œæ›²
`/qa ä¸“è¾‘å` - QQéŸ³ä¹æœç´¢ä¸“è¾‘

**ğŸ“¥ ä¸‹è½½ç®¡ç†ï¼š**
`/ds` - æŸ¥çœ‹ä¸‹è½½çŠ¶æ€
`/dq` - æŸ¥çœ‹ä¸‹è½½é˜Ÿåˆ—
`/dh` - æŸ¥çœ‹ä¸‹è½½å†å²

**ğŸ“‹ å…¶ä»–å‘½ä»¤ï¼š**
`/req æ­Œæ›²-æ­Œæ‰‹` - ç”³è¯·è¡¥å…¨æ­Œæ›²
`/mr` - æŸ¥çœ‹æˆ‘çš„ç”³è¯·
`/sub` - æŸ¥çœ‹è®¢é˜…æ­Œå•
`/unsub åºå·` - å–æ¶ˆè®¢é˜…
`/scan` - æ‰‹åŠ¨æ‰«æEmbyåº“
`/si å°æ—¶` - è®¾ç½®è‡ªåŠ¨æ‰«æé—´éš”

**ğŸ”§ åŸºç¡€å‘½ä»¤ï¼š**
`/b ç”¨æˆ·å å¯†ç ` - ç»‘å®šEmby
`/unbind` - è§£é™¤ç»‘å®š
`/s` - æŸ¥çœ‹çŠ¶æ€

ğŸ’¡ æ‰€æœ‰çŸ­å‘½ä»¤éƒ½æœ‰å®Œæ•´ç‰ˆæœ¬ï¼Œå¦‚ /ss = /search
"""
    await update.message.reply_text(help_text, parse_mode='Markdown')


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - æ­Œå•åŒæ­¥
# ============================================================

async def handle_playlist_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text
    user_id = str(update.effective_user.id)
    
    playlist_type, _ = parse_playlist_input(text)
    if not playlist_type:
        return False
    
    binding = get_user_binding(user_id)
    if not binding:
        await update.message.reply_text("è¯·å…ˆç»‘å®š Emby è´¦æˆ·ï¼š/bind <ç”¨æˆ·å> <å¯†ç >")
        return True
    
    context.user_data['playlist_url'] = text
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("âš¡ æ¨¡ç³ŠåŒ¹é…", callback_data="match_fuzzy"),
         InlineKeyboardButton("ğŸ¯ å®Œå…¨åŒ¹é…", callback_data="match_exact")]
    ])
    await update.message.reply_text("è¯·é€‰æ‹©åŒ¹é…æ¨¡å¼ï¼š", reply_markup=keyboard)
    return True

async def handle_match_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    playlist_url = context.user_data.pop('playlist_url', None)
    
    if not playlist_url:
        await query.edit_message_text("è¯·é‡æ–°å‘é€æ­Œå•é“¾æ¥")
        return
    
    match_mode = "å®Œå…¨åŒ¹é…" if query.data == 'match_exact' else "æ¨¡ç³ŠåŒ¹é…"
    await query.edit_message_text(
        f"ğŸ”„ **æ­£åœ¨åŒæ­¥æ­Œå•**\n\n"
        f"â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 10%\n\n"
        f"ğŸ“‹ æ¨¡å¼: `{match_mode}`\n"
        f"â³ æ­£åœ¨è·å–æ­Œå•ä¿¡æ¯...",
        parse_mode='Markdown'
    )
    
    binding = get_user_binding(user_id)
    if not binding:
        await query.message.reply_text("è¯·å…ˆç»‘å®š Emby è´¦æˆ·")
        return
    
    try:
        result, error = await asyncio.to_thread(process_playlist, playlist_url, user_id, False, binding, match_mode)
        
        if error:
            await query.message.reply_text(f"âŒ {error}")
        else:
            # è‡ªåŠ¨æ·»åŠ åˆ°å®šæ—¶åŒæ­¥åˆ—è¡¨
            playlist_type, _ = parse_playlist_input(playlist_url)
            if playlist_type and user_id in ADMIN_USER_IDS:
                # è·å–æ­Œæ›² ID åˆ—è¡¨ç”¨äºåç»­æ¯”è¾ƒ
                song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in result.get('all_unmatched', []) + result.get('unmatched_songs', [])]
                # ä»åŸå§‹æ­Œå•è·å–
                if playlist_type == "netease":
                    _, songs = get_ncm_playlist_details(extract_playlist_id(playlist_url, 'netease'))
                else:
                    _, songs = get_qq_playlist_details(extract_playlist_id(playlist_url, 'qq'))
                if songs:
                    song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
                add_scheduled_playlist(user_id, playlist_url, result['name'], playlist_type, song_ids)
            
            msg = f"âœ… **æ­Œå•åŒæ­¥å®Œæˆ**\n\n"
            msg += f"ğŸ“‹ æ­Œå•: `{result['name']}`\n"
            msg += f"ğŸ¯ æ¨¡å¼: `{result['mode']}`\n"
            msg += f"ğŸ“Š æ€»æ•°: {result['total']} é¦–\n"
            msg += f"âœ… åŒ¹é…: {result['matched']} é¦–\n"
            msg += f"âŒ æœªåŒ¹é…: {result['unmatched']} é¦–\n"
            msg += f"ğŸ“… å·²æ·»åŠ åˆ°å®šæ—¶åŒæ­¥\n"
            
            # æ£€æŸ¥æ˜¯å¦å¯ä»¥è‡ªåŠ¨ä¸‹è½½ï¼ˆç½‘æ˜“äº‘æ­Œå•ä¸”æœ‰æœªåŒ¹é…æ­Œæ›²æ—¶ï¼‰
            ncm_unmatched = [s for s in result.get('all_unmatched', result.get('unmatched_songs', [])) if s.get('platform') == 'NCM']
            all_unmatched = result.get('all_unmatched', result.get('unmatched_songs', []))
            
            if all_unmatched:
                # ä¿å­˜æ‰€æœ‰æœªåŒ¹é…æ­Œæ›²ç”¨äºç¿»é¡µ
                context.user_data['all_unmatched_songs'] = all_unmatched
                context.user_data['unmatched_page'] = 0
                
                msg += "\n**æœªåŒ¹é…æ­Œæ›²ï¼š**\n"
                page_size = 10
                for i, s in enumerate(all_unmatched[:page_size]):
                    msg += f"`{i+1}. {s['title']} - {s['artist']}`\n"
                if len(all_unmatched) > page_size:
                    msg += f"...è¿˜æœ‰ {len(all_unmatched) - page_size} é¦–\n"
            
            keyboard_buttons = []
            
            # ç¿»é¡µæŒ‰é’®ï¼ˆå¦‚æœè¶…è¿‡10é¦–ï¼‰
            if len(all_unmatched) > 10:
                keyboard_buttons.append([
                    InlineKeyboardButton("ğŸ“„ æŸ¥çœ‹æ›´å¤š", callback_data="unmatched_page_1")
                ])
            
            if ncm_unmatched and user_id in ADMIN_USER_IDS:
                # ä¿å­˜æœªåŒ¹é…æ­Œæ›²åˆ°ç”¨æˆ·æ•°æ®
                context.user_data['unmatched_ncm_songs'] = ncm_unmatched
                msg += f"\nğŸ’¡ æ£€æµ‹åˆ° {len(ncm_unmatched)} é¦–ç½‘æ˜“äº‘æ­Œæ›²å¯è‡ªåŠ¨ä¸‹è½½"
                keyboard_buttons.append([
                    InlineKeyboardButton("ğŸ“¥ è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²", callback_data="download_missing")
                ])
            
            keyboard = InlineKeyboardMarkup(keyboard_buttons) if keyboard_buttons else None
            
            await query.message.reply_text(msg, parse_mode='Markdown', reply_markup=keyboard)
    except Exception as e:
        logger.exception(f"å¤„ç†æ­Œå•å¤±è´¥: {e}")
        await query.message.reply_text(f"å¤„ç†å¤±è´¥: {e}")


async def handle_unmatched_page_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æœªåŒ¹é…æ­Œæ›²ç¿»é¡µ"""
    query = update.callback_query
    await query.answer()
    
    # è§£æé¡µç 
    data = query.data  # unmatched_page_1
    try:
        page = int(data.split('_')[-1])
    except:
        page = 0
    
    all_unmatched = context.user_data.get('all_unmatched_songs', [])
    if not all_unmatched:
        await query.edit_message_text("æœªåŒ¹é…æ­Œæ›²åˆ—è¡¨å·²è¿‡æœŸï¼Œè¯·é‡æ–°åŒæ­¥æ­Œå•")
        return
    
    page_size = 10
    total_pages = (len(all_unmatched) + page_size - 1) // page_size
    start_idx = page * page_size
    end_idx = min(start_idx + page_size, len(all_unmatched))
    
    # æ„å»ºæ¶ˆæ¯
    msg = f"**æœªåŒ¹é…æ­Œæ›²** (ç¬¬ {page + 1}/{total_pages} é¡µ)\n\n"
    for i, s in enumerate(all_unmatched[start_idx:end_idx], start=start_idx + 1):
        msg += f"`{i}. {s['title']} - {s['artist']}`\n"
    
    msg += f"\nğŸ“Š å…± {len(all_unmatched)} é¦–æœªåŒ¹é…"
    
    # æ„å»ºç¿»é¡µæŒ‰é’®
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("â¬…ï¸ ä¸Šä¸€é¡µ", callback_data=f"unmatched_page_{page - 1}"))
    if page < total_pages - 1:
        nav_buttons.append(InlineKeyboardButton("â¡ï¸ ä¸‹ä¸€é¡µ", callback_data=f"unmatched_page_{page + 1}"))
    
    keyboard_buttons = []
    if nav_buttons:
        keyboard_buttons.append(nav_buttons)
    
    # å¦‚æœæœ‰ç½‘æ˜“äº‘æ­Œæ›²ä¸”æ˜¯ç®¡ç†å‘˜ï¼Œæ˜¾ç¤ºä¸‹è½½æŒ‰é’®
    user_id = str(query.from_user.id)
    ncm_unmatched = context.user_data.get('unmatched_ncm_songs', [])
    if ncm_unmatched and user_id in ADMIN_USER_IDS:
        keyboard_buttons.append([
            InlineKeyboardButton("ğŸ“¥ è‡ªåŠ¨ä¸‹è½½ç¼ºå¤±æ­Œæ›²", callback_data="download_missing")
        ])
    
    keyboard = InlineKeyboardMarkup(keyboard_buttons) if keyboard_buttons else None
    
    await query.edit_message_text(msg, parse_mode='Markdown', reply_markup=keyboard)


async def handle_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†è‡ªåŠ¨ä¸‹è½½å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
        return
    
    ncm_cookie = get_ncm_cookie()
    if not ncm_cookie:
        await query.edit_message_text("æœªé…ç½®ç½‘æ˜“äº‘ Cookieï¼Œæ— æ³•ä¸‹è½½\n\nè¯·åœ¨ Web ç•Œé¢ä½¿ç”¨æ‰«ç ç™»å½•æˆ–æ‰‹åŠ¨é…ç½® Cookie")
        return
    
    unmatched_songs = context.user_data.get('unmatched_ncm_songs', [])
    ncm_songs = [s for s in unmatched_songs if s.get('platform') == 'NCM']
    
    if not ncm_songs:
        await query.edit_message_text("æ²¡æœ‰éœ€è¦ä¸‹è½½çš„ç½‘æ˜“äº‘æ­Œæ›²")
        return
    
    await query.edit_message_text(f"ğŸ”„ æ­£åœ¨ä¸‹è½½ {len(ncm_songs)} é¦–æ­Œæ›²...\n\nè¯·è€å¿ƒç­‰å¾…ï¼Œä¸‹è½½å®Œæˆåä¼šé€šçŸ¥æ‚¨ã€‚")
    
    try:
        # åŠ¨æ€å¯¼å…¥ä¸‹è½½æ¨¡å—
        from bot.ncm_downloader import MusicAutoDownloader
        
        # ä»æ•°æ®åº“è¯»å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        
        # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
        qq_cookie = get_qq_cookie()
        
        downloader = MusicAutoDownloader(
            ncm_cookie, qq_cookie, str(download_path),
            proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
        )
        
        # æ£€æŸ¥ç™»å½•çŠ¶æ€
        logged_in, info = downloader.check_ncm_login()
        if not logged_in:
            await query.message.reply_text("âŒ ç½‘æ˜“äº‘ Cookie å·²å¤±æ•ˆï¼Œè¯·æ›´æ–°")
            return
        
        await query.message.reply_text(f"ğŸµ ç½‘æ˜“äº‘ç™»å½•æˆåŠŸ: {info.get('nickname')} (VIP: {'æ˜¯' if info.get('is_vip') else 'å¦'})")
        
        # åˆ›å»ºè¿›åº¦æ¶ˆæ¯
        progress_msg = await query.message.reply_text(
            make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", 0, len(ncm_songs), "å‡†å¤‡å¼€å§‹...")
        )
        last_update_time = [0]  # ç”¨åˆ—è¡¨æ¥å…è®¸åœ¨é—­åŒ…ä¸­ä¿®æ”¹
        main_loop = asyncio.get_running_loop()  # åœ¨ä¸»çº¿ç¨‹è·å– loop
        
        async def update_progress(current, total, song):
            """æ›´æ–°ä¸‹è½½è¿›åº¦"""
            import time as time_module
            now = time_module.time()
            # é™åˆ¶æ›´æ–°é¢‘ç‡ï¼Œé¿å… Telegram API é™æµ
            if now - last_update_time[0] < 1.5:
                return
            last_update_time[0] = now
            try:
                song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                await progress_msg.edit_text(
                    make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", current, total, song_name),
                    parse_mode='Markdown'
                )
            except:
                pass
        
        # åŒ…è£…åŒæ­¥å›è°ƒä¸ºå¼‚æ­¥
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        # å¼€å§‹ä¸‹è½½
        success_results, failed_songs = await asyncio.to_thread(
            downloader.download_missing_songs,
            ncm_songs,
            download_quality,
            sync_progress_callback
        )
        
        # æå–æˆåŠŸçš„æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        success_files = [r['file'] for r in success_results]
        
        # å¦‚æœè®¾ç½®äº† MusicTag æ¨¡å¼ï¼Œç§»åŠ¨æ–‡ä»¶åˆ° MusicTag ç›®å½•
        moved_files = []
        if download_mode == 'musictag' and musictag_dir and success_files:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            
            for i, file_path in enumerate(success_files):
                try:
                    src = Path(file_path)
                    if not src.exists():
                        logger.warning(f"æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨: {file_path}")
                        continue
                    dst = musictag_path / src.name
                    shutil.move(str(src), str(dst))
                    moved_files.append(str(dst))
                    # æ›´æ–° success_results ä¸­çš„æ–‡ä»¶è·¯å¾„ï¼Œä»¥ä¾¿æ­£ç¡®è®°å½•æ–‡ä»¶å¤§å°
                    success_results[i]['file'] = str(dst)
                    logger.info(f"å·²ç§»åŠ¨æ–‡ä»¶åˆ° MusicTag: {src.name}")
                except Exception as e:
                    logger.error(f"ç§»åŠ¨æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
        
        # åˆ é™¤è¿›åº¦æ¶ˆæ¯
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…ä¸‹è½½å¹³å°è®°å½•ï¼‰
        save_download_record_v2(success_results, failed_songs, download_quality, user_id)
        
        # æ„å»ºå®Œæˆæ¶ˆæ¯
        success_rate = len(success_files) / max(len(ncm_songs), 1) * 100
        msg = f"âœ… **ä¸‹è½½å®Œæˆ**\n\n"
        msg += f"{make_progress_bar(len(success_files), len(ncm_songs))}\n\n"
        msg += f"ğŸµ éŸ³è´¨: `{download_quality}`\n"
        msg += f"ğŸ“Š æˆåŠŸ: {len(success_files)}/{len(ncm_songs)} é¦–\n"
        
        # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        if qq_count > 0:
            msg += f"   â€¢ ç½‘æ˜“äº‘: {ncm_count} é¦–, QQéŸ³ä¹: {qq_count} é¦–\n"
        
        if success_files:
            if moved_files:
                msg += f"\nğŸ“ å·²è½¬ç§»åˆ° MusicTag\n"
            else:
                msg += f"\nğŸ“ å·²ä¿å­˜åˆ°æœ¬åœ°\n"
        
        if failed_songs and len(failed_songs) <= 5:
            msg += "\n**âŒ ä¸‹è½½å¤±è´¥ï¼š**\n"
            for s in failed_songs:
                msg += f"â€¢ `{s['title']}`\n"
        elif failed_songs:
            msg += f"\nâŒ {len(failed_songs)} é¦–ä¸‹è½½å¤±è´¥\n"
        
        await query.message.reply_text(msg, parse_mode='Markdown')
        
        # è‡ªåŠ¨è§¦å‘ Emby æ‰«åº“ï¼ˆä»…æœ¬åœ°æ¨¡å¼ï¼‰
        if success_files and not moved_files:
            binding = get_user_binding(user_id)
            if binding:
                try:
                    user_access_token, user_id_emby = authenticate_emby(
                        EMBY_URL, binding['emby_username'], decrypt_password(binding['emby_password'])
                    )
                    if user_access_token:
                        user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                        if trigger_emby_library_scan(user_auth):
                            await query.message.reply_text("ğŸ”„ å·²è‡ªåŠ¨è§¦å‘ Emby åª’ä½“åº“æ‰«æï¼Œè¯·ç¨ç­‰å‡ åˆ†é’Ÿåé‡æ–°åŒæ­¥æ­Œå•")
                        else:
                            await query.message.reply_text("ğŸ’¡ æç¤ºï¼šè¯·ä½¿ç”¨ /rescan åˆ·æ–° Emby åª’ä½“åº“")
                except Exception as e:
                    logger.exception(f"è‡ªåŠ¨æ‰«åº“å¤±è´¥: {e}")
                    await query.message.reply_text("ğŸ’¡ æç¤ºï¼šè¯·ä½¿ç”¨ /rescan åˆ·æ–° Emby åª’ä½“åº“")
        
    except ImportError as e:
        logger.error(f"å¯¼å…¥ä¸‹è½½æ¨¡å—å¤±è´¥: {e}")
        await query.message.reply_text("âŒ ä¸‹è½½æ¨¡å—æœªæ­£ç¡®å®‰è£…ï¼Œè¯·æ£€æŸ¥ pycryptodome å’Œ mutagen ä¾èµ–")
    except Exception as e:
        logger.exception(f"ä¸‹è½½å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - éŸ³ä¹ä¸Šä¼ 
# ============================================================

def check_user_permission(telegram_id: str, permission: str) -> bool:
    """æ£€æŸ¥ç”¨æˆ·æƒé™"""
    # ç®¡ç†å‘˜å§‹ç»ˆæœ‰æƒé™
    if telegram_id in ADMIN_USER_IDS:
        return True
    
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT * FROM user_permissions WHERE telegram_id = ?', (telegram_id,))
            row = cursor.fetchone()
            if row:
                if permission == 'upload':
                    return bool(row['can_upload'] if isinstance(row, dict) else row[2])
                elif permission == 'request':
                    return bool(row['can_request'] if isinstance(row, dict) else row[3])
            # é»˜è®¤å…è®¸
            return True
    except Exception as e:
        logger.error(f"æ£€æŸ¥ç”¨æˆ·æƒé™å¤±è´¥: {e}")
    return True


async def handle_audio_upload(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†éŸ³é¢‘ä¸Šä¼ """
    user_id = str(update.effective_user.id)
    message = update.message
    
    # æ£€æŸ¥ä¸Šä¼ æƒé™
    if not check_user_permission(user_id, 'upload'):
        await message.reply_text("âŒ ä½ æ²¡æœ‰ä¸Šä¼ æƒé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return True
    
    # è·å–æ–‡ä»¶ä¿¡æ¯
    if message.audio:
        file = message.audio
        original_name = file.file_name or f"{file.title or 'audio'}.mp3"
    elif message.document:
        file = message.document
        original_name = file.file_name or "unknown"
        # æ£€æŸ¥æ˜¯å¦æ˜¯éŸ³é¢‘æ–‡ä»¶
        mime = file.mime_type or ""
        if not (mime.startswith('audio/') or original_name.lower().endswith(ALLOWED_AUDIO_EXTENSIONS)):
            return False
    else:
        return False
    
    file_size = file.file_size or 0
    
    try:
        status_msg = await message.reply_text(f"ğŸ“¥ æ­£åœ¨ä¸‹è½½: {original_name}...")
        
        # è·å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        # ä¸‹è½½æ–‡ä»¶
        tg_file = await context.bot.get_file(file.file_id)
        temp_path = UPLOAD_DIR / original_name
        await tg_file.download_to_drive(temp_path)
        
        # æ¸…ç†æ–‡ä»¶åå¹¶ç§»åŠ¨åˆ°ä¸‹è½½ç›®å½•
        clean_name = clean_filename(original_name)
        target_path = download_path / clean_name
        
        # å¦‚æœç›®æ ‡å·²å­˜åœ¨ï¼Œåˆ é™¤
        if target_path.exists():
            target_path.unlink()
        
        shutil.move(str(temp_path), str(target_path))
        
        # å¦‚æœæ˜¯ MusicTag æ¨¡å¼ï¼Œç»§ç»­ç§»åŠ¨åˆ° MusicTag ç›®å½•
        final_path = target_path
        if download_mode == 'musictag' and musictag_dir:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            final_dest = musictag_path / clean_name
            shutil.move(str(target_path), str(final_dest))
            final_path = final_dest
            logger.info(f"å·²ç§»åŠ¨ä¸Šä¼ æ–‡ä»¶åˆ° MusicTag: {clean_name}")
        
        # è®°å½•
        save_upload_record(user_id, original_name, clean_name, file_size)
        
        size_mb = file_size / 1024 / 1024
        if download_mode == 'musictag' and musictag_dir:
            await status_msg.edit_text(f"âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB\nğŸ“‚ å·²è½¬ç§»åˆ° MusicTag ç›®å½•")
        else:
            await status_msg.edit_text(f"âœ… ä¸Šä¼ æˆåŠŸï¼\n\nğŸ“ æ–‡ä»¶: `{clean_name}`\nğŸ“¦ å¤§å°: {size_mb:.2f} MB")
        
    except Exception as e:
        logger.exception(f"ä¸Šä¼ å¤±è´¥: {e}")
        await message.reply_text(f"âŒ ä¸Šä¼ å¤±è´¥: {e}")
    
    return True


# ============================================================
# Telegram å‘½ä»¤å¤„ç† - è®¾ç½®å’ŒçŠ¶æ€
# ============================================================

async def cmd_bind(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    
    if get_user_binding(user_id):
        await update.message.reply_text("æ‚¨å·²ç»‘å®šè´¦æˆ·ï¼Œå¦‚éœ€é‡æ–°ç»‘å®šè¯·å…ˆ /unbind")
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("æ ¼å¼: /bind <ç”¨æˆ·å> <å¯†ç >")
        return
    
    username = context.args[0]
    password = ' '.join(context.args[1:])
    
    token, emby_user_id = authenticate_emby(EMBY_URL, username, password)
    if not token:
        await update.message.reply_text("ç»‘å®šå¤±è´¥ï¼šEmby ç™»å½•å¤±è´¥")
        return
    
    if save_user_binding(user_id, username, password, emby_user_id):
        await update.message.reply_text(f"âœ… ç»‘å®šæˆåŠŸï¼\nç”¨æˆ·å: {username}")
    else:
        await update.message.reply_text("ç»‘å®šå¤±è´¥")

async def cmd_unbind(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    binding = get_user_binding(user_id)
    
    if not binding:
        await update.message.reply_text("æ‚¨å°šæœªç»‘å®šè´¦æˆ·")
        return
    
    if delete_user_binding(user_id):
        await update.message.reply_text(f"å·²è§£é™¤ç»‘å®š: {binding['emby_username']}")

async def cmd_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    stats = get_stats()
    msg = f"""
ğŸ“Š **TGmusicbot çŠ¶æ€**

ğŸµ Emby åª’ä½“åº“: {stats.get('library_songs', 0)} é¦–æ­Œæ›²
ğŸ‘¥ ç»‘å®šç”¨æˆ·: {stats.get('users', 0)}
ğŸ“‹ åŒæ­¥æ­Œå•: {stats.get('playlists', 0)} ä¸ª
ğŸ¶ åŒæ­¥æ­Œæ›²: {stats.get('songs_synced', 0)} é¦–
ğŸ“¤ ä¸Šä¼ æ–‡ä»¶: {stats.get('uploads', 0)} ä¸ª
"""
    await update.message.reply_text(msg, parse_mode='Markdown')

async def cmd_ncm_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æ£€æŸ¥ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    ncm_cookie = get_ncm_cookie()
    if not ncm_cookie:
        await update.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie\n\nè¯·åœ¨ Web ç•Œé¢ä½¿ç”¨æ‰«ç ç™»å½•ï¼Œæˆ–åœ¨ .env æ–‡ä»¶ä¸­æ·»åŠ  NCM_COOKIE")
        return
    
    await update.message.reply_text("ğŸ”„ æ­£åœ¨æ£€æŸ¥ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€...")
    
    try:
        from bot.ncm_downloader import NeteaseMusicAPI
        api = NeteaseMusicAPI(ncm_cookie)
        logged_in, info = api.check_login()
        
        # è·å–æ•°æ®åº“è®¾ç½®
        ncm_settings = get_ncm_settings()
        quality_names = {
            'standard': 'æ ‡å‡†éŸ³è´¨ (128kbps)',
            'higher': 'è¾ƒé«˜éŸ³è´¨ (192kbps)',
            'exhigh': 'æé«˜éŸ³è´¨ (320kbps)',
            'lossless': 'æ— æŸéŸ³è´¨ (FLAC)',
            'hires': 'Hi-Res'
        }
        quality_display = quality_names.get(ncm_settings['ncm_quality'], ncm_settings['ncm_quality'])
        
        if logged_in:
            msg = f"âœ… **ç½‘æ˜“äº‘ç™»å½•çŠ¶æ€**\n\n"
            msg += f"ğŸ‘¤ æ˜µç§°: `{info.get('nickname', 'æœªçŸ¥')}`\n"
            msg += f"ğŸ†” ç”¨æˆ·ID: `{info.get('user_id', 'æœªçŸ¥')}`\n"
            msg += f"ğŸ’ VIP: {'æ˜¯' if info.get('is_vip') else 'å¦'}\n"
            msg += f"ğŸ“Š VIPç±»å‹: {info.get('vip_type', 0)}\n\n"
            msg += f"ğŸµ ä¸‹è½½éŸ³è´¨: `{quality_display}`\n"
            msg += f"ğŸ”„ è‡ªåŠ¨ä¸‹è½½: {'å·²å¯ç”¨' if ncm_settings['auto_download'] else 'æœªå¯ç”¨'}\n"
            msg += f"ğŸ“ ä¸‹è½½ç›®å½•: `{MUSIC_TARGET_DIR}`"
        else:
            msg = "âŒ ç½‘æ˜“äº‘ Cookie å·²å¤±æ•ˆ\n\nè¯·åœ¨ Web ç•Œé¢ä½¿ç”¨æ‰«ç ç™»å½•"
        
        await update.message.reply_text(msg, parse_mode='Markdown')
    except ImportError:
        await update.message.reply_text("âŒ ä¸‹è½½æ¨¡å—æœªå®‰è£…\n\nè¯·ç¡®ä¿å·²å®‰è£… pycryptodome å’Œ mutagen")
    except Exception as e:
        await update.message.reply_text(f"âŒ æ£€æŸ¥å¤±è´¥: {e}")

async def cmd_rescan(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    await update.message.reply_text("å¼€å§‹æ‰«æ Emby åª’ä½“åº“...")
    binding = get_user_binding(user_id)
    
    if binding:
        token, emby_user_id = authenticate_emby(EMBY_URL, binding['emby_username'], binding['emby_password'])
        new_data = await asyncio.to_thread(scan_emby_library, True, emby_user_id, token)
    else:
        new_data = await asyncio.to_thread(scan_emby_library, True)
    
    await update.message.reply_text(f"âœ… æ‰«æå®Œæˆï¼Œå…± {len(new_data)} é¦–æ­Œæ›²")


async def cmd_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æœç´¢æ­Œæ›²"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /search <å…³é”®è¯>\nä¾‹å¦‚: /search å‘¨æ°ä¼¦ æ™´å¤©")
        return
    
    keyword = ' '.join(context.args)
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await update.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = ('ncm', keyword.lower())
    cached = _cmd_search_cache.get(cache_key)
    if cached and time.time() - cached[0] < _cmd_search_cache_ttl:
        results = cached[1]
        logger.debug(f"ä½¿ç”¨ç¼“å­˜çš„æœç´¢ç»“æœ: {keyword}")
    else:
        await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢: {keyword}...")
        
        try:
            from bot.ncm_downloader import NeteaseMusicAPI
            api = NeteaseMusicAPI(ncm_cookie)
            results = api.search_song(keyword, limit=10)
            
            # ç¼“å­˜ç»“æœ
            _cmd_search_cache[cache_key] = (time.time(), results)
            
            # æ¸…ç†è¿‡æœŸç¼“å­˜
            if len(_cmd_search_cache) > 50:
                now = time.time()
                expired = [k for k, v in _cmd_search_cache.items() if now - v[0] > _cmd_search_cache_ttl]
                for k in expired:
                    _cmd_search_cache.pop(k, None)
        except Exception as e:
            logger.exception(f"æœç´¢å¤±è´¥: {e}")
            await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")
            return
    
    try:
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³æ­Œæ›²")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['search_results'] = results
        
        msg = f"ğŸµ *æœç´¢ç»“æœ* \\({len(results)} é¦–\\)\n\n"
        keyboard_buttons = []
        
        for i, song in enumerate(results):
            title = escape_markdown(song['title'])
            artist = escape_markdown(song['artist'])
            album = escape_markdown(song.get('album', 'æœªçŸ¥ä¸“è¾‘'))
            msg += f"`{i+1}\\.` {title} \\- {artist}\n"
            msg += f"    ğŸ“€ {album}\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {i+1}. {song['title'][:20]}", callback_data=f"dl_song_{i}")
            ])
        
        keyboard_buttons.append([InlineKeyboardButton("ğŸ“¥ å…¨éƒ¨ä¸‹è½½", callback_data="dl_song_all")])
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"æœç´¢å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


async def cmd_album(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æœç´¢å¹¶ä¸‹è½½ä¸“è¾‘"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /album <ä¸“è¾‘åæˆ–å…³é”®è¯>\nä¾‹å¦‚: /album èŒƒç‰¹è¥¿")
        return
    
    keyword = ' '.join(context.args)
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await update.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢ä¸“è¾‘: {keyword}...")
    
    try:
        from bot.ncm_downloader import NeteaseMusicAPI
        api = NeteaseMusicAPI(ncm_cookie)
        results = api.search_album(keyword, limit=5)
        
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³ä¸“è¾‘")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['album_results'] = results
        
        msg = f"ğŸ’¿ *ä¸“è¾‘æœç´¢ç»“æœ* \\({len(results)} å¼ \\)\n\n"
        keyboard_buttons = []
        
        for i, album in enumerate(results):
            album_name = escape_markdown(album['name'])
            artist = escape_markdown(album['artist'])
            msg += f"`{i+1}\\.` {album_name}\n"
            msg += f"    ğŸ¤ {artist} Â· {album['size']} é¦–æ­Œ\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {album['name'][:25]}", callback_data=f"dl_album_{i}")
            ])
        
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"æœç´¢ä¸“è¾‘å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


async def cmd_qq_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """QQéŸ³ä¹æœç´¢æ­Œæ›²"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /qs <å…³é”®è¯>\nä¾‹å¦‚: /qs å‘¨æ°ä¼¦ æ™´å¤©")
        return
    
    keyword = ' '.join(context.args)
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await update.message.reply_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookieï¼Œè¯·åœ¨ Web è®¾ç½®ä¸­é…ç½®")
        return
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = ('qq', keyword.lower())
    cached = _cmd_search_cache.get(cache_key)
    if cached and time.time() - cached[0] < _cmd_search_cache_ttl:
        results = cached[1]
        logger.debug(f"ä½¿ç”¨ç¼“å­˜çš„ QQ æœç´¢ç»“æœ: {keyword}")
    else:
        await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢ QQéŸ³ä¹: {keyword}...")
        
        try:
            from bot.ncm_downloader import QQMusicAPI
            api = QQMusicAPI(qq_cookie)
            results = api.search_song(keyword, limit=10)
            
            # ç¼“å­˜ç»“æœ
            _cmd_search_cache[cache_key] = (time.time(), results)
        except Exception as e:
            logger.exception(f"QQéŸ³ä¹æœç´¢å¤±è´¥: {e}")
            await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")
            return
    
    try:
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³æ­Œæ›²")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['qq_search_results'] = results
        
        msg = f"ğŸµ *QQéŸ³ä¹æœç´¢ç»“æœ* \\({len(results)} é¦–\\)\n\n"
        keyboard_buttons = []
        
        for i, song in enumerate(results):
            title = escape_markdown(song['title'])
            artist = escape_markdown(song['artist'])
            album = escape_markdown(song.get('album', 'æœªçŸ¥ä¸“è¾‘'))
            msg += f"`{i+1}\\.` {title} \\- {artist}\n"
            msg += f"    ğŸ“€ {album}\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {i+1}. {song['title'][:20]}", callback_data=f"qdl_song_{i}")
            ])
        
        keyboard_buttons.append([InlineKeyboardButton("ğŸ“¥ å…¨éƒ¨ä¸‹è½½", callback_data="qdl_song_all")])
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹æœç´¢å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


async def cmd_qq_album(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """QQéŸ³ä¹æœç´¢å¹¶ä¸‹è½½ä¸“è¾‘"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /qa <ä¸“è¾‘åæˆ–å…³é”®è¯>\nä¾‹å¦‚: /qa èŒƒç‰¹è¥¿")
        return
    
    keyword = ' '.join(context.args)
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await update.message.reply_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookieï¼Œè¯·åœ¨ Web è®¾ç½®ä¸­é…ç½®")
        return
    
    await update.message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢ QQéŸ³ä¹ä¸“è¾‘: {keyword}...")
    
    try:
        from bot.ncm_downloader import QQMusicAPI
        api = QQMusicAPI(qq_cookie)
        results = api.search_album(keyword, limit=5)
        
        if not results:
            await update.message.reply_text("æœªæ‰¾åˆ°ç›¸å…³ä¸“è¾‘")
            return
        
        # ä¿å­˜æœç´¢ç»“æœåˆ°ç”¨æˆ·æ•°æ®
        context.user_data['qq_album_results'] = results
        
        msg = f"ğŸ’¿ *QQéŸ³ä¹ä¸“è¾‘æœç´¢ç»“æœ* \\({len(results)} å¼ \\)\n\n"
        keyboard_buttons = []
        
        for i, album in enumerate(results):
            album_name = escape_markdown(album['name'])
            artist = escape_markdown(album['artist'])
            msg += f"`{i+1}\\.` {album_name}\n"
            msg += f"    ğŸ¤ {artist} Â· {album['size']} é¦–æ­Œ\n"
            keyboard_buttons.append([
                InlineKeyboardButton(f"ğŸ“¥ {album['name'][:25]}", callback_data=f"qdl_album_{i}")
            ])
        
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(msg, parse_mode='MarkdownV2', reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹æœç´¢ä¸“è¾‘å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æœç´¢å¤±è´¥: {e}")


# ============================================================
# ä¸‹è½½ç®¡ç†å‘½ä»¤
# ============================================================

def format_file_size(size_bytes: int) -> str:
    """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"


async def cmd_download_status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹ä¸‹è½½çŠ¶æ€ /ds"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    manager = get_download_manager()
    if not manager:
        await update.message.reply_text("ğŸ“Š ä¸‹è½½ç®¡ç†å™¨æœªå¯ç”¨\n\nä½¿ç”¨ä¼ ç»Ÿä¸‹è½½æ¨¡å¼")
        return
    
    stats = manager.get_stats()
    queue = stats['queue']
    today = stats['today']
    
    msg = "ğŸ“Š **ä¸‹è½½çŠ¶æ€**\n\n"
    
    # é˜Ÿåˆ—çŠ¶æ€
    msg += "**ğŸ“¥ ä¸‹è½½é˜Ÿåˆ—**\n"
    msg += f"â”œ ç­‰å¾…ä¸­: {queue['pending']}\n"
    msg += f"â”œ ä¸‹è½½ä¸­: {queue['downloading']}\n"
    msg += f"â”œ é‡è¯•ä¸­: {queue['retrying']}\n"
    msg += f"â”œ å·²å®Œæˆ: {queue['completed']}\n"
    msg += f"â”” å¤±è´¥: {queue['failed']}\n\n"
    
    # ä»Šæ—¥ç»Ÿè®¡
    msg += "**ğŸ“ˆ ä»Šæ—¥ç»Ÿè®¡**\n"
    msg += f"â”œ æˆåŠŸ: {today['total_success']} é¦–\n"
    msg += f"â”œ å¤±è´¥: {today['total_fail']} é¦–\n"
    msg += f"â”” æ€»å¤§å°: {format_file_size(today['total_size'])}\n\n"
    
    # å¹³å°åˆ†å¸ƒ
    if today['by_platform']:
        msg += "**ğŸµ å¹³å°åˆ†å¸ƒ**\n"
        for platform, data in today['by_platform'].items():
            msg += f"â”œ {platform}: {data['success']} æˆåŠŸ / {data['fail']} å¤±è´¥\n"
    
    await update.message.reply_text(msg, parse_mode='Markdown')


async def cmd_download_queue(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹ä¸‹è½½é˜Ÿåˆ— /dq"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    manager = get_download_manager()
    if not manager:
        await update.message.reply_text("ğŸ“­ ä¸‹è½½ç®¡ç†å™¨æœªå¯ç”¨")
        return
    
    queue_status = manager.get_queue_status()
    tasks = queue_status['tasks']
    
    if not tasks:
        await update.message.reply_text("ğŸ“­ ä¸‹è½½é˜Ÿåˆ—ä¸ºç©º")
        return
    
    msg = f"ğŸ“¥ **ä¸‹è½½é˜Ÿåˆ—** ({queue_status['total']} ä¸ªä»»åŠ¡)\n\n"
    
    status_emoji = {
        'pending': 'â³',
        'downloading': 'ğŸ“¥',
        'completed': 'âœ…',
        'failed': 'âŒ',
        'retrying': 'ğŸ”„',
        'cancelled': 'ğŸš«'
    }
    
    for i, task in enumerate(tasks[-10:], 1):
        emoji = status_emoji.get(task['status'], 'â“')
        name = task.get('title', 'æœªçŸ¥')[:25]
        artist = task.get('artist', '')[:15]
        msg += f"{emoji} `{name}` - {artist}\n"
    
    if len(tasks) > 10:
        msg += f"\n... è¿˜æœ‰ {len(tasks) - 10} ä¸ªä»»åŠ¡"
    
    await update.message.reply_text(msg, parse_mode='Markdown')


async def cmd_download_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹ä¸‹è½½å†å² /dh"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    manager = get_download_manager()
    if not manager:
        await update.message.reply_text("ğŸ“­ ä¸‹è½½ç®¡ç†å™¨æœªå¯ç”¨")
        return
    
    history = manager.stats.get_recent_history(20)
    
    if not history:
        await update.message.reply_text("ğŸ“­ æš‚æ— ä¸‹è½½å†å²")
        return
    
    msg = "ğŸ“œ **æœ€è¿‘ä¸‹è½½å†å²**\n\n"
    
    status_emoji = {
        'completed': 'âœ…',
        'failed': 'âŒ',
    }
    
    for item in history:
        emoji = status_emoji.get(item['status'], 'â“')
        title = (item.get('title') or 'æœªçŸ¥')[:20]
        artist = (item.get('artist') or '')[:12]
        platform = item.get('platform', '?')
        
        msg += f"{emoji} `{title}` - {artist} [{platform}]\n"
    
    await update.message.reply_text(msg, parse_mode='Markdown')


# ============================================================
# å®šæ—¶ä»»åŠ¡
# ============================================================

def get_playlist_sync_interval():
    """è·å–å…¨å±€æ­Œå•åŒæ­¥é—´éš”ï¼ˆåˆ†é’Ÿï¼Œä»æ•°æ®åº“è¯»å–ï¼‰"""
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('playlist_sync_interval',))
            row = cursor.fetchone()
            if row:
                return max(1, int(row[0] if isinstance(row, tuple) else row['value']))
    except:
        pass
    return 60  # é»˜è®¤ 60 åˆ†é’Ÿ


async def scheduled_sync_job(application):
    """å®šæ—¶åŒæ­¥æ­Œå•ä»»åŠ¡"""
    logger.info("å®šæ—¶åŒæ­¥ä»»åŠ¡: å¯åŠ¨ï¼Œ5ç§’åå¼€å§‹ç¬¬ä¸€æ¬¡æ£€æŸ¥")
    await asyncio.sleep(5)
    
    next_check_times = {}
    
    while True:
        try:
            if not database_conn:
                logger.warning("å®šæ—¶åŒæ­¥: æ•°æ®åº“ä¸å¯ç”¨")
                await asyncio.sleep(30)
                continue
            
            cursor = database_conn.cursor()
            try:
                cursor.execute('SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, sync_interval FROM scheduled_playlists WHERE is_active = 1')
            except:
                cursor.execute('SELECT id, telegram_id, playlist_url, playlist_name, platform, last_song_ids, sync_interval FROM scheduled_playlists')
            rows = cursor.fetchall()
            
            default_interval = get_playlist_sync_interval()
            current_time = time.time()
            
            logger.info(f"å®šæ—¶åŒæ­¥: æ£€æŸ¥ {len(rows)} ä¸ªæ­Œå•")
            
            for row in rows:
                try:
                    # è§£æè¡Œæ•°æ®
                    pid = row[0]
                    telegram_id = row[1]
                    playlist_url = row[2]
                    playlist_name = row[3] or 'æœªçŸ¥æ­Œå•'
                    platform = row[4]
                    last_song_ids_json = row[5] or '[]'
                    sync_interval = row[6] or default_interval
                    
                    interval_seconds = max(1, sync_interval) * 60
                    
                    # æ£€æŸ¥æ˜¯å¦åˆ°åŒæ­¥æ—¶é—´
                    next_check = next_check_times.get(pid, 0)
                    if current_time < next_check:
                        continue
                    
                    logger.info(f"åŒæ­¥æ£€æŸ¥: {playlist_name} (é—´éš”{sync_interval}åˆ†é’Ÿ)")
                    
                    old_song_ids = set(json.loads(last_song_ids_json))
                    
                    # è·å–æœ€æ–°æ­Œæ›²
                    songs = []
                    if platform == 'netease':
                        pid_str = extract_playlist_id(playlist_url, 'netease')
                        _, songs = get_ncm_playlist_details(pid_str)
                    elif platform == 'qq':
                        pid_str = extract_playlist_id(playlist_url, 'qq')
                        _, songs = get_qq_playlist_details(pid_str)
                    
                    if not songs:
                        logger.warning(f"åŒæ­¥å¤±è´¥: {playlist_name} è·å–æ­Œæ›²åˆ—è¡¨ä¸ºç©º")
                        next_check_times[pid] = current_time + interval_seconds
                        continue
                    
                    def _format_song_display(song_dict):
                        title = song_dict.get('title') or song_dict.get('name') or song_dict.get('song')
                        title = title or song_dict.get('SongName') or 'æœªçŸ¥'
                        artist = song_dict.get('artist') or song_dict.get('artists') or song_dict.get('singer')
                        if isinstance(artist, list):
                            artist = ', '.join(str(a) for a in artist if a)
                        artist = artist or ''
                        return f"{title} - {artist}".strip(' -')

                    song_id_map = {}
                    for song in songs:
                        identifier = (
                            song.get('source_id') or song.get('id') or song.get('song_id') or
                            song.get('song_mid') or song.get('mid') or song.get('title') or
                            song.get('name') or song.get('song') or song.get('SongName')
                        )
                        song_id = str(identifier or _format_song_display(song))
                        song_id_map[song_id] = _format_song_display(song)
                    
                    current_song_ids = set(song_id_map.keys())
                    new_songs = current_song_ids - old_song_ids
                    removed_songs = old_song_ids - current_song_ids
                    
                    logger.info(
                        f"åŒæ­¥ç»“æœ: {playlist_name} - å½“å‰{len(current_song_ids)}é¦–, "
                        f"è®°å½•{len(old_song_ids)}é¦–, æ–°å¢{len(new_songs)}é¦–, åˆ é™¤{len(removed_songs)}é¦–"
                    )
                    
                    def _describe_changes(song_ids):
                        if not song_ids:
                            return "æ— "
                        samples = [song_id_map.get(sid, sid) for sid in list(song_ids)[:5]]
                        suffix = " ..." if len(song_ids) > 5 else ""
                        return ', '.join(samples) + suffix
                    
                    if new_songs:
                        logger.info(f"æ–°å¢æ­Œæ›²: {_describe_changes(new_songs)}")
                    if removed_songs:
                        logger.info(f"ä¸‹æ¶æ­Œæ›²: {_describe_changes(removed_songs)}")
                    if not new_songs and not removed_songs:
                        logger.info(f"åŒæ­¥å·®å¼‚: {playlist_name} æœªå‘ç°æ–°å¢æˆ–åˆ é™¤")
                    
                    if new_songs:
                        msg = f"ğŸµ **æ­Œå•æ›´æ–°é€šçŸ¥**\n\nğŸ“‹ æ­Œå•: {playlist_name}\nğŸ†• æ–°å¢: {len(new_songs)} é¦–\n\nç‚¹å‡»æŒ‰é’®ä¸‹è½½"
                        keyboard = InlineKeyboardMarkup([
                            [InlineKeyboardButton("ğŸ“¥ ä¸‹è½½æ–°æ­Œ", callback_data=f"sync_dl_{pid}")],
                            [InlineKeyboardButton("ğŸ”„ åŒæ­¥Emby", callback_data=f"sync_emby_{pid}")]
                        ])
                        await application.bot.send_message(chat_id=telegram_id, text=msg, parse_mode='Markdown', reply_markup=keyboard)
                        logger.info(f"å·²é€šçŸ¥: {playlist_name} æ–°å¢ {len(new_songs)} é¦–")
                    
                    if new_songs or removed_songs or old_song_ids != current_song_ids:
                        update_scheduled_playlist_songs(pid, list(current_song_ids))
                    
                    next_check_times[pid] = current_time + interval_seconds
                    
                except Exception as e:
                    logger.error(f"åŒæ­¥æ­Œå•å‡ºé”™: {e}", exc_info=True)
                    next_check_times[row[0]] = current_time + 300
            
            await asyncio.sleep(30)
            
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"å®šæ—¶åŒæ­¥ä»»åŠ¡å¼‚å¸¸: {e}", exc_info=True)
            await asyncio.sleep(30)
async def scheduled_emby_scan_job(application):
    """å®šæ—¶æ‰«æ Emby åª’ä½“åº“ä»»åŠ¡"""
    while True:
        try:
            # è·å–æ‰«æé—´éš”
            scan_interval = EMBY_SCAN_INTERVAL
            try:
                if database_conn:
                    cursor = database_conn.cursor()
                    cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                    row = cursor.fetchone()
                    if row:
                        scan_interval = int(row[0] if isinstance(row, tuple) else row['value'])
            except:
                pass
            
            if scan_interval <= 0:
                await asyncio.sleep(3600)  # ç¦ç”¨æ—¶æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡é…ç½®
                continue
            
            await asyncio.sleep(scan_interval * 3600)
            
            logger.info("å¼€å§‹å®šæ—¶æ‰«æ Emby åª’ä½“åº“...")
            
            if emby_auth['access_token']:
                scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
                trigger_emby_library_scan(emby_auth)
                logger.info("Emby åª’ä½“åº“æ‰«æå®Œæˆ")
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Emby æ‰«æä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(60)


async def daily_stats_job(application):
    """æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šä»»åŠ¡ - æ¯å¤©æ—©ä¸Š9ç‚¹å‘é€"""
    import datetime as dt
    
    while True:
        try:
            # è®¡ç®—åˆ°ä¸‹ä¸€ä¸ª9ç‚¹çš„æ—¶é—´
            now = dt.datetime.now()
            target = now.replace(hour=9, minute=0, second=0, microsecond=0)
            if now >= target:
                target += dt.timedelta(days=1)
            
            wait_seconds = (target - now).total_seconds()
            await asyncio.sleep(wait_seconds)
            
            logger.info("å‘é€æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š...")
            
            # è·å–ç»Ÿè®¡æ•°æ®
            if not database_conn:
                continue
            
            cursor = database_conn.cursor()
            
            # æ˜¨æ—¥ä¸‹è½½ç»Ÿè®¡
            yesterday = (dt.datetime.now() - dt.timedelta(days=1)).strftime('%Y-%m-%d')
            cursor.execute('''
                SELECT 
                    COUNT(*) as total,
                    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as success,
                    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
                    SUM(CASE WHEN status = 'completed' THEN file_size ELSE 0 END) as size
                FROM download_history 
                WHERE DATE(created_at) = ?
            ''', (yesterday,))
            row = cursor.fetchone()
            
            if row and row[0] > 0:
                total = row[0] or 0
                success = row[1] or 0
                failed = row[2] or 0
                size = row[3] or 0
                size_mb = size / (1024 * 1024) if size else 0
                
                # æ­Œå•åŒæ­¥ç»Ÿè®¡
                cursor.execute('''
                    SELECT COUNT(*) FROM playlist_records 
                    WHERE DATE(created_at) = ?
                ''', (yesterday,))
                playlists = cursor.fetchone()[0] or 0
                
                msg = f"ğŸ“Š **æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š** ({yesterday})\n\n"
                msg += f"**ğŸ“¥ ä¸‹è½½ç»Ÿè®¡**\n"
                msg += f"â”œ æˆåŠŸ: {success} é¦–\n"
                msg += f"â”œ å¤±è´¥: {failed} é¦–\n"
                msg += f"â”” å¤§å°: {size_mb:.1f} MB\n\n"
                msg += f"**ğŸ“‹ æ­Œå•åŒæ­¥**\n"
                msg += f"â”” åŒæ­¥: {playlists} æ¬¡\n"
                
                # å‘é€ç»™æ‰€æœ‰ç®¡ç†å‘˜
                for admin_id in ADMIN_USER_IDS:
                    try:
                        await application.bot.send_message(
                            chat_id=admin_id,
                            text=msg,
                            parse_mode='Markdown'
                        )
                    except:
                        pass
                if ADMIN_USER_IDS:
                    logger.info("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šå·²å‘é€")
            
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"æ¯æ—¥ç»Ÿè®¡ä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(3600)


async def cookie_check_job(application):
    """Cookie è¿‡æœŸæ£€æŸ¥ä»»åŠ¡ - æ¯6å°æ—¶æ£€æŸ¥ä¸€æ¬¡"""
    # å¯åŠ¨åç­‰å¾… 1 åˆ†é’Ÿå†æ‰§è¡Œç¬¬ä¸€æ¬¡æ£€æŸ¥
    await asyncio.sleep(60)
    
    while True:
        try:
            logger.info("æ£€æŸ¥ Cookie çŠ¶æ€...")
            
            notifications = []
            
            # æ£€æŸ¥ç½‘æ˜“äº‘ Cookie
            ncm_cookie = get_ncm_cookie()
            if ncm_cookie:
                try:
                    from bot.ncm_downloader import NeteaseMusicAPI
                    api = NeteaseMusicAPI(ncm_cookie)
                    logged_in, info = api.check_login()
                    if not logged_in:
                        notifications.append("ğŸ”´ **ç½‘æ˜“äº‘ Cookie å·²å¤±æ•ˆ**\nè¯·é‡æ–°ç™»å½•è·å– Cookie")
                    else:
                        logger.info(f"ç½‘æ˜“äº‘ Cookie æœ‰æ•ˆ: {info.get('nickname', 'æœªçŸ¥')}")
                except Exception as e:
                    logger.error(f"æ£€æŸ¥ç½‘æ˜“äº‘ Cookie å¤±è´¥: {e}")
            
            # æ£€æŸ¥ QQ Cookie
            qq_cookie = get_qq_cookie()
            if qq_cookie:
                try:
                    from bot.ncm_downloader import QQMusicAPI
                    api = QQMusicAPI(qq_cookie)
                    logged_in, info = api.check_login()
                    if not logged_in:
                        notifications.append("ğŸ”´ **QQéŸ³ä¹ Cookie å·²å¤±æ•ˆ**\nè¯·é‡æ–°ç™»å½•è·å– Cookie")
                    else:
                        logger.info(f"QQéŸ³ä¹ Cookie æœ‰æ•ˆ: {info.get('nickname', 'æœªçŸ¥')}")
                except Exception as e:
                    logger.error(f"æ£€æŸ¥ QQ Cookie å¤±è´¥: {e}")
            
            # å‘é€é€šçŸ¥ç»™æ‰€æœ‰ç®¡ç†å‘˜
            if notifications and ADMIN_USER_IDS:
                msg = "âš ï¸ **Cookie çŠ¶æ€å‘Šè­¦**\n\n" + "\n\n".join(notifications)
                msg += "\n\nğŸ’¡ è¯·åœ¨ Web ç®¡ç†ç•Œé¢é‡æ–°é…ç½® Cookie"
                
                for admin_id in ADMIN_USER_IDS:
                    try:
                        await application.bot.send_message(
                            chat_id=admin_id,
                            text=msg,
                            parse_mode='Markdown'
                        )
                    except:
                        pass
                logger.warning("å·²å‘é€ Cookie è¿‡æœŸé€šçŸ¥")
            
            # ç­‰å¾… 6 å°æ—¶åå†æ¬¡æ£€æŸ¥
            await asyncio.sleep(6 * 3600)
                
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Cookie æ£€æŸ¥ä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(3600)


# ============================================================
# Inline æ¨¡å¼æœç´¢ï¼ˆä»»æ„èŠå¤©ä¸­ @bot æ­Œå æœç´¢ï¼‰
# ============================================================

# æœç´¢ç»“æœç¼“å­˜
_search_cache = {}
_cache_ttl = 300  # 5åˆ†é’Ÿ

async def handle_inline_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† Inline æŸ¥è¯¢ - ä»»æ„èŠå¤©ä¸­ @bot æ­Œå æœç´¢"""
    query = update.inline_query
    search_text = query.query.strip()
    
    if not search_text or len(search_text) < 2:
        return
    
    # æ£€æŸ¥ç¼“å­˜
    cache_key = search_text.lower()
    if cache_key in _search_cache:
        cached_time, cached_results = _search_cache[cache_key]
        if time.time() - cached_time < _cache_ttl:
            await query.answer(cached_results, cache_time=60)
            return
    
    results = []
    
    try:
        # æœç´¢ç½‘æ˜“äº‘
        ncm_cookie = get_ncm_cookie()
        if ncm_cookie:
            from bot.ncm_downloader import NeteaseMusicAPI
            api = NeteaseMusicAPI(ncm_cookie)
            songs = api.search_songs(search_text, limit=5)
            
            for i, song in enumerate(songs):
                song_id = song.get('id', '')
                title = song.get('title', 'æœªçŸ¥')
                artist = song.get('artist', 'æœªçŸ¥')
                album = song.get('album', '')
                
                # åˆ›å»ºç»“æœ
                results.append(
                    InlineQueryResultArticle(
                        id=f"ncm_{song_id}",
                        title=f"ğŸ”´ {title}",
                        description=f"{artist} Â· {album}" if album else artist,
                        input_message_content=InputTextMessageContent(
                            message_text=f"ğŸµ *{title}*\nğŸ‘¤ {artist}\nğŸ’¿ {album}\n\nğŸ”— ç½‘æ˜“äº‘: https://music.163.com/song?id={song_id}",
                            parse_mode='Markdown'
                        ),
                        thumbnail_url=song.get('cover', '')
                    )
                )
        
        # æœç´¢ QQ éŸ³ä¹
        qq_cookie = get_qq_cookie()
        if qq_cookie:
            from bot.ncm_downloader import QQMusicAPI
            api = QQMusicAPI(qq_cookie)
            songs = api.search_songs(search_text, limit=5)
            
            for i, song in enumerate(songs):
                song_id = song.get('id', '')
                mid = song.get('mid', '')
                title = song.get('title', 'æœªçŸ¥')
                artist = song.get('artist', 'æœªçŸ¥')
                album = song.get('album', '')
                
                results.append(
                    InlineQueryResultArticle(
                        id=f"qq_{song_id}",
                        title=f"ğŸŸ¢ {title}",
                        description=f"{artist} Â· {album}" if album else artist,
                        input_message_content=InputTextMessageContent(
                            message_text=f"ğŸµ *{title}*\nğŸ‘¤ {artist}\nğŸ’¿ {album}\n\nğŸ”— QQéŸ³ä¹: https://y.qq.com/n/ryqq/songDetail/{mid}",
                            parse_mode='Markdown'
                        ),
                        thumbnail_url=song.get('cover', '')
                    )
                )
        
        # ç¼“å­˜ç»“æœ
        _search_cache[cache_key] = (time.time(), results)
        
        # æ¸…ç†è¿‡æœŸç¼“å­˜
        if len(_search_cache) > 100:
            now = time.time()
            _search_cache.clear()
        
    except Exception as e:
        logger.error(f"Inline æœç´¢å¤±è´¥: {e}")
    
    await query.answer(results, cache_time=60)


async def cmd_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹å®šæ—¶åŒæ­¥æ­Œå•"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    playlists = get_scheduled_playlists(user_id)
    
    if not playlists:
        await update.message.reply_text(
            "ğŸ“… **å®šæ—¶åŒæ­¥æ­Œå•**\n\n"
            "æš‚æ— è®¢é˜…çš„æ­Œå•\n\n"
            "ğŸ’¡ åŒæ­¥æ­Œå•åä¼šè‡ªåŠ¨æ·»åŠ åˆ°å®šæ—¶åŒæ­¥åˆ—è¡¨",
            parse_mode='Markdown'
        )
        return
    
    default_interval = get_playlist_sync_interval()
    msg = "ğŸ“… **å®šæ—¶åŒæ­¥æ­Œå•**\n\n"
    for i, p in enumerate(playlists, 1):
        platform_icon = "ğŸ”´" if p['platform'] == 'netease' else "ğŸŸ¢"
        last_sync = p['last_sync_at'][:16] if p['last_sync_at'] else "æœªåŒæ­¥"
        # è·å–åŒæ­¥é—´éš”
        try:
            interval = p.get('sync_interval') or default_interval
        except:
            interval = default_interval
        interval = max(MIN_PLAYLIST_SYNC_INTERVAL_MINUTES, interval)
        if interval >= 60:
            hours = interval // 60
            minutes = interval % 60
            if minutes:
                interval_str = f"{hours}h{minutes}m"
            else:
                interval_str = f"{hours}h"
        else:
            interval_str = f"{interval}m"
        msg += f"`{i}.` {platform_icon} {p['playlist_name']}\n"
        msg += f"    ğŸ“Š {len(p['last_song_ids'])} é¦– Â· â± {interval_str} Â· æœ€ååŒæ­¥: {last_sync}\n\n"
    
    msg += f"ğŸ’¡ ä½¿ç”¨ `/unschedule <åºå·>` å–æ¶ˆè®¢é˜…\n"
    msg += f"ğŸ’¡ ä½¿ç”¨ `/syncinterval <åºå·> <åˆ†é’Ÿ>` è®¾ç½®åŒæ­¥é—´éš”"
    await update.message.reply_text(msg, parse_mode='Markdown')


async def cmd_syncinterval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """è®¾ç½®æ­Œå•åŒæ­¥é—´éš”
    ç®¡ç†å‘˜: /syncinterval æˆ– /syncinterval default <åˆ†é’Ÿ> è®¾ç½®å…¨å±€é»˜è®¤
    ç”¨æˆ·: /syncinterval <åºå·> <åˆ†é’Ÿ> è®¾ç½®è‡ªå·±æ­Œå•çš„åŒæ­¥é—´éš”
    """
    user_id = str(update.effective_user.id)
    is_admin = user_id in ADMIN_USER_IDS
    
    # è·å–å½“å‰å…¨å±€é»˜è®¤é—´éš”
    default_interval = get_playlist_sync_interval()
    
    if not context.args:
        # æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
        msg = f"â± **æ­Œå•åŒæ­¥é—´éš”è®¾ç½®**\n\n"
        msg += f"ğŸ“Š å½“å‰é»˜è®¤é—´éš”: **{default_interval} åˆ†é’Ÿ**\n\n"
        msg += f"**ç”¨æ³•:**\n"
        msg += f"â€¢ `/syncinterval <åºå·> <åˆ†é’Ÿ>` - è®¾ç½®æŒ‡å®šæ­Œå•çš„åŒæ­¥é—´éš”\n"
        if is_admin:
            msg += f"â€¢ `/syncinterval default <åˆ†é’Ÿ>` - è®¾ç½®å…¨å±€é»˜è®¤é—´éš”\n"
        msg += f"\n**ç¤ºä¾‹:**\n"
        msg += f"â€¢ `/syncinterval 1 30` - ç¬¬1ä¸ªæ­Œå•æ¯30åˆ†é’ŸåŒæ­¥\n"
        if is_admin:
            msg += f"â€¢ `/syncinterval default 60` - å…¨å±€é»˜è®¤æ¯60åˆ†é’ŸåŒæ­¥\n"
        msg += f"\nğŸ’¡ æœ€å°é—´éš”: {MIN_PLAYLIST_SYNC_INTERVAL_MINUTES} åˆ†é’Ÿ"
        await update.message.reply_text(msg, parse_mode='Markdown')
        return
    
    # ç®¡ç†å‘˜è®¾ç½®å…¨å±€é»˜è®¤é—´éš”
    if context.args[0].lower() == 'default':
        if not is_admin:
            await update.message.reply_text("âŒ åªæœ‰ç®¡ç†å‘˜å¯ä»¥è®¾ç½®å…¨å±€é»˜è®¤é—´éš”")
            return
        
        if len(context.args) < 2:
            await update.message.reply_text(f"å½“å‰å…¨å±€é»˜è®¤é—´éš”: {default_interval} åˆ†é’Ÿ\nç”¨æ³•: `/syncinterval default <åˆ†é’Ÿ>`", parse_mode='Markdown')
            return
        
        try:
            interval = int(context.args[1])
            if interval < MIN_PLAYLIST_SYNC_INTERVAL_MINUTES:
                await update.message.reply_text(f"âŒ é—´éš”ä¸èƒ½å°äº {MIN_PLAYLIST_SYNC_INTERVAL_MINUTES} åˆ†é’Ÿ")
                return
            if interval > 10080:  # æœ€å¤§ä¸€å‘¨ï¼ˆ7*24*60ï¼‰
                await update.message.reply_text("âŒ é—´éš”ä¸èƒ½è¶…è¿‡ 10080 åˆ†é’Ÿï¼ˆä¸€å‘¨ï¼‰")
                return
            
            # ä¿å­˜åˆ°æ•°æ®åº“
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO bot_settings (key, value, updated_at)
                    VALUES (?, ?, ?)
                ''', ('playlist_sync_interval', str(interval), datetime.now().isoformat()))
                database_conn.commit()
            
            await update.message.reply_text(f"âœ… å·²è®¾ç½®å…¨å±€é»˜è®¤åŒæ­¥é—´éš”ä¸º **{interval} åˆ†é’Ÿ**", parse_mode='Markdown')
            
        except ValueError:
            await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
        return
    
    # ç”¨æˆ·è®¾ç½®è‡ªå·±æ­Œå•çš„åŒæ­¥é—´éš”
    try:
        index = int(context.args[0]) - 1
        
        if len(context.args) < 2:
            await update.message.reply_text("ç”¨æ³•: `/syncinterval <åºå·> <åˆ†é’Ÿ>`\nä¾‹å¦‚: `/syncinterval 1 30`", parse_mode='Markdown')
            return
        
        interval = int(context.args[1])
        if interval < MIN_PLAYLIST_SYNC_INTERVAL_MINUTES:
            await update.message.reply_text(f"âŒ é—´éš”ä¸èƒ½å°äº {MIN_PLAYLIST_SYNC_INTERVAL_MINUTES} åˆ†é’Ÿ")
            return
        if interval > 10080:  # æœ€å¤§ä¸€å‘¨
            await update.message.reply_text("âŒ é—´éš”ä¸èƒ½è¶…è¿‡ 10080 åˆ†é’Ÿï¼ˆä¸€å‘¨ï¼‰")
            return
        
        # è·å–ç”¨æˆ·çš„æ­Œå•åˆ—è¡¨
        playlists = get_scheduled_playlists(user_id)
        
        if index < 0 or index >= len(playlists):
            await update.message.reply_text("âŒ åºå·æ— æ•ˆï¼Œè¯·ä½¿ç”¨ /schedule æŸ¥çœ‹æ­Œå•åˆ—è¡¨")
            return
        
        playlist = playlists[index]
        
        # æ›´æ–°æ•°æ®åº“
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('''
                UPDATE scheduled_playlists SET sync_interval = ?
                WHERE id = ?
            ''', (interval, playlist['id']))
            database_conn.commit()
        
        await update.message.reply_text(
            f"âœ… å·²è®¾ç½®æ­Œå• **{playlist['playlist_name']}** çš„åŒæ­¥é—´éš”ä¸º **{interval} åˆ†é’Ÿ**",
            parse_mode='Markdown'
        )
        
    except ValueError:
        await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—\nç”¨æ³•: `/syncinterval <åºå·> <åˆ†é’Ÿ>`", parse_mode='Markdown')


async def cmd_scaninterval(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """è®¾ç½® Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æé—´éš”"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    # è·å–å½“å‰è®¾ç½®
    current_interval = EMBY_SCAN_INTERVAL
    try:
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
            row = cursor.fetchone()
            if row:
                current_interval = int(row[0] if isinstance(row, tuple) else row['value'])
    except:
        pass
    
    if not context.args:
        status = f"æ¯ {current_interval} å°æ—¶" if current_interval > 0 else "å·²ç¦ç”¨"
        await update.message.reply_text(
            f"ğŸ”„ **Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æ**\n\n"
            f"å½“å‰çŠ¶æ€: {status}\n\n"
            f"ç”¨æ³•: `/scaninterval <å°æ—¶>`\n"
            f"ç¤ºä¾‹:\n"
            f"â€¢ `/scaninterval 6` - æ¯ 6 å°æ—¶æ‰«æ\n"
            f"â€¢ `/scaninterval 0` - ç¦ç”¨è‡ªåŠ¨æ‰«æ\n\n"
            f"ğŸ’¡ ä¹Ÿå¯åœ¨ Web è®¾ç½®é¡µé¢é…ç½®",
            parse_mode='Markdown'
        )
        return
    
    try:
        interval = int(context.args[0])
        if interval < 0:
            await update.message.reply_text("âŒ é—´éš”ä¸èƒ½ä¸ºè´Ÿæ•°")
            return
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        if database_conn:
            cursor = database_conn.cursor()
            cursor.execute('''
                INSERT OR REPLACE INTO bot_settings (key, value, updated_at)
                VALUES (?, ?, ?)
            ''', ('emby_scan_interval', str(interval), datetime.now().isoformat()))
            database_conn.commit()
        
        if interval == 0:
            await update.message.reply_text("âœ… å·²ç¦ç”¨ Emby è‡ªåŠ¨æ‰«æ")
        else:
            await update.message.reply_text(f"âœ… å·²è®¾ç½® Emby è‡ªåŠ¨æ‰«æé—´éš”ä¸º {interval} å°æ—¶")
            
    except ValueError:
        await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")


async def cmd_unschedule(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å–æ¶ˆå®šæ—¶åŒæ­¥æ­Œå•"""
    user_id = str(update.effective_user.id)
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("æ— æƒæ‰§è¡Œæ­¤å‘½ä»¤")
        return
    
    if not context.args:
        await update.message.reply_text("ç”¨æ³•: /unschedule <åºå·>\nä¾‹å¦‚: /unschedule 1")
        return
    
    try:
        index = int(context.args[0]) - 1
        playlists = get_scheduled_playlists(user_id)
        
        if index < 0 or index >= len(playlists):
            await update.message.reply_text("âŒ åºå·æ— æ•ˆ")
            return
        
        playlist = playlists[index]
        if delete_scheduled_playlist(playlist['id'], user_id):
            await update.message.reply_text(f"âœ… å·²å–æ¶ˆè®¢é˜…: {playlist['playlist_name']}")
        else:
            await update.message.reply_text("âŒ å–æ¶ˆå¤±è´¥")
    except ValueError:
        await update.message.reply_text("âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„åºå·")


async def handle_sync_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†å®šæ—¶åŒæ­¥ç›¸å…³çš„å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        await query.edit_message_text("æ— æƒæ‰§è¡Œæ­¤æ“ä½œ")
        return
    
    data = query.data
    
    if data.startswith("sync_dl_"):
        # ä¸‹è½½æ–°æ­Œ
        playlist_id = int(data.replace("sync_dl_", ""))
        playlists = get_scheduled_playlists(user_id)
        playlist = next((p for p in playlists if p['id'] == playlist_id), None)
        
        if not playlist:
            await query.edit_message_text("âŒ æ­Œå•ä¸å­˜åœ¨")
            return
        
        await query.edit_message_text("ğŸ“¥ æ­£åœ¨è·å–æ–°æ­Œæ›²...")
        
        # è·å–æ­Œå•å¹¶æ‰¾å‡ºæ–°æ­Œæ›²
        try:
            platform = playlist['platform']
            playlist_url = playlist['playlist_url']
            old_song_ids = set(playlist['last_song_ids'])
            
            if platform == 'netease':
                playlist_id_str = extract_playlist_id(playlist_url, 'netease')
                _, songs = get_ncm_playlist_details(playlist_id_str)
            elif platform == 'qq':
                playlist_id_str = extract_playlist_id(playlist_url, 'qq')
                _, songs = get_qq_playlist_details(playlist_id_str)
            else:
                await query.message.reply_text("âŒ ä¸æ”¯æŒçš„å¹³å°")
                return
            
            new_songs = [s for s in songs if str(s.get('source_id') or s.get('id') or s.get('title', '')) not in old_song_ids]
            
            if not new_songs:
                await query.message.reply_text("æ²¡æœ‰æ–°æ­Œæ›²éœ€è¦ä¸‹è½½")
                return
            
            # å¼€å§‹ä¸‹è½½
            ncm_cookie = get_ncm_cookie()
            if not ncm_cookie:
                await query.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
                return
            
            from bot.ncm_downloader import MusicAutoDownloader
            ncm_settings = get_ncm_settings()
            download_quality = ncm_settings.get('ncm_quality', 'exhigh')
            download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
            
            download_path = Path(download_dir)
            download_path.mkdir(parents=True, exist_ok=True)
            
            # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
            qq_cookie = get_qq_cookie()
            
            downloader = MusicAutoDownloader(
                ncm_cookie, qq_cookie, str(download_path),
                proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
            )
            
            progress_msg = await query.message.reply_text(
                make_progress_message("ğŸ“¥ ä¸‹è½½æ–°æ­Œæ›²", 0, len(new_songs), "å‡†å¤‡å¼€å§‹...")
            )
            main_loop = asyncio.get_running_loop()
            last_update_time = [0]
            
            async def update_progress(current, total, song):
                import time as time_module
                now = time_module.time()
                if now - last_update_time[0] < 1.5:
                    return
                last_update_time[0] = now
                try:
                    song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                    await progress_msg.edit_text(
                        make_progress_message("ğŸ“¥ ä¸‹è½½æ–°æ­Œæ›²", current, total, song_name),
                        parse_mode='Markdown'
                    )
                except:
                    pass
            
            def sync_progress_callback(current, total, song, status=None):
                main_loop.call_soon_threadsafe(
                    lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
                )
            
            success_results, failed = await asyncio.to_thread(
                downloader.download_missing_songs,
                new_songs,
                download_quality,
                sync_progress_callback
            )
            
            # æå–æ–‡ä»¶åˆ—è¡¨
            success_files = [r['file'] for r in success_results]
            
            try:
                await progress_msg.delete()
            except:
                pass
            
            # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰
            save_download_record_v2(success_results, failed, download_quality, user_id)
            
            # æ›´æ–°æ­Œæ›²åˆ—è¡¨
            current_song_ids = [str(s.get('source_id') or s.get('id') or s.get('title', '')) for s in songs]
            update_scheduled_playlist_songs(playlist['id'], current_song_ids, playlist['playlist_name'])
            
            # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
            ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
            qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
            platform_info = f"\nâ€¢ ç½‘æ˜“äº‘: {ncm_count}, QQéŸ³ä¹: {qq_count}" if qq_count > 0 else ""
            
            await query.message.reply_text(
                f"âœ… ä¸‹è½½å®Œæˆ\næˆåŠŸ: {len(success_files)} é¦–{platform_info}\nå¤±è´¥: {len(failed)} é¦–"
            )
            
        except Exception as e:
            logger.exception(f"ä¸‹è½½æ–°æ­Œæ›²å¤±è´¥: {e}")
            await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")
    
    elif data.startswith("sync_emby_"):
        # åŒæ­¥åˆ° Emby
        playlist_id = int(data.replace("sync_emby_", ""))
        playlists = get_scheduled_playlists(user_id)
        playlist = next((p for p in playlists if p['id'] == playlist_id), None)
        
        if not playlist:
            await query.edit_message_text("âŒ æ­Œå•ä¸å­˜åœ¨")
            return
        
        # é‡æ–°åŒæ­¥æ•´ä¸ªæ­Œå•åˆ° Emby
        await query.edit_message_text("ğŸ”„ æ­£åœ¨åŒæ­¥åˆ° Emby...")
        
        # è§¦å‘æ­Œå•åŒæ­¥
        context.user_data['sync_playlist_url'] = playlist['playlist_url']
        context.user_data['sync_from_scheduled'] = True
        
        # æ¨¡æ‹Ÿå‘é€æ­Œå•é“¾æ¥
        await query.message.reply_text(f"è¯·ç¨å€™ï¼Œæ­£åœ¨å¤„ç†æ­Œå•...")


async def cmd_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ç”³è¯·åŒæ­¥æ­Œå• - ç”¨æˆ·æäº¤æ­Œå•é“¾æ¥ï¼Œç®¡ç†å‘˜å®¡æ ¸åä¸‹è½½ç¼ºå¤±æ­Œæ›²"""
    user_id = str(update.effective_user.id)
    
    # æ£€æŸ¥ç”³è¯·æƒé™
    if not check_user_permission(user_id, 'request'):
        await update.message.reply_text("âŒ ä½ æ²¡æœ‰ç”³è¯·æƒé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return
    
    args = ' '.join(context.args) if context.args else ''
    
    if not args:
        await update.message.reply_text(
            "ğŸ“ **ç”³è¯·åŒæ­¥æ­Œå•**\n\n"
            "å‘é€æ­Œå•é“¾æ¥ç”³è¯·åŒæ­¥åˆ°éŸ³ä¹åº“ï¼Œç®¡ç†å‘˜å®¡æ ¸é€šè¿‡åä¼šè‡ªåŠ¨ä¸‹è½½ç¼ºå¤±çš„æ­Œæ›²ã€‚\n\n"
            "**ç”¨æ³•ï¼š**\n"
            "`/request <æ­Œå•é“¾æ¥>`\n\n"
            "**æ”¯æŒå¹³å°ï¼š**\n"
            "â€¢ ç½‘æ˜“äº‘éŸ³ä¹\n"
            "â€¢ QQéŸ³ä¹\n"
            "â€¢ Spotify\n\n"
            "**ç¤ºä¾‹ï¼š**\n"
            "`/request https://music.163.com/playlist?id=123456`\n"
            "`/request https://y.qq.com/n/ryqq/playlist/123456`\n"
            "`/request https://open.spotify.com/playlist/xxxxx`",
            parse_mode='Markdown'
        )
        return
    
    # è§£ææ­Œå•é“¾æ¥
    import re
    playlist_url = args.strip()
    
    # æ£€æµ‹å¹³å°
    platform = None
    playlist_id = None
    playlist_name = "æœªçŸ¥æ­Œå•"
    song_count = 0
    
    if 'music.163.com' in playlist_url or 'y.music.163.com' in playlist_url:
        platform = 'netease'
        playlist_id = extract_playlist_id(playlist_url, 'netease')
    elif 'y.qq.com' in playlist_url or 'qq.com' in playlist_url:
        platform = 'qq'
        playlist_id = extract_playlist_id(playlist_url, 'qq')
    elif 'spotify.com' in playlist_url or 'spotify:' in playlist_url:
        platform = 'spotify'
        playlist_id = extract_playlist_id(playlist_url, 'spotify')
    
    if not platform or not playlist_id:
        await update.message.reply_text(
            "âŒ æ— æ³•è¯†åˆ«æ­Œå•é“¾æ¥\n\n"
            "æ”¯æŒçš„å¹³å°ï¼šç½‘æ˜“äº‘éŸ³ä¹ã€QQéŸ³ä¹ã€Spotify"
        )
        return
    
    # è·å–æ­Œå•ä¿¡æ¯
    try:
        if platform == 'netease':
            playlist_name, songs = get_ncm_playlist_details(playlist_id)
        elif platform == 'spotify':
            playlist_name, songs = get_spotify_playlist_details(playlist_id)
        else:
            playlist_name, songs = get_qq_playlist_details(playlist_id)
        song_count = len(songs) if songs else 0
    except Exception as e:
        logger.warning(f"è·å–æ­Œå•ä¿¡æ¯å¤±è´¥: {e}")
        playlist_name = f"æ­Œå• {playlist_id}"
    
    # æ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒç”³è¯·
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            SELECT id, status FROM playlist_requests 
            WHERE telegram_id = ? AND playlist_url = ? AND status = 'pending'
        ''', (user_id, playlist_url))
        existing = cursor.fetchone()
        if existing:
            await update.message.reply_text("â³ ä½ å·²ç»ç”³è¯·è¿‡è¿™ä¸ªæ­Œå•ï¼Œè¯·ç­‰å¾…ç®¡ç†å‘˜å®¡æ ¸")
            return
    except:
        pass
    
    # åˆ›å»ºç”³è¯·è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS playlist_requests (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id TEXT NOT NULL,
                playlist_url TEXT NOT NULL,
                playlist_name TEXT,
                platform TEXT,
                song_count INTEGER DEFAULT 0,
                status TEXT DEFAULT 'pending',
                admin_note TEXT,
                download_count INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                processed_at TIMESTAMP
            )
        ''')
        database_conn.commit()
    except:
        pass
    
    # æäº¤ç”³è¯·
    try:
        cursor = database_conn.cursor()
        cursor.execute('''
            INSERT INTO playlist_requests (telegram_id, playlist_url, playlist_name, platform, song_count)
            VALUES (?, ?, ?, ?, ?)
        ''', (user_id, playlist_url, playlist_name, platform, song_count))
        database_conn.commit()
        request_id = cursor.lastrowid
        
        platform_name = "ç½‘æ˜“äº‘éŸ³ä¹" if platform == 'netease' else "QQéŸ³ä¹"
        
        await update.message.reply_text(
            f"âœ… **ç”³è¯·å·²æäº¤**\n\n"
            f"ğŸ“‹ æ­Œå•: {playlist_name}\n"
            f"ğŸµ å¹³å°: {platform_name}\n"
            f"ğŸ”¢ æ­Œæ›²æ•°: {song_count}\n\n"
            f"ç®¡ç†å‘˜å®¡æ ¸é€šè¿‡åä¼šè‡ªåŠ¨ä¸‹è½½ç¼ºå¤±çš„æ­Œæ›²",
            parse_mode='Markdown'
        )
        
        # é€šçŸ¥ç®¡ç†å‘˜
        if ADMIN_USER_IDS:
            user = update.effective_user
            user_info = f"@{user.username}" if user.username else f"{user.first_name} ({user_id})"
            
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("âœ… æ‰¹å‡†å¹¶ä¸‹è½½", callback_data=f"req_approve_{request_id}"),
                    InlineKeyboardButton("âŒ æ‹’ç»", callback_data=f"req_reject_{request_id}")
                ],
                [
                    InlineKeyboardButton("ğŸ‘ï¸ é¢„è§ˆæ­Œå•", callback_data=f"req_preview_{request_id}")
                ]
            ])
            
            admin_msg = (
                f"ğŸ“ **æ–°æ­Œå•åŒæ­¥ç”³è¯·**\n\n"
                f"ğŸ‘¤ ç”¨æˆ·: {user_info}\n"
                f"ğŸ“‹ æ­Œå•: {playlist_name}\n"
                f"ğŸµ å¹³å°: {platform_name}\n"
                f"ğŸ”¢ æ­Œæ›²æ•°: {song_count}\n"
                f"ğŸ”— é“¾æ¥: {playlist_url}"
            )
            
            # é€šçŸ¥æ‰€æœ‰ç®¡ç†å‘˜
            for admin_id in ADMIN_USER_IDS:
                try:
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=admin_msg,
                        parse_mode='Markdown',
                        reply_markup=keyboard
                    )
                except Exception as e:
                    logger.error(f"é€šçŸ¥ç®¡ç†å‘˜ {admin_id} å¤±è´¥: {e}")
                
    except Exception as e:
        logger.error(f"æäº¤æ­Œå•ç”³è¯·å¤±è´¥: {e}")
        await update.message.reply_text(f"âŒ æäº¤å¤±è´¥: {e}")


async def cmd_myrequests(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """æŸ¥çœ‹æˆ‘çš„æ­Œå•ç”³è¯·"""
    user_id = str(update.effective_user.id)
    
    try:
        if database_conn:
            cursor = database_conn.cursor()
            
            # å…ˆæŸ¥æ­Œå•ç”³è¯·
            cursor.execute('''
                SELECT * FROM playlist_requests 
                WHERE telegram_id = ? 
                ORDER BY created_at DESC 
                LIMIT 10
            ''', (user_id,))
            rows = cursor.fetchall()
            
            if not rows:
                await update.message.reply_text("ğŸ“ ä½ è¿˜æ²¡æœ‰æäº¤è¿‡ç”³è¯·")
                return
            
            msg = "ğŸ“ **æˆ‘çš„æ­Œå•ç”³è¯·**\n\n"
            for row in rows:
                status_emoji = {'pending': 'â³', 'approved': 'âœ…', 'rejected': 'âŒ'}.get(row['status'], 'â“')
                platform_name = "ç½‘æ˜“äº‘" if row['platform'] == 'netease' else "QQéŸ³ä¹"
                msg += f"{status_emoji} {row['playlist_name']}\n"
                msg += f"   ğŸµ {platform_name} Â· {row['song_count']} é¦–\n"
                msg += f"   çŠ¶æ€: {row['status']}"
                if row['download_count']:
                    msg += f" (å·²ä¸‹è½½ {row['download_count']} é¦–)"
                if row['admin_note']:
                    msg += f"\n   å¤‡æ³¨: {row['admin_note']}"
                msg += "\n\n"
            
            await update.message.reply_text(msg, parse_mode='Markdown')
    except Exception as e:
        await update.message.reply_text(f"âŒ æŸ¥è¯¢å¤±è´¥: {e}")


async def handle_request_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æ­Œå•ç”³è¯·å®¡æ ¸å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        await query.answer("ä»…ç®¡ç†å‘˜å¯æ“ä½œ", show_alert=True)
        return
    
    data = query.data
    
    if data.startswith("req_approve_"):
        request_id = int(data.replace("req_approve_", ""))
        await process_playlist_request(query, context, request_id, 'approved')
        
    elif data.startswith("req_reject_"):
        request_id = int(data.replace("req_reject_", ""))
        await process_playlist_request(query, context, request_id, 'rejected')
    
    elif data.startswith("req_preview_"):
        request_id = int(data.replace("req_preview_", ""))
        await preview_playlist_request(query, context, request_id)


async def preview_playlist_request(query, context, request_id: int):
    """é¢„è§ˆæ­Œå•å†…å®¹"""
    try:
        cursor = database_conn.cursor()
        cursor.execute('SELECT * FROM playlist_requests WHERE id = ?', (request_id,))
        row = cursor.fetchone()
        
        if not row:
            await query.message.reply_text("âŒ ç”³è¯·ä¸å­˜åœ¨")
            return
        
        playlist_url = row['playlist_url']
        platform = row['platform']
        
        # è·å–æ­Œå•è¯¦æƒ…
        if platform == 'netease':
            playlist_id = extract_playlist_id(playlist_url, 'netease')
            playlist_name, songs = get_ncm_playlist_details(playlist_id)
        else:
            playlist_id = extract_playlist_id(playlist_url, 'qq')
            playlist_name, songs = get_qq_playlist_details(playlist_id)
        
        if not songs:
            await query.message.reply_text("âŒ è·å–æ­Œå•å†…å®¹å¤±è´¥")
            return
        
        # æ˜¾ç¤ºå‰10é¦–
        msg = f"ğŸ“‹ **{playlist_name}** ({len(songs)} é¦–)\n\n"
        for i, song in enumerate(songs[:10]):
            msg += f"{i+1}. {song.get('title', 'æœªçŸ¥')} - {song.get('artist', 'æœªçŸ¥')}\n"
        
        if len(songs) > 10:
            msg += f"\n... è¿˜æœ‰ {len(songs) - 10} é¦–"
        
        await query.message.reply_text(msg, parse_mode='Markdown')
        
    except Exception as e:
        await query.message.reply_text(f"âŒ é¢„è§ˆå¤±è´¥: {e}")


async def process_playlist_request(query, context, request_id: int, action: str):
    """å¤„ç†æ­Œå•ç”³è¯·ï¼ˆæ‰¹å‡†/æ‹’ç»ï¼‰"""
    try:
        cursor = database_conn.cursor()
        cursor.execute('SELECT * FROM playlist_requests WHERE id = ?', (request_id,))
        row = cursor.fetchone()
        
        if not row:
            await query.message.reply_text("âŒ ç”³è¯·ä¸å­˜åœ¨")
            return
        
        requester_id = row['telegram_id']
        playlist_url = row['playlist_url']
        playlist_name = row['playlist_name']
        platform = row['platform']
        
        if action == 'rejected':
            # æ‹’ç»ç”³è¯·
            cursor.execute('''
                UPDATE playlist_requests 
                SET status = 'rejected', processed_at = CURRENT_TIMESTAMP 
                WHERE id = ?
            ''', (request_id,))
            database_conn.commit()
            
            await query.edit_message_text(
                query.message.text + "\n\nâŒ **å·²æ‹’ç»**",
                parse_mode='Markdown'
            )
            
            # é€šçŸ¥ç”¨æˆ·
            try:
                await context.bot.send_message(
                    chat_id=requester_id,
                    text=f"âŒ ä½ çš„æ­Œå•ç”³è¯·è¢«æ‹’ç»\n\nğŸ“‹ æ­Œå•: {playlist_name}"
                )
            except:
                pass
            return
        
        # æ‰¹å‡†å¹¶ä¸‹è½½
        await query.edit_message_text(
            query.message.text + "\n\nâ³ **æ­£åœ¨åŒ¹é…å¹¶ä¸‹è½½ç¼ºå¤±æ­Œæ›²...**",
            parse_mode='Markdown'
        )
        
        # è·å–æ­Œå•å†…å®¹
        if platform == 'netease':
            playlist_id = extract_playlist_id(playlist_url, 'netease')
            _, songs = get_ncm_playlist_details(playlist_id)
        else:
            playlist_id = extract_playlist_id(playlist_url, 'qq')
            _, songs = get_qq_playlist_details(playlist_id)
        
        if not songs:
            await query.message.reply_text("âŒ è·å–æ­Œå•å†…å®¹å¤±è´¥")
            return
        
        # åŒ¹é… Emby åª’ä½“åº“ï¼Œæ‰¾å‡ºç¼ºå¤±æ­Œæ›²
        # ä½¿ç”¨ç¬¬ä¸€ä¸ªç®¡ç†å‘˜çš„ç»‘å®š
        admin_binding = None
        for admin_id in ADMIN_USER_IDS:
            admin_binding = get_user_binding(admin_id)
            if admin_binding:
                break
        if not admin_binding:
            await query.message.reply_text("âŒ ç®¡ç†å‘˜æœªç»‘å®š Emby")
            return
        
        # è·å–åª’ä½“åº“
        library_songs = load_library_cache()
        if not library_songs:
            await query.message.reply_text("âŒ åª’ä½“åº“ç¼“å­˜ä¸ºç©ºï¼Œè¯·å…ˆ /rescan")
            return
        
        # åŒ¹é…
        missing_songs = []
        for song in songs:
            matched = False
            song_title = song.get('title', '')
            song_artist = song.get('artist', '')
            
            for lib_song in library_songs:
                lib_title = lib_song.get('Name', '')
                lib_artist = lib_song.get('Artists', [''])[0] if lib_song.get('Artists') else ''
                
                # æ¨¡ç³ŠåŒ¹é…
                title_ratio = fuzz.ratio(song_title.lower(), lib_title.lower())
                if title_ratio > 85:
                    artist_ratio = fuzz.ratio(song_artist.lower(), lib_artist.lower())
                    if artist_ratio > 70 or not song_artist:
                        matched = True
                        break
            
            if not matched:
                missing_songs.append(song)
        
        if not missing_songs:
            # æ›´æ–°çŠ¶æ€
            cursor.execute('''
                UPDATE playlist_requests 
                SET status = 'approved', download_count = 0, processed_at = CURRENT_TIMESTAMP 
                WHERE id = ?
            ''', (request_id,))
            database_conn.commit()
            
            await query.edit_message_text(
                query.message.text.replace("â³ **æ­£åœ¨åŒ¹é…å¹¶ä¸‹è½½ç¼ºå¤±æ­Œæ›²...**", "") +
                "\n\nâœ… **å·²æ‰¹å‡†** - æ‰€æœ‰æ­Œæ›²å·²åœ¨åª’ä½“åº“ä¸­",
                parse_mode='Markdown'
            )
            
            try:
                await context.bot.send_message(
                    chat_id=requester_id,
                    text=f"âœ… ä½ çš„æ­Œå•ç”³è¯·å·²é€šè¿‡ï¼\n\nğŸ“‹ æ­Œå•: {playlist_name}\nğŸµ æ‰€æœ‰æ­Œæ›²å·²åœ¨éŸ³ä¹åº“ä¸­"
                )
            except:
                pass
            return
        
        # ä¸‹è½½ç¼ºå¤±æ­Œæ›²
        ncm_cookie = get_ncm_cookie()
        if not ncm_cookie:
            await query.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
            return
        
        from bot.ncm_downloader import MusicAutoDownloader
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        
        # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
        qq_cookie = get_qq_cookie()
        
        downloader = MusicAutoDownloader(
            ncm_cookie, qq_cookie, download_dir,
            proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
        )
        
        progress_msg = await query.message.reply_text(
            f"ğŸ“¥ æ­£åœ¨ä¸‹è½½ {len(missing_songs)} é¦–ç¼ºå¤±æ­Œæ›²..."
        )
        
        main_loop = asyncio.get_running_loop()
        last_update_time = [0]
        
        async def update_progress(current, total, song):
            import time as time_module
            now = time_module.time()
            if now - last_update_time[0] < 2:
                return
            last_update_time[0] = now
            try:
                await progress_msg.edit_text(
                    f"ğŸ“¥ ä¸‹è½½ä¸­ ({current}/{total})\nğŸµ {song.get('title', '')} - {song.get('artist', '')}"
                )
            except:
                pass
        
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        success_results, failed_songs = await asyncio.to_thread(
            downloader.download_missing_songs,
            missing_songs,
            download_quality,
            sync_progress_callback
        )
        
        # æå–æ–‡ä»¶åˆ—è¡¨
        success_files = [r['file'] for r in success_results]
        
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰- ä½¿ç”¨ç¬¬ä¸€ä¸ªç®¡ç†å‘˜ID
        first_admin_id = ADMIN_USER_IDS[0] if ADMIN_USER_IDS else ''
        save_download_record_v2(success_results, failed_songs, download_quality, first_admin_id)
        
        # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        platform_info = f"\n   â€¢ ç½‘æ˜“äº‘: {ncm_count}, QQéŸ³ä¹: {qq_count}" if qq_count > 0 else ""
        
        # æ›´æ–°ç”³è¯·çŠ¶æ€
        cursor.execute('''
            UPDATE playlist_requests 
            SET status = 'approved', download_count = ?, processed_at = CURRENT_TIMESTAMP 
            WHERE id = ?
        ''', (len(success_files), request_id))
        database_conn.commit()
        
        await query.edit_message_text(
            query.message.text.replace("â³ **æ­£åœ¨åŒ¹é…å¹¶ä¸‹è½½ç¼ºå¤±æ­Œæ›²...**", "") +
            f"\n\nâœ… **å·²æ‰¹å‡†å¹¶ä¸‹è½½**\n"
            f"ğŸ“Š ç¼ºå¤±: {len(missing_songs)} é¦–\n"
            f"âœ… æˆåŠŸ: {len(success_files)} é¦–{platform_info}\n"
            f"âŒ å¤±è´¥: {len(failed_songs)} é¦–",
            parse_mode='Markdown'
        )
        
        # é€šçŸ¥ç”¨æˆ·
        try:
            await context.bot.send_message(
                chat_id=requester_id,
                text=f"âœ… ä½ çš„æ­Œå•ç”³è¯·å·²é€šè¿‡ï¼\n\n"
                     f"ğŸ“‹ æ­Œå•: {playlist_name}\n"
                     f"ğŸ“¥ å·²ä¸‹è½½ {len(success_files)} é¦–æ–°æ­Œæ›²åˆ°éŸ³ä¹åº“"
            )
        except:
            pass
        
        # è§¦å‘ Emby æ‰«åº“
        if success_files:
            try:
                user_access_token, user_id_emby = authenticate_emby(
                    EMBY_URL, admin_binding['emby_username'], decrypt_password(admin_binding['emby_password'])
                )
                if user_access_token:
                    user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                    trigger_emby_library_scan(user_auth)
            except:
                pass
                
    except Exception as e:
        logger.exception(f"å¤„ç†æ­Œå•ç”³è¯·å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ å¤„ç†å¤±è´¥: {e}")


async def handle_preview_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†ç½‘æ˜“äº‘è¯•å¬å›è°ƒ"""
    query = update.callback_query
    await query.answer("ğŸ§ æ­£åœ¨è·å–è¯•å¬...")
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        return
    
    data = query.data
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await query.message.reply_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    try:
        idx = int(data.replace("preview_song_", ""))
        search_results = context.user_data.get('search_results', [])
        
        if not search_results or idx >= len(search_results):
            await query.message.reply_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
            return
        
        song = search_results[idx]
        song_id = song['source_id']
        
        from bot.ncm_downloader import NeteaseMusicAPI
        api = NeteaseMusicAPI(ncm_cookie)
        
        # è·å–æ­Œæ›²URLï¼ˆä½¿ç”¨æ ‡å‡†éŸ³è´¨ä»¥åŠ å¿«é€Ÿåº¦ï¼‰
        song_urls = api.get_song_url([song_id], 'standard')
        
        if not song_urls or song_id not in song_urls:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥ï¼Œå¯èƒ½æ˜¯ç‰ˆæƒé™åˆ¶")
            return
        
        url_info = song_urls[song_id]
        audio_url = url_info.get('url')
        
        if not audio_url:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥")
            return
        
        # å‘é€éŸ³é¢‘
        caption = f"ğŸµ {song['title']}\nğŸ¤ {song['artist']}\nğŸ“€ {song.get('album', 'æœªçŸ¥ä¸“è¾‘')}"
        await query.message.reply_audio(
            audio=audio_url,
            caption=caption,
            title=song['title'],
            performer=song['artist']
        )
        
    except Exception as e:
        logger.exception(f"è¯•å¬å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ è¯•å¬å¤±è´¥: {e}")


async def handle_qq_preview_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†QQéŸ³ä¹è¯•å¬å›è°ƒ"""
    query = update.callback_query
    await query.answer("ğŸ§ æ­£åœ¨è·å–è¯•å¬...")
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        return
    
    data = query.data
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await query.message.reply_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookie")
        return
    
    try:
        idx = int(data.replace("qpreview_song_", ""))
        search_results = context.user_data.get('qq_search_results', [])
        
        if not search_results or idx >= len(search_results):
            await query.message.reply_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
            return
        
        song = search_results[idx]
        song_mid = song['source_id']
        
        from bot.ncm_downloader import QQMusicAPI
        api = QQMusicAPI(qq_cookie)
        
        # è·å–æ­Œæ›²URLï¼ˆä½¿ç”¨æ ‡å‡†éŸ³è´¨ï¼‰
        song_urls = api.get_song_url([song_mid], 'standard')
        
        if not song_urls or song_mid not in song_urls:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥ï¼Œå¯èƒ½æ˜¯ç‰ˆæƒé™åˆ¶")
            return
        
        url_info = song_urls[song_mid]
        audio_url = url_info.get('url')
        
        if not audio_url:
            await query.message.reply_text("âŒ æ— æ³•è·å–è¯•å¬é“¾æ¥")
            return
        
        # å‘é€éŸ³é¢‘
        caption = f"ğŸµ {song['title']}\nğŸ¤ {song['artist']}\nğŸ“€ {song.get('album', 'æœªçŸ¥ä¸“è¾‘')}"
        await query.message.reply_audio(
            audio=audio_url,
            caption=caption,
            title=song['title'],
            performer=song['artist']
        )
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹è¯•å¬å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ è¯•å¬å¤±è´¥: {e}")


async def handle_search_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æœç´¢ç»“æœä¸‹è½½å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
        return
    
    data = query.data
    ncm_cookie = get_ncm_cookie()
    
    if not ncm_cookie:
        await query.edit_message_text("âŒ æœªé…ç½®ç½‘æ˜“äº‘ Cookie")
        return
    
    try:
        from bot.ncm_downloader import MusicAutoDownloader, NeteaseMusicAPI
        
        # è·å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        organize_dir = ncm_settings.get('organize_dir', '')
        
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        # è·å– QQ éŸ³ä¹ Cookie ç”¨äºé™çº§ä¸‹è½½
        qq_cookie = get_qq_cookie()
        
        downloader = MusicAutoDownloader(
            ncm_cookie, qq_cookie, str(download_path),
            proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY
        )
        
        songs_to_download = []
        
        if data.startswith("dl_song_"):
            # ä¸‹è½½å•æ›²æˆ–å…¨éƒ¨
            search_results = context.user_data.get('search_results', [])
            if not search_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            if data == "dl_song_all":
                songs_to_download = search_results
            else:
                idx = int(data.replace("dl_song_", ""))
                if idx < len(search_results):
                    songs_to_download = [search_results[idx]]
        
        elif data.startswith("dl_album_"):
            # ä¸‹è½½ä¸“è¾‘
            album_results = context.user_data.get('album_results', [])
            if not album_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            idx = int(data.replace("dl_album_", ""))
            if idx < len(album_results):
                album = album_results[idx]
                await query.edit_message_text(f"ğŸ“¥ æ­£åœ¨è·å–ä¸“è¾‘ `{album['name']}` çš„æ­Œæ›²åˆ—è¡¨...", parse_mode='Markdown')
                
                api = NeteaseMusicAPI(ncm_cookie)
                songs_to_download = api.get_album_songs(album['album_id'])
                
                if not songs_to_download:
                    await query.message.reply_text("âŒ è·å–ä¸“è¾‘æ­Œæ›²å¤±è´¥")
                    return
        
        if not songs_to_download:
            await query.edit_message_text("æ²¡æœ‰å¯ä¸‹è½½çš„æ­Œæ›²")
            return
        
        # éŸ³è´¨æ˜¾ç¤º
        quality_names = {
            'standard': 'æ ‡å‡†',
            'higher': 'è¾ƒé«˜',
            'exhigh': 'æé«˜',
            'lossless': 'æ— æŸ',
            'hires': 'Hi-Res'
        }
        quality_name = quality_names.get(download_quality, download_quality)
        
        await query.edit_message_text(f"ğŸ”„ å¼€å§‹ä¸‹è½½ {len(songs_to_download)} é¦–æ­Œæ›²...\nğŸ“Š éŸ³è´¨: {quality_name}")
        
        # è¿›åº¦æ¶ˆæ¯
        progress_msg = await query.message.reply_text(
            make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", 0, len(songs_to_download), "å‡†å¤‡å¼€å§‹...")
        )
        last_update_time = [0]
        main_loop = asyncio.get_running_loop()
        
        async def update_progress(current, total, song):
            import time as time_module
            now = time_module.time()
            if now - last_update_time[0] < 1.5:
                return
            last_update_time[0] = now
            try:
                song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                await progress_msg.edit_text(
                    make_progress_message("ğŸ“¥ ä¸‹è½½ä¸­", current, total, song_name),
                    parse_mode='Markdown'
                )
            except:
                pass
        
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        # å¼€å§‹ä¸‹è½½
        # organize æ¨¡å¼ï¼šæŒ‰è‰ºæœ¯å®¶/ä¸“è¾‘æ•´ç†
        is_organize_mode = download_mode == 'organize' and organize_dir
        # æœç´¢ä¸‹è½½ï¼šä¸å›é€€åˆ° QQ éŸ³ä¹ï¼Œåªç”¨ç½‘æ˜“äº‘ä¸‹è½½
        success_results, failed_songs = await asyncio.to_thread(
            downloader.download_missing_songs,
            songs_to_download,
            download_quality,
            sync_progress_callback,
            is_organize_mode,
            organize_dir if is_organize_mode else None,
            False  # fallback_to_qq=Falseï¼Œæœç´¢ä¸‹è½½ä¸å›é€€
        )
        
        # æå–æ–‡ä»¶åˆ—è¡¨
        success_files = [r['file'] for r in success_results]
        
        # MusicTag æ¨¡å¼ç§»åŠ¨æ–‡ä»¶
        moved_files = []
        if download_mode == 'musictag' and musictag_dir and success_files:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            for i, file_path in enumerate(success_files):
                try:
                    src = Path(file_path)
                    if not src.exists():
                        logger.warning(f"æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨: {file_path}")
                        continue
                    dst = musictag_path / src.name
                    shutil.move(str(src), str(dst))
                    moved_files.append(str(dst))
                    # æ›´æ–° success_results ä¸­çš„æ–‡ä»¶è·¯å¾„
                    success_results[i]['file'] = str(dst)
                except Exception as e:
                    logger.error(f"ç§»åŠ¨æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
        
        # åˆ é™¤è¿›åº¦æ¶ˆæ¯
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•ï¼ˆæŒ‰å®é™…å¹³å°ï¼‰
        save_download_record_v2(success_results, failed_songs, download_quality, user_id)
        
        # ç»Ÿè®¡å¹³å°åˆ†å¸ƒ
        ncm_count = sum(1 for r in success_results if r.get('platform') == 'NCM')
        qq_count = sum(1 for r in success_results if r.get('platform') == 'QQ')
        platform_info = f"\n   â€¢ ç½‘æ˜“äº‘: {ncm_count}, QQéŸ³ä¹: {qq_count}" if qq_count > 0 else ""
        
        msg = f"ğŸ“¥ **ä¸‹è½½å®Œæˆ** (éŸ³è´¨: {quality_name})\n\n"
        msg += f"âœ… æˆåŠŸ: {len(success_files)} é¦–{platform_info}\n"
        msg += f"âŒ å¤±è´¥: {len(failed_songs)} é¦–\n"
        
        # æ˜¾ç¤ºæ–‡ä»¶å¤§å°
        if success_files:
            total_size = sum(Path(f).stat().st_size for f in success_files if Path(f).exists())
            if total_size > 1024 * 1024:
                size_str = f"{total_size / 1024 / 1024:.1f} MB"
            else:
                size_str = f"{total_size / 1024:.1f} KB"
            msg += f"ğŸ“¦ æ€»å¤§å°: {size_str}\n"
            
            if moved_files:
                msg += f"\nğŸ“ å·²è½¬ç§»åˆ° MusicTag ç›®å½•"
            elif is_organize_mode:
                msg += f"\nğŸ“ å·²æ•´ç†åˆ°: `{organize_dir}`"
            else:
                msg += f"\nğŸ“ å·²ä¿å­˜åˆ°: `{download_dir}`"
        
        # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ é‡è¯•æŒ‰é’®
        retry_keyboard = None
        if failed_songs:
            # ä¿å­˜å¤±è´¥æ­Œæ›²ä»¥ä¾¿é‡è¯•
            context.user_data['failed_songs_ncm'] = failed_songs
            context.user_data['failed_quality_ncm'] = download_quality
            msg += f"\n\nğŸ’¡ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é‡è¯•å¤±è´¥çš„æ­Œæ›²"
            retry_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(f"ğŸ”„ é‡è¯• {len(failed_songs)} é¦–å¤±è´¥æ­Œæ›²", callback_data="retry_ncm_failed")]
            ])
        
        await query.message.reply_text(msg, parse_mode='Markdown', reply_markup=retry_keyboard)
        
        # å¦‚æœåªä¸‹è½½äº†ä¸€é¦–æ­Œï¼Œå‘é€éŸ³é¢‘é¢„è§ˆ
        if len(songs_to_download) == 1 and success_files:
            audio_path = Path(success_files[0])
            if audio_path.exists() and audio_path.stat().st_size < 50 * 1024 * 1024:  # å°äº 50MB
                try:
                    song = songs_to_download[0]
                    with open(str(audio_path), 'rb') as audio_file:
                        await query.message.reply_audio(
                            audio=audio_file,
                            title=song.get('title', audio_path.stem),
                            performer=song.get('artist', 'Unknown'),
                            caption=f"ğŸµ {song.get('title', '')} - {song.get('artist', '')}"
                        )
                except Exception as e:
                    logger.warning(f"å‘é€éŸ³é¢‘é¢„è§ˆå¤±è´¥: {e}")
        
        # è‡ªåŠ¨æ‰«åº“ï¼ˆorganize æ¨¡å¼ä¹Ÿè§¦å‘ï¼‰
        if success_files and (not moved_files or is_organize_mode):
            binding = get_user_binding(user_id)
            if binding:
                try:
                    user_access_token, user_id_emby = authenticate_emby(
                        EMBY_URL, binding['emby_username'], decrypt_password(binding['emby_password'])
                    )
                    if user_access_token:
                        user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                        if trigger_emby_library_scan(user_auth):
                            await query.message.reply_text("ğŸ”„ å·²è‡ªåŠ¨è§¦å‘ Emby æ‰«åº“")
                except:
                    pass
        
    except Exception as e:
        logger.exception(f"ä¸‹è½½å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")


async def handle_qq_download_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† QQ éŸ³ä¹æœç´¢ç»“æœä¸‹è½½å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        await query.edit_message_text("ä»…ç®¡ç†å‘˜å¯ä½¿ç”¨æ­¤åŠŸèƒ½")
        return
    
    data = query.data
    qq_cookie = get_qq_cookie()
    
    if not qq_cookie:
        await query.edit_message_text("âŒ æœªé…ç½® QQéŸ³ä¹ Cookie")
        return
    
    try:
        from bot.ncm_downloader import QQMusicAPI
        
        # è·å–ä¸‹è½½è®¾ç½®
        ncm_settings = get_ncm_settings()
        download_quality = ncm_settings.get('ncm_quality', 'exhigh')
        download_mode = ncm_settings.get('download_mode', 'local')
        download_dir = ncm_settings.get('download_dir', str(MUSIC_TARGET_DIR))
        musictag_dir = ncm_settings.get('musictag_dir', '')
        organize_dir = ncm_settings.get('organize_dir', '')
        
        download_path = Path(download_dir)
        download_path.mkdir(parents=True, exist_ok=True)
        
        api = QQMusicAPI(qq_cookie, proxy_url=MUSIC_PROXY_URL, proxy_key=MUSIC_PROXY_KEY)
        
        songs_to_download = []
        
        if data.startswith("qdl_song_"):
            # ä¸‹è½½å•æ›²æˆ–å…¨éƒ¨
            search_results = context.user_data.get('qq_search_results', [])
            if not search_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            if data == "qdl_song_all":
                songs_to_download = search_results
            else:
                idx = int(data.replace("qdl_song_", ""))
                if idx < len(search_results):
                    songs_to_download = [search_results[idx]]
        
        elif data.startswith("qdl_album_"):
            # ä¸‹è½½ä¸“è¾‘
            album_results = context.user_data.get('qq_album_results', [])
            if not album_results:
                await query.edit_message_text("æœç´¢ç»“æœå·²è¿‡æœŸï¼Œè¯·é‡æ–°æœç´¢")
                return
            
            idx = int(data.replace("qdl_album_", ""))
            if idx < len(album_results):
                album = album_results[idx]
                await query.edit_message_text(f"ğŸ“¥ æ­£åœ¨è·å– QQéŸ³ä¹ä¸“è¾‘ `{album['name']}` çš„æ­Œæ›²åˆ—è¡¨...", parse_mode='Markdown')
                
                songs_to_download = api.get_album_songs(album['album_id'])
                
                if not songs_to_download:
                    await query.message.reply_text("âŒ è·å–ä¸“è¾‘æ­Œæ›²å¤±è´¥")
                    return
        
        if not songs_to_download:
            await query.edit_message_text("æ²¡æœ‰å¯ä¸‹è½½çš„æ­Œæ›²")
            return
        
        # éŸ³è´¨æ˜¾ç¤º
        quality_names = {
            'standard': 'æ ‡å‡†',
            'higher': 'è¾ƒé«˜',
            'exhigh': 'æé«˜',
            'lossless': 'æ— æŸ',
            'hires': 'Hi-Res'
        }
        quality_name = quality_names.get(download_quality, download_quality)
        
        await query.edit_message_text(f"ğŸ”„ å¼€å§‹ä» QQéŸ³ä¹ ä¸‹è½½ {len(songs_to_download)} é¦–æ­Œæ›²...\nğŸ“Š éŸ³è´¨: {quality_name}")
        
        # è¿›åº¦æ¶ˆæ¯
        progress_msg = await query.message.reply_text(
            make_progress_message("ğŸ“¥ QQéŸ³ä¹ä¸‹è½½ä¸­", 0, len(songs_to_download), "å‡†å¤‡å¼€å§‹...")
        )
        last_update_time = [0]
        main_loop = asyncio.get_running_loop()
        
        async def update_progress(current, total, song):
            import time as time_module
            now = time_module.time()
            if now - last_update_time[0] < 1.5:
                return
            last_update_time[0] = now
            try:
                song_name = f"{song.get('title', '')} - {song.get('artist', '')}"
                await progress_msg.edit_text(
                    make_progress_message("ğŸ“¥ QQéŸ³ä¹ä¸‹è½½ä¸­", current, total, song_name),
                    parse_mode='Markdown'
                )
            except:
                pass
        
        def sync_progress_callback(current, total, song, status=None):
            main_loop.call_soon_threadsafe(
                lambda: asyncio.run_coroutine_threadsafe(update_progress(current, total, song), main_loop)
            )
        
        # å¼€å§‹ä¸‹è½½
        # organize æ¨¡å¼ï¼šæŒ‰è‰ºæœ¯å®¶/ä¸“è¾‘æ•´ç†
        is_organize_mode = download_mode == 'organize' and organize_dir
        success_files, failed_songs = await asyncio.to_thread(
            api.batch_download,
            songs_to_download,
            str(download_path),
            download_quality,
            sync_progress_callback,
            is_organize_mode,
            organize_dir if is_organize_mode else None
        )
        
        # MusicTag æ¨¡å¼ç§»åŠ¨æ–‡ä»¶
        moved_files = []
        if download_mode == 'musictag' and musictag_dir and success_files:
            musictag_path = Path(musictag_dir)
            musictag_path.mkdir(parents=True, exist_ok=True)
            new_success_files = []
            for file_path in success_files:
                try:
                    src = Path(file_path)
                    if not src.exists():
                        logger.warning(f"æºæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡ç§»åŠ¨: {file_path}")
                        new_success_files.append(file_path)  # ä¿ç•™åŸè·¯å¾„
                        continue
                    dst = musictag_path / src.name
                    shutil.move(str(src), str(dst))
                    moved_files.append(str(dst))
                    new_success_files.append(str(dst))  # ä½¿ç”¨æ–°è·¯å¾„
                except Exception as e:
                    logger.error(f"ç§»åŠ¨æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
                    new_success_files.append(file_path)  # å¤±è´¥æ—¶ä¿ç•™åŸè·¯å¾„
            success_files = new_success_files  # æ›´æ–°æ–‡ä»¶åˆ—è¡¨ç”¨äºåç»­è®°å½•
        
        # åˆ é™¤è¿›åº¦æ¶ˆæ¯
        try:
            await progress_msg.delete()
        except:
            pass
        
        # ä¿å­˜ä¸‹è½½è®°å½•
        save_download_record(songs_to_download, success_files, failed_songs, 'QQ', download_quality, user_id)
        
        msg = f"ğŸ“¥ **QQéŸ³ä¹ä¸‹è½½å®Œæˆ** (éŸ³è´¨: {quality_name})\n\n"
        msg += f"âœ… æˆåŠŸ: {len(success_files)} é¦–\n"
        msg += f"âŒ å¤±è´¥: {len(failed_songs)} é¦–\n"
        
        # æ˜¾ç¤ºæ–‡ä»¶å¤§å°
        if success_files:
            total_size = sum(Path(f).stat().st_size for f in success_files if Path(f).exists())
            if total_size > 1024 * 1024:
                size_str = f"{total_size / 1024 / 1024:.1f} MB"
            else:
                size_str = f"{total_size / 1024:.1f} KB"
            msg += f"ğŸ“¦ æ€»å¤§å°: {size_str}\n"
            
            if moved_files:
                msg += f"\nğŸ“ å·²è½¬ç§»åˆ° MusicTag ç›®å½•"
            elif is_organize_mode:
                msg += f"\nğŸ“ å·²æ•´ç†åˆ°: `{organize_dir}`"
            else:
                msg += f"\nğŸ“ å·²ä¿å­˜åˆ°: `{download_dir}`"
        
        # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ é‡è¯•æŒ‰é’®
        retry_keyboard = None
        if failed_songs:
            # ä¿å­˜å¤±è´¥æ­Œæ›²ä»¥ä¾¿é‡è¯•
            context.user_data['failed_songs_qq'] = failed_songs
            context.user_data['failed_quality_qq'] = download_quality
            msg += f"\n\nğŸ’¡ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®é‡è¯•å¤±è´¥çš„æ­Œæ›²"
            retry_keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(f"ğŸ”„ é‡è¯• {len(failed_songs)} é¦–å¤±è´¥æ­Œæ›²", callback_data="retry_qq_failed")]
            ])
        
        await query.message.reply_text(msg, parse_mode='Markdown', reply_markup=retry_keyboard)
        
        # å¦‚æœåªä¸‹è½½äº†ä¸€é¦–æ­Œï¼Œå‘é€éŸ³é¢‘é¢„è§ˆ
        if len(songs_to_download) == 1 and success_files:
            audio_path = Path(success_files[0])
            if audio_path.exists() and audio_path.stat().st_size < 50 * 1024 * 1024:  # å°äº 50MB
                try:
                    song = songs_to_download[0]
                    with open(str(audio_path), 'rb') as audio_file:
                        await query.message.reply_audio(
                            audio=audio_file,
                            title=song.get('title', audio_path.stem),
                            performer=song.get('artist', 'Unknown'),
                            caption=f"ğŸµ {song.get('title', '')} - {song.get('artist', '')}"
                        )
                except Exception as e:
                    logger.warning(f"å‘é€éŸ³é¢‘é¢„è§ˆå¤±è´¥: {e}")
        
        # è‡ªåŠ¨æ‰«åº“ï¼ˆorganize æ¨¡å¼ä¹Ÿè§¦å‘ï¼‰
        if success_files and (not moved_files or is_organize_mode):
            binding = get_user_binding(user_id)
            if binding:
                try:
                    user_access_token, user_id_emby = authenticate_emby(
                        EMBY_URL, binding['emby_username'], decrypt_password(binding['emby_password'])
                    )
                    if user_access_token:
                        user_auth = {'access_token': user_access_token, 'user_id': user_id_emby}
                        if trigger_emby_library_scan(user_auth):
                            await query.message.reply_text("ğŸ”„ å·²è‡ªåŠ¨è§¦å‘ Emby æ‰«åº“")
                except:
                    pass
        
    except Exception as e:
        logger.exception(f"QQéŸ³ä¹ä¸‹è½½å¤±è´¥: {e}")
        await query.message.reply_text(f"âŒ ä¸‹è½½å¤±è´¥: {e}")


# ============================================================
# èœå•å›è°ƒå¤„ç†
# ============================================================

async def handle_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    
    if data == "menu_playlist":
        await query.edit_message_text(
            "ğŸ“‹ **æ­Œå•åŒæ­¥**\n\n"
            "ç›´æ¥å‘é€ QQéŸ³ä¹ æˆ– ç½‘æ˜“äº‘éŸ³ä¹ çš„æ­Œå•é“¾æ¥å³å¯ã€‚\n\n"
            "æ”¯æŒçš„é“¾æ¥æ ¼å¼ï¼š\n"
            "â€¢ `https://y.qq.com/n/ryqq/playlist/...`\n"
            "â€¢ `https://music.163.com/playlist?id=...`\n"
            "â€¢ çŸ­é“¾æ¥ä¹Ÿæ”¯æŒ",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]])
        )
    
    elif data == "menu_upload":
        await query.edit_message_text(
            "ğŸ“¤ **éŸ³ä¹ä¸Šä¼ **\n\n"
            "ç›´æ¥å‘é€éŸ³é¢‘æ–‡ä»¶å³å¯è‡ªåŠ¨ä¸Šä¼ åˆ°æœåŠ¡å™¨ã€‚\n\n"
            "æ”¯æŒæ ¼å¼ï¼šMP3, FLAC, M4A, WAV, OGG, AAC\n\n"
            f"ğŸ“ ä¿å­˜è·¯å¾„: `{MUSIC_TARGET_DIR}`",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]])
        )
    
    elif data == "menu_settings":
        user_id = str(query.from_user.id)
        binding = get_user_binding(user_id)
        
        text = "âš™ï¸ **è®¾ç½®**\n\n"
        if binding:
            text += f"âœ… å·²ç»‘å®š Emby: `{binding['emby_username']}`\n\n"
            text += "ä½¿ç”¨ /unbind è§£é™¤ç»‘å®š\n"
            text += "ä½¿ç”¨ /bind <ç”¨æˆ·å> <å¯†ç > é‡æ–°ç»‘å®š"
        else:
            text += "âŒ å°šæœªç»‘å®š Emby è´¦æˆ·\n\n"
            text += "ä½¿ç”¨ /bind <ç”¨æˆ·å> <å¯†ç > è¿›è¡Œç»‘å®š"
        
        await query.edit_message_text(text, parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]]))
    
    elif data == "menu_status":
        stats = get_stats()
        text = f"""
ğŸ“Š **çŠ¶æ€**

ğŸµ åª’ä½“åº“: {stats.get('library_songs', 0)} é¦–
ğŸ‘¥ ç”¨æˆ·: {stats.get('users', 0)}
ğŸ“‹ æ­Œå•: {stats.get('playlists', 0)} ä¸ª
ğŸ“¤ ä¸Šä¼ : {stats.get('uploads', 0)} ä¸ª
"""
        await query.edit_message_text(text, parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="menu_back")]]))
    
    elif data == "menu_back":
        await query.edit_message_text("è¯·é€‰æ‹©åŠŸèƒ½ï¼š", reply_markup=get_main_menu_keyboard())


async def handle_retry_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†ä¸‹è½½å¤±è´¥é‡è¯•å›è°ƒ"""
    query = update.callback_query
    await query.answer()
    
    user_id = str(query.from_user.id)
    if user_id not in ADMIN_USER_IDS:
        await query.edit_message_text("æ— æƒæ‰§è¡Œæ­¤æ“ä½œ")
        return
    
    data = query.data
    
    if data == "retry_ncm_failed":
        # é‡è¯•ç½‘æ˜“äº‘å¤±è´¥çš„æ­Œæ›²
        failed_songs = context.user_data.get('failed_songs_ncm', [])
        quality = context.user_data.get('failed_quality_ncm', 'exhigh')
        
        if not failed_songs:
            await query.edit_message_text("âŒ æ²¡æœ‰éœ€è¦é‡è¯•çš„æ­Œæ›²")
            return
        
        await query.edit_message_text(f"ğŸ”„ æ­£åœ¨é‡è¯• {len(failed_songs)} é¦–æ­Œæ›²...")
        
        # é‡æ–°è®¾ç½®æœç´¢ç»“æœå¹¶è§¦å‘ä¸‹è½½
        context.user_data['search_results'] = failed_songs
        context.user_data['failed_songs_ncm'] = []  # æ¸…ç©º
        
        # æ„é€ ä¸€ä¸ªå‡çš„ callback data æ¥å¤ç”¨ä¸‹è½½é€»è¾‘
        query.data = "dl_song_all"
        await handle_search_download_callback(update, context)
        
    elif data == "retry_qq_failed":
        # é‡è¯• QQ éŸ³ä¹å¤±è´¥çš„æ­Œæ›²
        failed_songs = context.user_data.get('failed_songs_qq', [])
        quality = context.user_data.get('failed_quality_qq', 'exhigh')
        
        if not failed_songs:
            await query.edit_message_text("âŒ æ²¡æœ‰éœ€è¦é‡è¯•çš„æ­Œæ›²")
            return
        
        await query.edit_message_text(f"ğŸ”„ æ­£åœ¨é‡è¯• {len(failed_songs)} é¦–æ­Œæ›²...")
        
        # é‡æ–°è®¾ç½®æœç´¢ç»“æœå¹¶è§¦å‘ä¸‹è½½
        context.user_data['qq_search_results'] = failed_songs
        context.user_data['failed_songs_qq'] = []  # æ¸…ç©º
        
        # æ„é€ ä¸€ä¸ªå‡çš„ callback data æ¥å¤ç”¨ä¸‹è½½é€»è¾‘
        query.data = "qdl_song_all"
        await handle_qq_download_callback(update, context)


# ============================================================
# æ–‡ä»¶æ•´ç†å™¨
# ============================================================

# å…¨å±€å˜é‡å­˜å‚¨ application å®ä¾‹ï¼Œç”¨äºå‘é€é€šçŸ¥
_telegram_app = None


def file_organizer_callback(source_path: str, target_path: str):
    """æ–‡ä»¶æ•´ç†å®Œæˆåçš„å›è°ƒ - æ—¥å¿—å·²åœ¨ file_organizer ä¸­è®°å½•"""
    pass  # æ—¥å¿—å·²åœ¨ file_organizer.py ä¸­ç¾åŒ–è¾“å‡º


async def start_file_organizer_if_enabled(application):
    """å¦‚æœé…ç½®äº†å¹¶å¯ç”¨äº†æ–‡ä»¶æ•´ç†å™¨ï¼Œåˆ™å¯åŠ¨å®ƒ"""
    global _telegram_app
    _telegram_app = application
    
    try:
        if not database_conn:
            return
        
        cursor = database_conn.cursor()
        
        # æ£€æŸ¥æ˜¯å¦å¯ç”¨
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_enabled',))
        row = cursor.fetchone()
        enabled = row and (row[0] if isinstance(row, tuple) else row['value']) == 'true'
        
        if not enabled:
            logger.info("ğŸ“ æ–‡ä»¶æ•´ç†å™¨æœªå¯ç”¨")
            return
        
        # è·å–é…ç½®
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_source_dir',))
        row = cursor.fetchone()
        source_dir = (row[0] if isinstance(row, tuple) else row['value']) if row else ''
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_target_dir',))
        row = cursor.fetchone()
        target_dir = (row[0] if isinstance(row, tuple) else row['value']) if row else ''
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_template',))
        row = cursor.fetchone()
        template = (row[0] if isinstance(row, tuple) else row['value']) if row else '{album_artist}/{album}'
        
        cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('organize_on_conflict',))
        row = cursor.fetchone()
        on_conflict = (row[0] if isinstance(row, tuple) else row['value']) if row else 'skip'
        
        if not source_dir or not target_dir:
            logger.info("ğŸ“ æ–‡ä»¶æ•´ç†å™¨æœªé…ç½®æºç›®å½•æˆ–ç›®æ ‡ç›®å½•")
            return
        
        # å¯åŠ¨ç›‘æ§
        from bot.file_organizer import start_watcher
        watcher = start_watcher(
            source_dir, target_dir, template, on_conflict,
            callback=file_organizer_callback
        )
        
        # å‘é€ Telegram é€šçŸ¥ç»™æ‰€æœ‰ç®¡ç†å‘˜
        for admin_id in ADMIN_USER_IDS:
            try:
                msg = (
                    "ğŸ“ *æ–‡ä»¶æ•´ç†å™¨å·²å¯åŠ¨*\n\n"
                    f"ğŸ“‚ ç›‘æ§ç›®å½•: `{source_dir}`\n"
                    f"ğŸµ æ•´ç†ç›®å½•: `{target_dir}`\n"
                    f"ğŸ“‹ æ•´ç†æ¨¡æ¿: `{template}`\n"
                    f"âš™ï¸ å†²çªå¤„ç†: `{on_conflict}`"
                )
                await application.bot.send_message(
                    chat_id=admin_id,
                    text=msg,
                    parse_mode='Markdown'
                )
            except Exception as e:
                logger.debug(f"å‘é€æ•´ç†å™¨å¯åŠ¨é€šçŸ¥å¤±è´¥: {e}")
        
    except Exception as e:
        logger.error(f"å¯åŠ¨æ–‡ä»¶æ•´ç†å™¨å¤±è´¥: {e}")


async def emby_webhook_notify_job(application):
    """å¤„ç† Emby Webhook é€šçŸ¥å¹¶å‘é€åˆ° Telegram"""
    from bot.web import get_webhook_notifications, set_webhook_bot
    
    # è®¾ç½® Bot å®ä¾‹å¼•ç”¨
    set_webhook_bot(application.bot)
    
    while True:
        try:
            if not EMBY_WEBHOOK_NOTIFY:
                await asyncio.sleep(60)
                continue
            
            # è·å–å¾…å¤„ç†çš„é€šçŸ¥
            notifications = get_webhook_notifications()
            
            if notifications and ADMIN_USER_IDS:
                for notif in notifications:
                    try:
                        if notif.get('type') == 'library_new':
                            title = notif.get('title', 'æœªçŸ¥')
                            artist = notif.get('artist', '')
                            album = notif.get('album', '')
                            item_type = notif.get('item_type', '').lower()
                            
                            if item_type == 'audio':
                                emoji = "ğŸµ"
                                type_name = "æ­Œæ›²"
                            elif item_type == 'musicalbum':
                                emoji = "ğŸ’¿"
                                type_name = "ä¸“è¾‘"
                            elif item_type == 'musicartist':
                                emoji = "ğŸ¤"
                                type_name = "è‰ºæœ¯å®¶"
                            else:
                                emoji = "ğŸ“€"
                                type_name = "åª’ä½“"
                            
                            msg = f"{emoji} *Emby æ–°{type_name}å…¥åº“*\n\n"
                            msg += f"ğŸµ åç§°: {title}\n"
                            if artist:
                                msg += f"ğŸ¤ è‰ºæœ¯å®¶: {artist}\n"
                            if album:
                                msg += f"ğŸ’¿ ä¸“è¾‘: {album}"
                            
                            # å‘é€ç»™æ‰€æœ‰ç®¡ç†å‘˜
                            for admin_id in ADMIN_USER_IDS:
                                try:
                                    await application.bot.send_message(
                                        chat_id=admin_id,
                                        text=msg,
                                        parse_mode='Markdown'
                                    )
                                except:
                                    pass
                            
                    except Exception as e:
                        logger.debug(f"å‘é€ Webhook é€šçŸ¥å¤±è´¥: {e}")
            
        except Exception as e:
            logger.error(f"Webhook é€šçŸ¥ä»»åŠ¡å‡ºé”™: {e}")
        
        await asyncio.sleep(30)  # æ¯ 30 ç§’æ£€æŸ¥ä¸€æ¬¡


async def sync_library_cache():
    """åŒæ­¥ Emby åª’ä½“åº“ç¼“å­˜"""
    global emby_library_data
    
    try:
        if not emby_auth.get('access_token') or not emby_auth.get('user_id'):
            return
        
        headers = {
            'X-Emby-Token': emby_auth['access_token'],
            'X-Emby-Client': EMBY_CLIENT_NAME,
            'X-Emby-Device-Name': DEVICE_ID,
            'X-Emby-Device-Id': DEVICE_ID
        }
        
        # è·å–éŸ³ä¹åº“
        url = f"{EMBY_URL}/Users/{emby_auth['user_id']}/Items"
        params = {
            'IncludeItemTypes': 'Audio',
            'Recursive': 'true',
            'Fields': 'Artists,Album,AlbumArtist',
            'Limit': 50000
        }
        
        resp = requests_session.get(url, headers=headers, params=params, timeout=60)
        if resp.status_code == 200:
            data = resp.json()
            items = data.get('Items', [])
            
            # è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼ï¼ˆä¸ scan_emby_library ä¸€è‡´ï¼‰
            converted_items = []
            for item in items:
                artists = "/".join([a.get('Name', '') for a in item.get('ArtistItems', [])])
                if not artists:
                    # å…¼å®¹ä¸åŒçš„ Artists æ ¼å¼
                    artists = "/".join(item.get('Artists', []))
                converted_items.append({
                    'id': str(item.get('Id', '')),
                    'title': html.unescape(item.get('Name', '')),
                    'artist': html.unescape(artists)
                })
            
            emby_library_data = converted_items
            
            # ä¿å­˜åˆ°ç¼“å­˜æ–‡ä»¶
            with open(LIBRARY_CACHE_FILE, 'w', encoding='utf-8') as f:
                json.dump(converted_items, f, ensure_ascii=False)
            
            logger.info(f"åª’ä½“åº“ç¼“å­˜å·²æ›´æ–°: {len(converted_items)} é¦–æ­Œæ›²")
            
    except Exception as e:
        logger.error(f"åŒæ­¥åª’ä½“åº“ç¼“å­˜å¤±è´¥: {e}")


# ============================================================
# æ¶ˆæ¯å¤„ç†
# ============================================================

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message
    
    # å¤„ç†éŸ³é¢‘/æ–‡æ¡£ä¸Šä¼ 
    if message.audio or message.document:
        handled = await handle_audio_upload(update, context)
        if handled:
            return
    
    # å¤„ç†æ–‡æœ¬æ¶ˆæ¯ï¼ˆæ­Œå•é“¾æ¥ï¼‰
    if message.text:
        handled = await handle_playlist_url(update, context)
        if handled:
            return


# ============================================================
# ä¸»ç¨‹åº
# ============================================================

def main():
    global requests_session
    
    if not TELEGRAM_TOKEN:
        logger.critical("ç¼ºå°‘ TELEGRAM_BOT_TOKENï¼ˆæˆ– TELEGRAM_TOKENï¼‰ï¼")
        return
    if not EMBY_URL:
        logger.critical("ç¼ºå°‘ EMBY_URLï¼")
        return
    
    requests_session = create_requests_session()
    init_database()
    
    # Emby è®¤è¯
    if EMBY_USERNAME and EMBY_PASSWORD:
        token, user_id = authenticate_emby(EMBY_URL, EMBY_USERNAME, EMBY_PASSWORD)
        if token:
            emby_auth['access_token'] = token
            emby_auth['user_id'] = user_id
    
    # åŠ è½½åª’ä½“åº“ç¼“å­˜
    global emby_library_data
    if LIBRARY_CACHE_FILE.exists():
        try:
            with open(LIBRARY_CACHE_FILE, 'r', encoding='utf-8') as f:
                cached_data = json.load(f)
            
            # æ£€æŸ¥ç¼“å­˜æ ¼å¼ï¼Œå¦‚æœæ˜¯æ—§æ ¼å¼ï¼ˆæœ‰ Name å­—æ®µï¼‰åˆ™è½¬æ¢
            if cached_data and isinstance(cached_data, list) and len(cached_data) > 0:
                first_item = cached_data[0]
                if 'Name' in first_item and 'title' not in first_item:
                    # æ—§æ ¼å¼ï¼Œéœ€è¦è½¬æ¢
                    logger.info("æ£€æµ‹åˆ°æ—§æ ¼å¼ç¼“å­˜ï¼Œæ­£åœ¨è½¬æ¢...")
                    converted = []
                    for item in cached_data:
                        artists = "/".join([a.get('Name', '') for a in item.get('ArtistItems', [])])
                        if not artists:
                            artists = "/".join(item.get('Artists', []))
                        converted.append({
                            'id': str(item.get('Id', '')),
                            'title': html.unescape(item.get('Name', '')),
                            'artist': html.unescape(artists)
                        })
                    emby_library_data = converted
                    # ä¿å­˜è½¬æ¢åçš„ç¼“å­˜
                    with open(LIBRARY_CACHE_FILE, 'w', encoding='utf-8') as f:
                        json.dump(converted, f, ensure_ascii=False)
                    logger.info(f"ç¼“å­˜æ ¼å¼å·²è½¬æ¢: {len(converted)} é¦–æ­Œæ›²")
                else:
                    # æ–°æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
                    emby_library_data = cached_data
                    logger.info(f"ä»ç¼“å­˜åŠ è½½ {len(emby_library_data)} é¦–æ­Œæ›²")
            else:
                emby_library_data = cached_data
                logger.info(f"ä»ç¼“å­˜åŠ è½½ {len(emby_library_data)} é¦–æ­Œæ›²")
        except Exception as e:
            logger.warning(f"åŠ è½½ç¼“å­˜å¤±è´¥: {e}")
            if emby_auth['access_token']:
                scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
    else:
        if emby_auth['access_token']:
            scan_emby_library(True, emby_auth['user_id'], emby_auth['access_token'])
    
    # åˆå§‹åŒ–ä¸‹è½½ç®¡ç†å™¨
    global download_manager
    download_manager = _init_dm(str(DATABASE_FILE), max_concurrent=3, max_retries=3, retry_delay=2.0)
    logger.info("ä¸‹è½½ç®¡ç†å™¨å·²åˆå§‹åŒ–")
    
    # å¯åŠ¨ Bot
    builder = Application.builder().token(TELEGRAM_TOKEN).connect_timeout(30).read_timeout(30).write_timeout(30)
    
    # å¦‚æœé…ç½®äº† Local Bot API Server
    if TELEGRAM_API_URL:
        builder = builder.base_url(TELEGRAM_API_URL).base_file_url(TELEGRAM_API_URL.replace('/bot', '/file/bot'))
        logger.info(f"ä½¿ç”¨ Local Bot API Server: {TELEGRAM_API_URL}")
    
    app = builder.build()
    
    # å‘½ä»¤ï¼ˆæ”¯æŒçŸ­å‘½ä»¤å’Œå®Œæ•´å‘½ä»¤ï¼‰
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("help", cmd_help))
    app.add_handler(CommandHandler(["bind", "b"], cmd_bind))  # /b ç»‘å®š
    app.add_handler(CommandHandler("unbind", cmd_unbind))
    app.add_handler(CommandHandler(["status", "s"], cmd_status))  # /s çŠ¶æ€
    app.add_handler(CommandHandler(["rescan", "scan", "rs"], cmd_rescan))  # /scan /rs æ‰«åº“
    app.add_handler(CommandHandler("ncmstatus", cmd_ncm_status))
    app.add_handler(CommandHandler(["search", "ss"], cmd_search))  # /ss ç½‘æ˜“äº‘æœç´¢
    app.add_handler(CommandHandler(["album", "al"], cmd_album))  # /al ç½‘æ˜“äº‘ä¸“è¾‘
    app.add_handler(CommandHandler(["qqsearch", "qs"], cmd_qq_search))  # /qs QQéŸ³ä¹æœç´¢
    app.add_handler(CommandHandler(["qqalbum", "qa"], cmd_qq_album))  # /qa QQéŸ³ä¹ä¸“è¾‘
    app.add_handler(CommandHandler(["schedule", "sub"], cmd_schedule))  # /sub è®¢é˜…åˆ—è¡¨
    app.add_handler(CommandHandler(["unschedule", "unsub"], cmd_unschedule))  # /unsub å–æ¶ˆè®¢é˜…
    app.add_handler(CommandHandler(["scaninterval", "si"], cmd_scaninterval))  # /si Embyæ‰«æé—´éš”
    app.add_handler(CommandHandler(["syncinterval", "syi"], cmd_syncinterval))  # /syi æ­Œå•åŒæ­¥é—´éš”
    app.add_handler(CommandHandler(["request", "req"], cmd_request))  # /req ç”³è¯·
    app.add_handler(CommandHandler(["myrequests", "mr"], cmd_myrequests))  # /mr æˆ‘çš„ç”³è¯·
    app.add_handler(CommandHandler(["dlstatus", "ds"], cmd_download_status))  # /ds ä¸‹è½½çŠ¶æ€
    app.add_handler(CommandHandler(["dlqueue", "dq"], cmd_download_queue))  # /dq ä¸‹è½½é˜Ÿåˆ—
    app.add_handler(CommandHandler(["dlhistory", "dh"], cmd_download_history))  # /dh ä¸‹è½½å†å²
    
    # å›è°ƒ
    app.add_handler(CallbackQueryHandler(handle_match_callback, pattern='^match_'))
    app.add_handler(CallbackQueryHandler(handle_download_callback, pattern='^download_'))
    app.add_handler(CallbackQueryHandler(handle_unmatched_page_callback, pattern='^unmatched_page_'))  # æœªåŒ¹é…æ­Œæ›²ç¿»é¡µ
    app.add_handler(CallbackQueryHandler(handle_preview_callback, pattern='^preview_'))  # ç½‘æ˜“äº‘è¯•å¬
    app.add_handler(CallbackQueryHandler(handle_qq_preview_callback, pattern='^qpreview_'))  # QQéŸ³ä¹è¯•å¬
    app.add_handler(CallbackQueryHandler(handle_search_download_callback, pattern='^dl_'))
    app.add_handler(CallbackQueryHandler(handle_qq_download_callback, pattern='^qdl_'))  # QQéŸ³ä¹ä¸‹è½½
    app.add_handler(CallbackQueryHandler(handle_sync_callback, pattern='^sync_'))
    app.add_handler(CallbackQueryHandler(handle_request_callback, pattern='^req_'))
    app.add_handler(CallbackQueryHandler(handle_retry_callback, pattern='^retry_'))  # é‡è¯•å¤±è´¥ä¸‹è½½
    app.add_handler(CallbackQueryHandler(handle_menu_callback, pattern='^menu_'))
    
    # Inline æŸ¥è¯¢ï¼ˆä»»æ„èŠå¤©ä¸­ @bot æ­Œåï¼‰
    app.add_handler(InlineQueryHandler(handle_inline_query))
    
    # æ¶ˆæ¯
    app.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_message))
    
    logger.info("Bot å¯åŠ¨æˆåŠŸï¼")
    ncm_cookie = get_ncm_cookie()
    if ncm_cookie:
        logger.info("å·²é…ç½®ç½‘æ˜“äº‘ Cookieï¼Œè‡ªåŠ¨ä¸‹è½½åŠŸèƒ½å·²å¯ç”¨")
    
    # å¯åŠ¨å®šæ—¶åŒæ­¥ä»»åŠ¡ & æ³¨å†Œå‘½ä»¤èœå•
    async def post_init(application):
        # æ³¨å†Œå‘½ä»¤èœå•ï¼ˆç”¨æˆ·è¾“å…¥ / æ—¶æ˜¾ç¤ºï¼‰
        from telegram import BotCommand
        commands = [
            BotCommand("start", "ğŸ  ä¸»èœå•"),
            BotCommand("help", "â“ å¸®åŠ©"),
            BotCommand("b", "ğŸ”‘ ç»‘å®šEmby (bind)"),
            BotCommand("s", "ğŸ“Š çŠ¶æ€ (status)"),
            BotCommand("ss", "ğŸ” ç½‘æ˜“äº‘æœæ­Œ"),
            BotCommand("al", "ğŸ’¿ ç½‘æ˜“äº‘ä¸“è¾‘"),
            BotCommand("qs", "ğŸ” QQéŸ³ä¹æœæ­Œ"),
            BotCommand("qa", "ğŸ’¿ QQéŸ³ä¹ä¸“è¾‘"),
            BotCommand("req", "ğŸ“ ç”³è¯·æ­Œæ›²"),
            BotCommand("mr", "ğŸ“‹ æˆ‘çš„ç”³è¯·"),
            BotCommand("sub", "ğŸ“… è®¢é˜…åˆ—è¡¨"),
            BotCommand("unsub", "âŒ å–æ¶ˆè®¢é˜…"),
            BotCommand("scan", "ğŸ”„ æ‰«æEmby"),
            BotCommand("si", "â±ï¸ æ‰«æé—´éš”"),
            BotCommand("ds", "ğŸ“Š ä¸‹è½½çŠ¶æ€"),
            BotCommand("dq", "ğŸ“¥ ä¸‹è½½é˜Ÿåˆ—"),
        ]
        await application.bot.set_my_commands(commands)
        logger.info("å·²æ³¨å†Œ Telegram å‘½ä»¤èœå•")
        
        # å¯åŠ¨ä¸‹è½½ç®¡ç†å™¨
        if download_manager:
            await download_manager.start()
            logger.info("ä¸‹è½½ç®¡ç†å™¨å·²å¯åŠ¨")
        
        # å¯åŠ¨å®šæ—¶åŒæ­¥ä»»åŠ¡
        asyncio.create_task(scheduled_sync_job(application))
        sync_interval = get_playlist_sync_interval()
        logger.info(
            f"å®šæ—¶åŒæ­¥ä»»åŠ¡å³å°†å¯åŠ¨ (é»˜è®¤é—´éš”: {sync_interval} åˆ†é’Ÿ, è½®è¯¢ {PLAYLIST_SYNC_POLL_INTERVAL_SECONDS} ç§’)"
        )
        
        # å¯åŠ¨å®šæ—¶æ‰«æ Emby åª’ä½“åº“ä»»åŠ¡
        asyncio.create_task(scheduled_emby_scan_job(application))
        scan_interval = EMBY_SCAN_INTERVAL
        try:
            if database_conn:
                cursor = database_conn.cursor()
                cursor.execute('SELECT value FROM bot_settings WHERE key = ?', ('emby_scan_interval',))
                row = cursor.fetchone()
                if row:
                    scan_interval = int(row[0] if isinstance(row, tuple) else row['value'])
        except:
            pass
        if scan_interval > 0:
            logger.info(f"Emby åª’ä½“åº“è‡ªåŠ¨æ‰«æå·²å¯åŠ¨ (æ¯ {scan_interval} å°æ—¶)")
        else:
            logger.info("Emby åª’ä½“åº“è‡ªåŠ¨æ‰«ææœªå¯ç”¨")
        
        # å¯åŠ¨æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šä»»åŠ¡
        asyncio.create_task(daily_stats_job(application))
        logger.info("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Šä»»åŠ¡å·²å¯åŠ¨ (æ¯å¤© 9:00)")
        
        # å¯åŠ¨ Cookie è¿‡æœŸæ£€æŸ¥ä»»åŠ¡
        asyncio.create_task(cookie_check_job(application))
        logger.info("Cookie è¿‡æœŸæ£€æŸ¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯6å°æ—¶)")
        
        # è®¾ç½® Webhook Bot å®ä¾‹ï¼ˆç”¨äºç›´æ¥å‘é€é€šçŸ¥ï¼‰
        from bot.web import set_webhook_bot
        set_webhook_bot(application.bot)
        logger.info("Webhook Bot å®ä¾‹å·²è®¾ç½®")
        
        # å¯åŠ¨ Emby Webhook é€šçŸ¥ä»»åŠ¡
        asyncio.create_task(emby_webhook_notify_job(application))
        if EMBY_WEBHOOK_NOTIFY:
            logger.info("Emby Webhook é€šçŸ¥ä»»åŠ¡å·²å¯åŠ¨ (æ¯30ç§’æ£€æŸ¥)")
        else:
            logger.info("Emby Webhook é€šçŸ¥å·²ç¦ç”¨")
        
        # å¯åŠ¨æ–‡ä»¶æ•´ç†å™¨ï¼ˆå¦‚æœå·²é…ç½®å¹¶å¯ç”¨ï¼‰
        await start_file_organizer_if_enabled(application)
    
    app.post_init = post_init
    
    # å¦‚æœé…ç½®äº† Pyrogramï¼Œå¯åŠ¨å¤§æ–‡ä»¶æ¥æ”¶åŠŸèƒ½
    if TG_API_ID and TG_API_HASH:
        asyncio.get_event_loop().run_until_complete(start_pyrogram_client())
    
    # å…¨å±€é”™è¯¯å¤„ç†å™¨ï¼Œç”¨äºæ•è·æœªå¤„ç†å¼‚å¸¸å¹¶è®°å½•/é€šçŸ¥ç®¡ç†å‘˜
    async def global_error_handler(update, context):
        import traceback
        try:
            tb = traceback.format_exc()
        except Exception:
            tb = 'æ— æ³•è·å– traceback'
        # è®°å½•åˆ°æ—¥å¿—
        logger.error(f"Unhandled exception in update handler:\n{tb}")
        # å‘é€ç»™ç®¡ç†å‘˜ï¼ˆé¿å…åœ¨ç¾¤é‡Œé‡å¤å‘é€å¤±è´¥æ—¶æŠ›å‡ºå¼‚å¸¸ï¼‰
        try:
            text = "âŒ æœºå™¨äººå‘ç”Ÿæœªå¤„ç†å¼‚å¸¸ï¼Œå·²è®°å½•ã€‚è¯·æ£€æŸ¥æ—¥å¿—ã€‚"
            for admin in ADMIN_USER_IDS:
                try:
                    await app.bot.send_message(chat_id=admin, text=text)
                except Exception:
                    pass
        except Exception:
            pass

    # æ³¨å†Œå…¨å±€é”™è¯¯å¤„ç†å™¨ï¼ˆtelegram.ext ä¼šåœ¨å¤„ç† update æ—¶è°ƒç”¨ï¼‰
    try:
        app.add_error_handler(global_error_handler)
    except Exception:
        # å…¼å®¹ä¸åŒç‰ˆæœ¬çš„ python-telegram-botï¼ˆæŸäº›æ—§ç‰ˆä½¿ç”¨ä¸åŒæ¥å£ï¼‰
        try:
            app.add_error_handler(lambda u, c: None)
        except:
            pass

    app.run_polling()


if __name__ == '__main__':
    main()
